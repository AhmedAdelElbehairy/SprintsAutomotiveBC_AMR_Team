
MCU_To_MCU_Bluetooth_Communication.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00002136  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000b0  00800060  00002136  000021ca  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000650  00800110  00800110  0000227a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000227a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000022ac  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000500  00000000  00000000  000022e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004b86  00000000  00000000  000027e8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000019d1  00000000  00000000  0000736e  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000031f9  00000000  00000000  00008d3f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000aac  00000000  00000000  0000bf38  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001b47  00000000  00000000  0000c9e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000354a  00000000  00000000  0000e52b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000488  00000000  00000000  00011a75  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 57 00 	jmp	0xae	; 0xae <__ctors_end>
       4:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
       8:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
       c:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      10:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      14:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      18:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      1c:	0c 94 59 02 	jmp	0x4b2	; 0x4b2 <__vector_7>
      20:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      24:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      28:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      2c:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      30:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      34:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      38:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      3c:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      40:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      44:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      48:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      4c:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      50:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      54:	08 00       	.word	0x0008	; ????
      56:	00 00       	nop
      58:	be 92       	st	-X, r11
      5a:	24 49       	sbci	r18, 0x94	; 148
      5c:	12 3e       	cpi	r17, 0xE2	; 226
      5e:	ab aa       	std	Y+51, r10	; 0x33
      60:	aa 2a       	or	r10, r26
      62:	be cd       	rjmp	.-1156   	; 0xfffffbe0 <__eeprom_end+0xff7efbe0>
      64:	cc cc       	rjmp	.-1640   	; 0xfffff9fe <__eeprom_end+0xff7ef9fe>
      66:	4c 3e       	cpi	r20, 0xEC	; 236
      68:	00 00       	nop
      6a:	00 80       	ld	r0, Z
      6c:	be ab       	std	Y+54, r27	; 0x36
      6e:	aa aa       	std	Y+50, r10	; 0x32
      70:	aa 3e       	cpi	r26, 0xEA	; 234
      72:	00 00       	nop
      74:	00 00       	nop
      76:	bf 00       	.word	0x00bf	; ????
      78:	00 00       	nop
      7a:	80 3f       	cpi	r24, 0xF0	; 240
      7c:	00 00       	nop
      7e:	00 00       	nop
      80:	00 08       	sbc	r0, r0
      82:	41 78       	andi	r20, 0x81	; 129
      84:	d3 bb       	out	0x13, r29	; 19
      86:	43 87       	std	Z+11, r20	; 0x0b
      88:	d1 13       	cpse	r29, r17
      8a:	3d 19       	sub	r19, r13
      8c:	0e 3c       	cpi	r16, 0xCE	; 206
      8e:	c3 bd       	out	0x23, r28	; 35
      90:	42 82       	std	Z+2, r4	; 0x02
      92:	ad 2b       	or	r26, r29
      94:	3e 68       	ori	r19, 0x8E	; 142
      96:	ec 82       	std	Y+4, r14	; 0x04
      98:	76 be       	out	0x36, r7	; 54
      9a:	d9 8f       	std	Y+25, r29	; 0x19
      9c:	e1 a9       	ldd	r30, Z+49	; 0x31
      9e:	3e 4c       	sbci	r19, 0xCE	; 206
      a0:	80 ef       	ldi	r24, 0xF0	; 240
      a2:	ff be       	out	0x3f, r15	; 63
      a4:	01 c4       	rjmp	.+2050   	; 0x8a8 <__stack+0x49>
      a6:	ff 7f       	andi	r31, 0xFF	; 255
      a8:	3f 00       	.word	0x003f	; ????
      aa:	00 00       	nop
	...

000000ae <__ctors_end>:
      ae:	11 24       	eor	r1, r1
      b0:	1f be       	out	0x3f, r1	; 63
      b2:	cf e5       	ldi	r28, 0x5F	; 95
      b4:	d8 e0       	ldi	r29, 0x08	; 8
      b6:	de bf       	out	0x3e, r29	; 62
      b8:	cd bf       	out	0x3d, r28	; 61

000000ba <__do_copy_data>:
      ba:	11 e0       	ldi	r17, 0x01	; 1
      bc:	a0 e6       	ldi	r26, 0x60	; 96
      be:	b0 e0       	ldi	r27, 0x00	; 0
      c0:	e6 e3       	ldi	r30, 0x36	; 54
      c2:	f1 e2       	ldi	r31, 0x21	; 33
      c4:	02 c0       	rjmp	.+4      	; 0xca <__do_copy_data+0x10>
      c6:	05 90       	lpm	r0, Z+
      c8:	0d 92       	st	X+, r0
      ca:	a0 31       	cpi	r26, 0x10	; 16
      cc:	b1 07       	cpc	r27, r17
      ce:	d9 f7       	brne	.-10     	; 0xc6 <__do_copy_data+0xc>

000000d0 <__do_clear_bss>:
      d0:	27 e0       	ldi	r18, 0x07	; 7
      d2:	a0 e1       	ldi	r26, 0x10	; 16
      d4:	b1 e0       	ldi	r27, 0x01	; 1
      d6:	01 c0       	rjmp	.+2      	; 0xda <.do_clear_bss_start>

000000d8 <.do_clear_bss_loop>:
      d8:	1d 92       	st	X+, r1

000000da <.do_clear_bss_start>:
      da:	a0 36       	cpi	r26, 0x60	; 96
      dc:	b2 07       	cpc	r27, r18
      de:	e1 f7       	brne	.-8      	; 0xd8 <.do_clear_bss_loop>
      e0:	0e 94 dd 0d 	call	0x1bba	; 0x1bba <main>
      e4:	0c 94 99 10 	jmp	0x2132	; 0x2132 <_exit>

000000e8 <__bad_interrupt>:
      e8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ec <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
      ec:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      ee:	03 96       	adiw	r24, 0x03	; 3
      f0:	92 83       	std	Z+2, r25	; 0x02
      f2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
      f4:	2f ef       	ldi	r18, 0xFF	; 255
      f6:	3f ef       	ldi	r19, 0xFF	; 255
      f8:	34 83       	std	Z+4, r19	; 0x04
      fa:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      fc:	96 83       	std	Z+6, r25	; 0x06
      fe:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     100:	90 87       	std	Z+8, r25	; 0x08
     102:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     104:	10 82       	st	Z, r1
     106:	08 95       	ret

00000108 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     108:	fc 01       	movw	r30, r24
     10a:	11 86       	std	Z+9, r1	; 0x09
     10c:	10 86       	std	Z+8, r1	; 0x08
     10e:	08 95       	ret

00000110 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     110:	cf 93       	push	r28
     112:	df 93       	push	r29
     114:	9c 01       	movw	r18, r24
     116:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     118:	dc 01       	movw	r26, r24
     11a:	11 96       	adiw	r26, 0x01	; 1
     11c:	cd 91       	ld	r28, X+
     11e:	dc 91       	ld	r29, X
     120:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     122:	d3 83       	std	Z+3, r29	; 0x03
     124:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     126:	8c 81       	ldd	r24, Y+4	; 0x04
     128:	9d 81       	ldd	r25, Y+5	; 0x05
     12a:	95 83       	std	Z+5, r25	; 0x05
     12c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     12e:	8c 81       	ldd	r24, Y+4	; 0x04
     130:	9d 81       	ldd	r25, Y+5	; 0x05
     132:	dc 01       	movw	r26, r24
     134:	13 96       	adiw	r26, 0x03	; 3
     136:	7c 93       	st	X, r23
     138:	6e 93       	st	-X, r22
     13a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     13c:	7d 83       	std	Y+5, r23	; 0x05
     13e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     140:	31 87       	std	Z+9, r19	; 0x09
     142:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     144:	f9 01       	movw	r30, r18
     146:	80 81       	ld	r24, Z
     148:	8f 5f       	subi	r24, 0xFF	; 255
     14a:	80 83       	st	Z, r24
}
     14c:	df 91       	pop	r29
     14e:	cf 91       	pop	r28
     150:	08 95       	ret

00000152 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     152:	cf 93       	push	r28
     154:	df 93       	push	r29
     156:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     158:	48 81       	ld	r20, Y
     15a:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     15c:	4f 3f       	cpi	r20, 0xFF	; 255
     15e:	2f ef       	ldi	r18, 0xFF	; 255
     160:	52 07       	cpc	r21, r18
     162:	21 f4       	brne	.+8      	; 0x16c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     164:	fc 01       	movw	r30, r24
     166:	a7 81       	ldd	r26, Z+7	; 0x07
     168:	b0 85       	ldd	r27, Z+8	; 0x08
     16a:	0d c0       	rjmp	.+26     	; 0x186 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     16c:	dc 01       	movw	r26, r24
     16e:	13 96       	adiw	r26, 0x03	; 3
     170:	01 c0       	rjmp	.+2      	; 0x174 <vListInsert+0x22>
     172:	df 01       	movw	r26, r30
     174:	12 96       	adiw	r26, 0x02	; 2
     176:	ed 91       	ld	r30, X+
     178:	fc 91       	ld	r31, X
     17a:	13 97       	sbiw	r26, 0x03	; 3
     17c:	20 81       	ld	r18, Z
     17e:	31 81       	ldd	r19, Z+1	; 0x01
     180:	42 17       	cp	r20, r18
     182:	53 07       	cpc	r21, r19
     184:	b0 f7       	brcc	.-20     	; 0x172 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     186:	12 96       	adiw	r26, 0x02	; 2
     188:	ed 91       	ld	r30, X+
     18a:	fc 91       	ld	r31, X
     18c:	13 97       	sbiw	r26, 0x03	; 3
     18e:	fb 83       	std	Y+3, r31	; 0x03
     190:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     192:	d5 83       	std	Z+5, r29	; 0x05
     194:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     196:	bd 83       	std	Y+5, r27	; 0x05
     198:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     19a:	13 96       	adiw	r26, 0x03	; 3
     19c:	dc 93       	st	X, r29
     19e:	ce 93       	st	-X, r28
     1a0:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     1a2:	99 87       	std	Y+9, r25	; 0x09
     1a4:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     1a6:	fc 01       	movw	r30, r24
     1a8:	20 81       	ld	r18, Z
     1aa:	2f 5f       	subi	r18, 0xFF	; 255
     1ac:	20 83       	st	Z, r18
}
     1ae:	df 91       	pop	r29
     1b0:	cf 91       	pop	r28
     1b2:	08 95       	ret

000001b4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     1b4:	cf 93       	push	r28
     1b6:	df 93       	push	r29
     1b8:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     1ba:	a0 85       	ldd	r26, Z+8	; 0x08
     1bc:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     1be:	c2 81       	ldd	r28, Z+2	; 0x02
     1c0:	d3 81       	ldd	r29, Z+3	; 0x03
     1c2:	84 81       	ldd	r24, Z+4	; 0x04
     1c4:	95 81       	ldd	r25, Z+5	; 0x05
     1c6:	9d 83       	std	Y+5, r25	; 0x05
     1c8:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     1ca:	c4 81       	ldd	r28, Z+4	; 0x04
     1cc:	d5 81       	ldd	r29, Z+5	; 0x05
     1ce:	82 81       	ldd	r24, Z+2	; 0x02
     1d0:	93 81       	ldd	r25, Z+3	; 0x03
     1d2:	9b 83       	std	Y+3, r25	; 0x03
     1d4:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     1d6:	11 96       	adiw	r26, 0x01	; 1
     1d8:	8d 91       	ld	r24, X+
     1da:	9c 91       	ld	r25, X
     1dc:	12 97       	sbiw	r26, 0x02	; 2
     1de:	e8 17       	cp	r30, r24
     1e0:	f9 07       	cpc	r31, r25
     1e2:	31 f4       	brne	.+12     	; 0x1f0 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     1e4:	84 81       	ldd	r24, Z+4	; 0x04
     1e6:	95 81       	ldd	r25, Z+5	; 0x05
     1e8:	12 96       	adiw	r26, 0x02	; 2
     1ea:	9c 93       	st	X, r25
     1ec:	8e 93       	st	-X, r24
     1ee:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     1f0:	11 86       	std	Z+9, r1	; 0x09
     1f2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     1f4:	8c 91       	ld	r24, X
     1f6:	81 50       	subi	r24, 0x01	; 1
     1f8:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     1fa:	df 91       	pop	r29
     1fc:	cf 91       	pop	r28
     1fe:	08 95       	ret

00000200 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     200:	1b bc       	out	0x2b, r1	; 43
     202:	89 ef       	ldi	r24, 0xF9	; 249
     204:	8a bd       	out	0x2a, r24	; 42
     206:	8b e0       	ldi	r24, 0x0B	; 11
     208:	8e bd       	out	0x2e, r24	; 46
     20a:	89 b7       	in	r24, 0x39	; 57
     20c:	80 61       	ori	r24, 0x10	; 16
     20e:	89 bf       	out	0x39, r24	; 57
     210:	08 95       	ret

00000212 <pxPortInitialiseStack>:
     212:	31 e1       	ldi	r19, 0x11	; 17
     214:	fc 01       	movw	r30, r24
     216:	30 83       	st	Z, r19
     218:	31 97       	sbiw	r30, 0x01	; 1
     21a:	22 e2       	ldi	r18, 0x22	; 34
     21c:	20 83       	st	Z, r18
     21e:	31 97       	sbiw	r30, 0x01	; 1
     220:	a3 e3       	ldi	r26, 0x33	; 51
     222:	a0 83       	st	Z, r26
     224:	31 97       	sbiw	r30, 0x01	; 1
     226:	60 83       	st	Z, r22
     228:	31 97       	sbiw	r30, 0x01	; 1
     22a:	70 83       	st	Z, r23
     22c:	31 97       	sbiw	r30, 0x01	; 1
     22e:	10 82       	st	Z, r1
     230:	31 97       	sbiw	r30, 0x01	; 1
     232:	60 e8       	ldi	r22, 0x80	; 128
     234:	60 83       	st	Z, r22
     236:	31 97       	sbiw	r30, 0x01	; 1
     238:	10 82       	st	Z, r1
     23a:	31 97       	sbiw	r30, 0x01	; 1
     23c:	62 e0       	ldi	r22, 0x02	; 2
     23e:	60 83       	st	Z, r22
     240:	31 97       	sbiw	r30, 0x01	; 1
     242:	63 e0       	ldi	r22, 0x03	; 3
     244:	60 83       	st	Z, r22
     246:	31 97       	sbiw	r30, 0x01	; 1
     248:	64 e0       	ldi	r22, 0x04	; 4
     24a:	60 83       	st	Z, r22
     24c:	31 97       	sbiw	r30, 0x01	; 1
     24e:	65 e0       	ldi	r22, 0x05	; 5
     250:	60 83       	st	Z, r22
     252:	31 97       	sbiw	r30, 0x01	; 1
     254:	66 e0       	ldi	r22, 0x06	; 6
     256:	60 83       	st	Z, r22
     258:	31 97       	sbiw	r30, 0x01	; 1
     25a:	67 e0       	ldi	r22, 0x07	; 7
     25c:	60 83       	st	Z, r22
     25e:	31 97       	sbiw	r30, 0x01	; 1
     260:	68 e0       	ldi	r22, 0x08	; 8
     262:	60 83       	st	Z, r22
     264:	31 97       	sbiw	r30, 0x01	; 1
     266:	69 e0       	ldi	r22, 0x09	; 9
     268:	60 83       	st	Z, r22
     26a:	31 97       	sbiw	r30, 0x01	; 1
     26c:	60 e1       	ldi	r22, 0x10	; 16
     26e:	60 83       	st	Z, r22
     270:	31 97       	sbiw	r30, 0x01	; 1
     272:	30 83       	st	Z, r19
     274:	31 97       	sbiw	r30, 0x01	; 1
     276:	32 e1       	ldi	r19, 0x12	; 18
     278:	30 83       	st	Z, r19
     27a:	31 97       	sbiw	r30, 0x01	; 1
     27c:	33 e1       	ldi	r19, 0x13	; 19
     27e:	30 83       	st	Z, r19
     280:	31 97       	sbiw	r30, 0x01	; 1
     282:	34 e1       	ldi	r19, 0x14	; 20
     284:	30 83       	st	Z, r19
     286:	31 97       	sbiw	r30, 0x01	; 1
     288:	35 e1       	ldi	r19, 0x15	; 21
     28a:	30 83       	st	Z, r19
     28c:	31 97       	sbiw	r30, 0x01	; 1
     28e:	36 e1       	ldi	r19, 0x16	; 22
     290:	30 83       	st	Z, r19
     292:	31 97       	sbiw	r30, 0x01	; 1
     294:	37 e1       	ldi	r19, 0x17	; 23
     296:	30 83       	st	Z, r19
     298:	31 97       	sbiw	r30, 0x01	; 1
     29a:	38 e1       	ldi	r19, 0x18	; 24
     29c:	30 83       	st	Z, r19
     29e:	31 97       	sbiw	r30, 0x01	; 1
     2a0:	39 e1       	ldi	r19, 0x19	; 25
     2a2:	30 83       	st	Z, r19
     2a4:	31 97       	sbiw	r30, 0x01	; 1
     2a6:	30 e2       	ldi	r19, 0x20	; 32
     2a8:	30 83       	st	Z, r19
     2aa:	31 97       	sbiw	r30, 0x01	; 1
     2ac:	31 e2       	ldi	r19, 0x21	; 33
     2ae:	30 83       	st	Z, r19
     2b0:	31 97       	sbiw	r30, 0x01	; 1
     2b2:	20 83       	st	Z, r18
     2b4:	31 97       	sbiw	r30, 0x01	; 1
     2b6:	23 e2       	ldi	r18, 0x23	; 35
     2b8:	20 83       	st	Z, r18
     2ba:	31 97       	sbiw	r30, 0x01	; 1
     2bc:	40 83       	st	Z, r20
     2be:	31 97       	sbiw	r30, 0x01	; 1
     2c0:	50 83       	st	Z, r21
     2c2:	31 97       	sbiw	r30, 0x01	; 1
     2c4:	26 e2       	ldi	r18, 0x26	; 38
     2c6:	20 83       	st	Z, r18
     2c8:	31 97       	sbiw	r30, 0x01	; 1
     2ca:	27 e2       	ldi	r18, 0x27	; 39
     2cc:	20 83       	st	Z, r18
     2ce:	31 97       	sbiw	r30, 0x01	; 1
     2d0:	28 e2       	ldi	r18, 0x28	; 40
     2d2:	20 83       	st	Z, r18
     2d4:	31 97       	sbiw	r30, 0x01	; 1
     2d6:	29 e2       	ldi	r18, 0x29	; 41
     2d8:	20 83       	st	Z, r18
     2da:	31 97       	sbiw	r30, 0x01	; 1
     2dc:	20 e3       	ldi	r18, 0x30	; 48
     2de:	20 83       	st	Z, r18
     2e0:	31 97       	sbiw	r30, 0x01	; 1
     2e2:	21 e3       	ldi	r18, 0x31	; 49
     2e4:	20 83       	st	Z, r18
     2e6:	86 97       	sbiw	r24, 0x26	; 38
     2e8:	08 95       	ret

000002ea <xPortStartScheduler>:
     2ea:	0e 94 00 01 	call	0x200	; 0x200 <prvSetupTimerInterrupt>
     2ee:	a0 91 49 07 	lds	r26, 0x0749	; 0x800749 <pxCurrentTCB>
     2f2:	b0 91 4a 07 	lds	r27, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     2f6:	cd 91       	ld	r28, X+
     2f8:	cd bf       	out	0x3d, r28	; 61
     2fa:	dd 91       	ld	r29, X+
     2fc:	de bf       	out	0x3e, r29	; 62
     2fe:	ff 91       	pop	r31
     300:	ef 91       	pop	r30
     302:	df 91       	pop	r29
     304:	cf 91       	pop	r28
     306:	bf 91       	pop	r27
     308:	af 91       	pop	r26
     30a:	9f 91       	pop	r25
     30c:	8f 91       	pop	r24
     30e:	7f 91       	pop	r23
     310:	6f 91       	pop	r22
     312:	5f 91       	pop	r21
     314:	4f 91       	pop	r20
     316:	3f 91       	pop	r19
     318:	2f 91       	pop	r18
     31a:	1f 91       	pop	r17
     31c:	0f 91       	pop	r16
     31e:	ff 90       	pop	r15
     320:	ef 90       	pop	r14
     322:	df 90       	pop	r13
     324:	cf 90       	pop	r12
     326:	bf 90       	pop	r11
     328:	af 90       	pop	r10
     32a:	9f 90       	pop	r9
     32c:	8f 90       	pop	r8
     32e:	7f 90       	pop	r7
     330:	6f 90       	pop	r6
     332:	5f 90       	pop	r5
     334:	4f 90       	pop	r4
     336:	3f 90       	pop	r3
     338:	2f 90       	pop	r2
     33a:	1f 90       	pop	r1
     33c:	0f 90       	pop	r0
     33e:	0f be       	out	0x3f, r0	; 63
     340:	0f 90       	pop	r0
     342:	08 95       	ret
     344:	81 e0       	ldi	r24, 0x01	; 1
     346:	08 95       	ret

00000348 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     348:	0f 92       	push	r0
     34a:	0f b6       	in	r0, 0x3f	; 63
     34c:	f8 94       	cli
     34e:	0f 92       	push	r0
     350:	1f 92       	push	r1
     352:	11 24       	eor	r1, r1
     354:	2f 92       	push	r2
     356:	3f 92       	push	r3
     358:	4f 92       	push	r4
     35a:	5f 92       	push	r5
     35c:	6f 92       	push	r6
     35e:	7f 92       	push	r7
     360:	8f 92       	push	r8
     362:	9f 92       	push	r9
     364:	af 92       	push	r10
     366:	bf 92       	push	r11
     368:	cf 92       	push	r12
     36a:	df 92       	push	r13
     36c:	ef 92       	push	r14
     36e:	ff 92       	push	r15
     370:	0f 93       	push	r16
     372:	1f 93       	push	r17
     374:	2f 93       	push	r18
     376:	3f 93       	push	r19
     378:	4f 93       	push	r20
     37a:	5f 93       	push	r21
     37c:	6f 93       	push	r22
     37e:	7f 93       	push	r23
     380:	8f 93       	push	r24
     382:	9f 93       	push	r25
     384:	af 93       	push	r26
     386:	bf 93       	push	r27
     388:	cf 93       	push	r28
     38a:	df 93       	push	r29
     38c:	ef 93       	push	r30
     38e:	ff 93       	push	r31
     390:	a0 91 49 07 	lds	r26, 0x0749	; 0x800749 <pxCurrentTCB>
     394:	b0 91 4a 07 	lds	r27, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     398:	0d b6       	in	r0, 0x3d	; 61
     39a:	0d 92       	st	X+, r0
     39c:	0e b6       	in	r0, 0x3e	; 62
     39e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     3a0:	0e 94 f4 06 	call	0xde8	; 0xde8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     3a4:	a0 91 49 07 	lds	r26, 0x0749	; 0x800749 <pxCurrentTCB>
     3a8:	b0 91 4a 07 	lds	r27, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     3ac:	cd 91       	ld	r28, X+
     3ae:	cd bf       	out	0x3d, r28	; 61
     3b0:	dd 91       	ld	r29, X+
     3b2:	de bf       	out	0x3e, r29	; 62
     3b4:	ff 91       	pop	r31
     3b6:	ef 91       	pop	r30
     3b8:	df 91       	pop	r29
     3ba:	cf 91       	pop	r28
     3bc:	bf 91       	pop	r27
     3be:	af 91       	pop	r26
     3c0:	9f 91       	pop	r25
     3c2:	8f 91       	pop	r24
     3c4:	7f 91       	pop	r23
     3c6:	6f 91       	pop	r22
     3c8:	5f 91       	pop	r21
     3ca:	4f 91       	pop	r20
     3cc:	3f 91       	pop	r19
     3ce:	2f 91       	pop	r18
     3d0:	1f 91       	pop	r17
     3d2:	0f 91       	pop	r16
     3d4:	ff 90       	pop	r15
     3d6:	ef 90       	pop	r14
     3d8:	df 90       	pop	r13
     3da:	cf 90       	pop	r12
     3dc:	bf 90       	pop	r11
     3de:	af 90       	pop	r10
     3e0:	9f 90       	pop	r9
     3e2:	8f 90       	pop	r8
     3e4:	7f 90       	pop	r7
     3e6:	6f 90       	pop	r6
     3e8:	5f 90       	pop	r5
     3ea:	4f 90       	pop	r4
     3ec:	3f 90       	pop	r3
     3ee:	2f 90       	pop	r2
     3f0:	1f 90       	pop	r1
     3f2:	0f 90       	pop	r0
     3f4:	0f be       	out	0x3f, r0	; 63
     3f6:	0f 90       	pop	r0

	asm volatile ( "ret" );
     3f8:	08 95       	ret

000003fa <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     3fa:	0f 92       	push	r0
     3fc:	0f b6       	in	r0, 0x3f	; 63
     3fe:	f8 94       	cli
     400:	0f 92       	push	r0
     402:	1f 92       	push	r1
     404:	11 24       	eor	r1, r1
     406:	2f 92       	push	r2
     408:	3f 92       	push	r3
     40a:	4f 92       	push	r4
     40c:	5f 92       	push	r5
     40e:	6f 92       	push	r6
     410:	7f 92       	push	r7
     412:	8f 92       	push	r8
     414:	9f 92       	push	r9
     416:	af 92       	push	r10
     418:	bf 92       	push	r11
     41a:	cf 92       	push	r12
     41c:	df 92       	push	r13
     41e:	ef 92       	push	r14
     420:	ff 92       	push	r15
     422:	0f 93       	push	r16
     424:	1f 93       	push	r17
     426:	2f 93       	push	r18
     428:	3f 93       	push	r19
     42a:	4f 93       	push	r20
     42c:	5f 93       	push	r21
     42e:	6f 93       	push	r22
     430:	7f 93       	push	r23
     432:	8f 93       	push	r24
     434:	9f 93       	push	r25
     436:	af 93       	push	r26
     438:	bf 93       	push	r27
     43a:	cf 93       	push	r28
     43c:	df 93       	push	r29
     43e:	ef 93       	push	r30
     440:	ff 93       	push	r31
     442:	a0 91 49 07 	lds	r26, 0x0749	; 0x800749 <pxCurrentTCB>
     446:	b0 91 4a 07 	lds	r27, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     44a:	0d b6       	in	r0, 0x3d	; 61
     44c:	0d 92       	st	X+, r0
     44e:	0e b6       	in	r0, 0x3e	; 62
     450:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     452:	0e 94 87 05 	call	0xb0e	; 0xb0e <xTaskIncrementTick>
     456:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     458:	0e 94 f4 06 	call	0xde8	; 0xde8 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     45c:	a0 91 49 07 	lds	r26, 0x0749	; 0x800749 <pxCurrentTCB>
     460:	b0 91 4a 07 	lds	r27, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     464:	cd 91       	ld	r28, X+
     466:	cd bf       	out	0x3d, r28	; 61
     468:	dd 91       	ld	r29, X+
     46a:	de bf       	out	0x3e, r29	; 62
     46c:	ff 91       	pop	r31
     46e:	ef 91       	pop	r30
     470:	df 91       	pop	r29
     472:	cf 91       	pop	r28
     474:	bf 91       	pop	r27
     476:	af 91       	pop	r26
     478:	9f 91       	pop	r25
     47a:	8f 91       	pop	r24
     47c:	7f 91       	pop	r23
     47e:	6f 91       	pop	r22
     480:	5f 91       	pop	r21
     482:	4f 91       	pop	r20
     484:	3f 91       	pop	r19
     486:	2f 91       	pop	r18
     488:	1f 91       	pop	r17
     48a:	0f 91       	pop	r16
     48c:	ff 90       	pop	r15
     48e:	ef 90       	pop	r14
     490:	df 90       	pop	r13
     492:	cf 90       	pop	r12
     494:	bf 90       	pop	r11
     496:	af 90       	pop	r10
     498:	9f 90       	pop	r9
     49a:	8f 90       	pop	r8
     49c:	7f 90       	pop	r7
     49e:	6f 90       	pop	r6
     4a0:	5f 90       	pop	r5
     4a2:	4f 90       	pop	r4
     4a4:	3f 90       	pop	r3
     4a6:	2f 90       	pop	r2
     4a8:	1f 90       	pop	r1
     4aa:	0f 90       	pop	r0
     4ac:	0f be       	out	0x3f, r0	; 63
     4ae:	0f 90       	pop	r0

	asm volatile ( "ret" );
     4b0:	08 95       	ret

000004b2 <__vector_7>:
	 * DeeThe: Changed from SIG_OUTPUT_COMPARE1A to TIMER1_COMPA_vect
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     4b2:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vPortYieldFromTick>
		asm volatile ( "reti" );
     4b6:	18 95       	reti

000004b8 <prvHeapInit>:

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     4b8:	e8 e1       	ldi	r30, 0x18	; 24
     4ba:	f1 e0       	ldi	r31, 0x01	; 1
     4bc:	ac e1       	ldi	r26, 0x1C	; 28
     4be:	b1 e0       	ldi	r27, 0x01	; 1
     4c0:	b1 83       	std	Z+1, r27	; 0x01
     4c2:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
     4c4:	13 82       	std	Z+3, r1	; 0x03
     4c6:	12 82       	std	Z+2, r1	; 0x02

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
     4c8:	e4 ef       	ldi	r30, 0xF4	; 244
     4ca:	f6 e0       	ldi	r31, 0x06	; 6
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
     4cc:	f0 93 17 01 	sts	0x0117, r31	; 0x800117 <pxEnd+0x1>
     4d0:	e0 93 16 01 	sts	0x0116, r30	; 0x800116 <pxEnd>
	pxEnd->xBlockSize = 0;
     4d4:	13 82       	std	Z+3, r1	; 0x03
     4d6:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
     4d8:	11 82       	std	Z+1, r1	; 0x01
     4da:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
     4dc:	88 ed       	ldi	r24, 0xD8	; 216
     4de:	95 e0       	ldi	r25, 0x05	; 5
     4e0:	13 96       	adiw	r26, 0x03	; 3
     4e2:	9c 93       	st	X, r25
     4e4:	8e 93       	st	-X, r24
     4e6:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
     4e8:	ed 93       	st	X+, r30
     4ea:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     4ec:	90 93 13 01 	sts	0x0113, r25	; 0x800113 <xMinimumEverFreeBytesRemaining+0x1>
     4f0:	80 93 12 01 	sts	0x0112, r24	; 0x800112 <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     4f4:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <xFreeBytesRemaining+0x1>
     4f8:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
     4fc:	80 e0       	ldi	r24, 0x00	; 0
     4fe:	90 e8       	ldi	r25, 0x80	; 128
     500:	90 93 11 01 	sts	0x0111, r25	; 0x800111 <__data_end+0x1>
     504:	80 93 10 01 	sts	0x0110, r24	; 0x800110 <__data_end>
     508:	08 95       	ret

0000050a <prvInsertBlockIntoFreeList>:
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
     50a:	cf 93       	push	r28
     50c:	df 93       	push	r29
     50e:	ec 01       	movw	r28, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     510:	a8 e1       	ldi	r26, 0x18	; 24
     512:	b1 e0       	ldi	r27, 0x01	; 1
     514:	01 c0       	rjmp	.+2      	; 0x518 <prvInsertBlockIntoFreeList+0xe>
     516:	df 01       	movw	r26, r30
     518:	ed 91       	ld	r30, X+
     51a:	fc 91       	ld	r31, X
     51c:	11 97       	sbiw	r26, 0x01	; 1
     51e:	ec 17       	cp	r30, r28
     520:	fd 07       	cpc	r31, r29
     522:	c8 f3       	brcs	.-14     	; 0x516 <prvInsertBlockIntoFreeList+0xc>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
     524:	12 96       	adiw	r26, 0x02	; 2
     526:	8d 91       	ld	r24, X+
     528:	9c 91       	ld	r25, X
     52a:	13 97       	sbiw	r26, 0x03	; 3
     52c:	9d 01       	movw	r18, r26
     52e:	28 0f       	add	r18, r24
     530:	39 1f       	adc	r19, r25
     532:	c2 17       	cp	r28, r18
     534:	d3 07       	cpc	r29, r19
     536:	49 f4       	brne	.+18     	; 0x54a <prvInsertBlockIntoFreeList+0x40>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
     538:	2a 81       	ldd	r18, Y+2	; 0x02
     53a:	3b 81       	ldd	r19, Y+3	; 0x03
     53c:	82 0f       	add	r24, r18
     53e:	93 1f       	adc	r25, r19
     540:	13 96       	adiw	r26, 0x03	; 3
     542:	9c 93       	st	X, r25
     544:	8e 93       	st	-X, r24
     546:	12 97       	sbiw	r26, 0x02	; 2
		pxBlockToInsert = pxIterator;
     548:	ed 01       	movw	r28, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     54a:	8a 81       	ldd	r24, Y+2	; 0x02
     54c:	9b 81       	ldd	r25, Y+3	; 0x03
     54e:	9e 01       	movw	r18, r28
     550:	28 0f       	add	r18, r24
     552:	39 1f       	adc	r19, r25
     554:	e2 17       	cp	r30, r18
     556:	f3 07       	cpc	r31, r19
     558:	c1 f4       	brne	.+48     	; 0x58a <prvInsertBlockIntoFreeList+0x80>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
     55a:	20 91 16 01 	lds	r18, 0x0116	; 0x800116 <pxEnd>
     55e:	30 91 17 01 	lds	r19, 0x0117	; 0x800117 <pxEnd+0x1>
     562:	e2 17       	cp	r30, r18
     564:	f3 07       	cpc	r31, r19
     566:	71 f0       	breq	.+28     	; 0x584 <prvInsertBlockIntoFreeList+0x7a>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
     568:	22 81       	ldd	r18, Z+2	; 0x02
     56a:	33 81       	ldd	r19, Z+3	; 0x03
     56c:	82 0f       	add	r24, r18
     56e:	93 1f       	adc	r25, r19
     570:	9b 83       	std	Y+3, r25	; 0x03
     572:	8a 83       	std	Y+2, r24	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
     574:	ed 91       	ld	r30, X+
     576:	fc 91       	ld	r31, X
     578:	11 97       	sbiw	r26, 0x01	; 1
     57a:	80 81       	ld	r24, Z
     57c:	91 81       	ldd	r25, Z+1	; 0x01
     57e:	99 83       	std	Y+1, r25	; 0x01
     580:	88 83       	st	Y, r24
     582:	05 c0       	rjmp	.+10     	; 0x58e <prvInsertBlockIntoFreeList+0x84>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
     584:	39 83       	std	Y+1, r19	; 0x01
     586:	28 83       	st	Y, r18
     588:	02 c0       	rjmp	.+4      	; 0x58e <prvInsertBlockIntoFreeList+0x84>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
     58a:	f9 83       	std	Y+1, r31	; 0x01
     58c:	e8 83       	st	Y, r30

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
     58e:	ca 17       	cp	r28, r26
     590:	db 07       	cpc	r29, r27
     592:	11 f0       	breq	.+4      	; 0x598 <prvInsertBlockIntoFreeList+0x8e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
     594:	cd 93       	st	X+, r28
     596:	dc 93       	st	X, r29
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
     598:	df 91       	pop	r29
     59a:	cf 91       	pop	r28
     59c:	08 95       	ret

0000059e <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     59e:	ef 92       	push	r14
     5a0:	ff 92       	push	r15
     5a2:	0f 93       	push	r16
     5a4:	1f 93       	push	r17
     5a6:	cf 93       	push	r28
     5a8:	df 93       	push	r29
     5aa:	8c 01       	movw	r16, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
     5ac:	0e 94 77 05 	call	0xaee	; 0xaee <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
     5b0:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <pxEnd>
     5b4:	90 91 17 01 	lds	r25, 0x0117	; 0x800117 <pxEnd+0x1>
     5b8:	89 2b       	or	r24, r25
     5ba:	11 f4       	brne	.+4      	; 0x5c0 <pvPortMalloc+0x22>
		{
			prvHeapInit();
     5bc:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
     5c0:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <__data_end>
     5c4:	90 91 11 01 	lds	r25, 0x0111	; 0x800111 <__data_end+0x1>
     5c8:	80 23       	and	r24, r16
     5ca:	91 23       	and	r25, r17
     5cc:	89 2b       	or	r24, r25
     5ce:	09 f0       	breq	.+2      	; 0x5d2 <pvPortMalloc+0x34>
     5d0:	67 c0       	rjmp	.+206    	; 0x6a0 <pvPortMalloc+0x102>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
     5d2:	01 15       	cp	r16, r1
     5d4:	11 05       	cpc	r17, r1
     5d6:	11 f0       	breq	.+4      	; 0x5dc <pvPortMalloc+0x3e>
			{
				xWantedSize += xHeapStructSize;
     5d8:	0c 5f       	subi	r16, 0xFC	; 252
     5da:	1f 4f       	sbci	r17, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
     5dc:	01 15       	cp	r16, r1
     5de:	11 05       	cpc	r17, r1
     5e0:	09 f4       	brne	.+2      	; 0x5e4 <pvPortMalloc+0x46>
     5e2:	61 c0       	rjmp	.+194    	; 0x6a6 <pvPortMalloc+0x108>
     5e4:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <xFreeBytesRemaining>
     5e8:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <xFreeBytesRemaining+0x1>
     5ec:	80 17       	cp	r24, r16
     5ee:	91 07       	cpc	r25, r17
     5f0:	08 f4       	brcc	.+2      	; 0x5f4 <pvPortMalloc+0x56>
     5f2:	5c c0       	rjmp	.+184    	; 0x6ac <pvPortMalloc+0x10e>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
     5f4:	c0 91 18 01 	lds	r28, 0x0118	; 0x800118 <xStart>
     5f8:	d0 91 19 01 	lds	r29, 0x0119	; 0x800119 <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
     5fc:	e8 e1       	ldi	r30, 0x18	; 24
     5fe:	f1 e0       	ldi	r31, 0x01	; 1
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     600:	02 c0       	rjmp	.+4      	; 0x606 <pvPortMalloc+0x68>
				{
					pxPreviousBlock = pxBlock;
     602:	fe 01       	movw	r30, r28
					pxBlock = pxBlock->pxNextFreeBlock;
     604:	ec 01       	movw	r28, r24
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     606:	8a 81       	ldd	r24, Y+2	; 0x02
     608:	9b 81       	ldd	r25, Y+3	; 0x03
     60a:	80 17       	cp	r24, r16
     60c:	91 07       	cpc	r25, r17
     60e:	20 f4       	brcc	.+8      	; 0x618 <pvPortMalloc+0x7a>
     610:	88 81       	ld	r24, Y
     612:	99 81       	ldd	r25, Y+1	; 0x01
     614:	00 97       	sbiw	r24, 0x00	; 0
     616:	a9 f7       	brne	.-22     	; 0x602 <pvPortMalloc+0x64>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
     618:	80 91 16 01 	lds	r24, 0x0116	; 0x800116 <pxEnd>
     61c:	90 91 17 01 	lds	r25, 0x0117	; 0x800117 <pxEnd+0x1>
     620:	c8 17       	cp	r28, r24
     622:	d9 07       	cpc	r29, r25
     624:	09 f4       	brne	.+2      	; 0x628 <pvPortMalloc+0x8a>
     626:	45 c0       	rjmp	.+138    	; 0x6b2 <pvPortMalloc+0x114>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     628:	e0 80       	ld	r14, Z
     62a:	f1 80       	ldd	r15, Z+1	; 0x01
     62c:	84 e0       	ldi	r24, 0x04	; 4
     62e:	e8 0e       	add	r14, r24
     630:	f1 1c       	adc	r15, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     632:	88 81       	ld	r24, Y
     634:	99 81       	ldd	r25, Y+1	; 0x01
     636:	91 83       	std	Z+1, r25	; 0x01
     638:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     63a:	2a 81       	ldd	r18, Y+2	; 0x02
     63c:	3b 81       	ldd	r19, Y+3	; 0x03
     63e:	20 1b       	sub	r18, r16
     640:	31 0b       	sbc	r19, r17
     642:	29 30       	cpi	r18, 0x09	; 9
     644:	31 05       	cpc	r19, r1
     646:	50 f0       	brcs	.+20     	; 0x65c <pvPortMalloc+0xbe>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     648:	ce 01       	movw	r24, r28
     64a:	80 0f       	add	r24, r16
     64c:	91 1f       	adc	r25, r17
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     64e:	fc 01       	movw	r30, r24
     650:	33 83       	std	Z+3, r19	; 0x03
     652:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
     654:	1b 83       	std	Y+3, r17	; 0x03
     656:	0a 83       	std	Y+2, r16	; 0x02

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
     658:	0e 94 85 02 	call	0x50a	; 0x50a <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
     65c:	2a 81       	ldd	r18, Y+2	; 0x02
     65e:	3b 81       	ldd	r19, Y+3	; 0x03
     660:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <xFreeBytesRemaining>
     664:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <xFreeBytesRemaining+0x1>
     668:	82 1b       	sub	r24, r18
     66a:	93 0b       	sbc	r25, r19
     66c:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <xFreeBytesRemaining+0x1>
     670:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
     674:	40 91 12 01 	lds	r20, 0x0112	; 0x800112 <xMinimumEverFreeBytesRemaining>
     678:	50 91 13 01 	lds	r21, 0x0113	; 0x800113 <xMinimumEverFreeBytesRemaining+0x1>
     67c:	84 17       	cp	r24, r20
     67e:	95 07       	cpc	r25, r21
     680:	20 f4       	brcc	.+8      	; 0x68a <pvPortMalloc+0xec>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
     682:	90 93 13 01 	sts	0x0113, r25	; 0x800113 <xMinimumEverFreeBytesRemaining+0x1>
     686:	80 93 12 01 	sts	0x0112, r24	; 0x800112 <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
     68a:	80 91 10 01 	lds	r24, 0x0110	; 0x800110 <__data_end>
     68e:	90 91 11 01 	lds	r25, 0x0111	; 0x800111 <__data_end+0x1>
     692:	28 2b       	or	r18, r24
     694:	39 2b       	or	r19, r25
     696:	3b 83       	std	Y+3, r19	; 0x03
     698:	2a 83       	std	Y+2, r18	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
     69a:	19 82       	std	Y+1, r1	; 0x01
     69c:	18 82       	st	Y, r1
     69e:	0b c0       	rjmp	.+22     	; 0x6b6 <pvPortMalloc+0x118>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
     6a0:	e1 2c       	mov	r14, r1
     6a2:	f1 2c       	mov	r15, r1
     6a4:	08 c0       	rjmp	.+16     	; 0x6b6 <pvPortMalloc+0x118>
     6a6:	e1 2c       	mov	r14, r1
     6a8:	f1 2c       	mov	r15, r1
     6aa:	05 c0       	rjmp	.+10     	; 0x6b6 <pvPortMalloc+0x118>
     6ac:	e1 2c       	mov	r14, r1
     6ae:	f1 2c       	mov	r15, r1
     6b0:	02 c0       	rjmp	.+4      	; 0x6b6 <pvPortMalloc+0x118>
     6b2:	e1 2c       	mov	r14, r1
     6b4:	f1 2c       	mov	r15, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     6b6:	0e 94 41 06 	call	0xc82	; 0xc82 <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
     6ba:	c7 01       	movw	r24, r14
     6bc:	df 91       	pop	r29
     6be:	cf 91       	pop	r28
     6c0:	1f 91       	pop	r17
     6c2:	0f 91       	pop	r16
     6c4:	ff 90       	pop	r15
     6c6:	ef 90       	pop	r14
     6c8:	08 95       	ret

000006ca <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     6ca:	0f 93       	push	r16
     6cc:	1f 93       	push	r17
     6ce:	cf 93       	push	r28
     6d0:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     6d2:	00 97       	sbiw	r24, 0x00	; 0
     6d4:	51 f1       	breq	.+84     	; 0x72a <vPortFree+0x60>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
     6d6:	ec 01       	movw	r28, r24
     6d8:	24 97       	sbiw	r28, 0x04	; 4

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
     6da:	4a 81       	ldd	r20, Y+2	; 0x02
     6dc:	5b 81       	ldd	r21, Y+3	; 0x03
     6de:	20 91 10 01 	lds	r18, 0x0110	; 0x800110 <__data_end>
     6e2:	30 91 11 01 	lds	r19, 0x0111	; 0x800111 <__data_end+0x1>
     6e6:	ba 01       	movw	r22, r20
     6e8:	62 23       	and	r22, r18
     6ea:	73 23       	and	r23, r19
     6ec:	67 2b       	or	r22, r23
     6ee:	e9 f0       	breq	.+58     	; 0x72a <vPortFree+0x60>
		{
			if( pxLink->pxNextFreeBlock == NULL )
     6f0:	68 81       	ld	r22, Y
     6f2:	79 81       	ldd	r23, Y+1	; 0x01
     6f4:	67 2b       	or	r22, r23
     6f6:	c9 f4       	brne	.+50     	; 0x72a <vPortFree+0x60>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
     6f8:	20 95       	com	r18
     6fa:	30 95       	com	r19
     6fc:	24 23       	and	r18, r20
     6fe:	35 23       	and	r19, r21
     700:	3b 83       	std	Y+3, r19	; 0x03
     702:	2a 83       	std	Y+2, r18	; 0x02

				vTaskSuspendAll();
     704:	0e 94 77 05 	call	0xaee	; 0xaee <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
     708:	8a 81       	ldd	r24, Y+2	; 0x02
     70a:	9b 81       	ldd	r25, Y+3	; 0x03
     70c:	20 91 14 01 	lds	r18, 0x0114	; 0x800114 <xFreeBytesRemaining>
     710:	30 91 15 01 	lds	r19, 0x0115	; 0x800115 <xFreeBytesRemaining+0x1>
     714:	82 0f       	add	r24, r18
     716:	93 1f       	adc	r25, r19
     718:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <xFreeBytesRemaining+0x1>
     71c:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <xFreeBytesRemaining>
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     720:	ce 01       	movw	r24, r28
     722:	0e 94 85 02 	call	0x50a	; 0x50a <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
     726:	0e 94 41 06 	call	0xc82	; 0xc82 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     72a:	df 91       	pop	r29
     72c:	cf 91       	pop	r28
     72e:	1f 91       	pop	r17
     730:	0f 91       	pop	r16
     732:	08 95       	ret

00000734 <prvResetNextTaskUnblockTime>:
	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     734:	e0 91 11 07 	lds	r30, 0x0711	; 0x800711 <pxDelayedTaskList>
     738:	f0 91 12 07 	lds	r31, 0x0712	; 0x800712 <pxDelayedTaskList+0x1>
     73c:	80 81       	ld	r24, Z
     73e:	81 11       	cpse	r24, r1
     740:	07 c0       	rjmp	.+14     	; 0x750 <prvResetNextTaskUnblockTime+0x1c>
     742:	8f ef       	ldi	r24, 0xFF	; 255
     744:	9f ef       	ldi	r25, 0xFF	; 255
     746:	90 93 fc 06 	sts	0x06FC, r25	; 0x8006fc <xNextTaskUnblockTime+0x1>
     74a:	80 93 fb 06 	sts	0x06FB, r24	; 0x8006fb <xNextTaskUnblockTime>
     74e:	08 95       	ret
     750:	e0 91 11 07 	lds	r30, 0x0711	; 0x800711 <pxDelayedTaskList>
     754:	f0 91 12 07 	lds	r31, 0x0712	; 0x800712 <pxDelayedTaskList+0x1>
     758:	05 80       	ldd	r0, Z+5	; 0x05
     75a:	f6 81       	ldd	r31, Z+6	; 0x06
     75c:	e0 2d       	mov	r30, r0
     75e:	06 80       	ldd	r0, Z+6	; 0x06
     760:	f7 81       	ldd	r31, Z+7	; 0x07
     762:	e0 2d       	mov	r30, r0
     764:	82 81       	ldd	r24, Z+2	; 0x02
     766:	93 81       	ldd	r25, Z+3	; 0x03
     768:	90 93 fc 06 	sts	0x06FC, r25	; 0x8006fc <xNextTaskUnblockTime+0x1>
     76c:	80 93 fb 06 	sts	0x06FB, r24	; 0x8006fb <xNextTaskUnblockTime>
     770:	08 95       	ret

00000772 <prvInitialiseNewTask>:
     772:	6f 92       	push	r6
     774:	7f 92       	push	r7
     776:	8f 92       	push	r8
     778:	9f 92       	push	r9
     77a:	af 92       	push	r10
     77c:	bf 92       	push	r11
     77e:	cf 92       	push	r12
     780:	df 92       	push	r13
     782:	ef 92       	push	r14
     784:	0f 93       	push	r16
     786:	1f 93       	push	r17
     788:	cf 93       	push	r28
     78a:	df 93       	push	r29
     78c:	cd b7       	in	r28, 0x3d	; 61
     78e:	de b7       	in	r29, 0x3e	; 62
     790:	4c 01       	movw	r8, r24
     792:	f5 01       	movw	r30, r10
     794:	87 89       	ldd	r24, Z+23	; 0x17
     796:	90 8d       	ldd	r25, Z+24	; 0x18
     798:	21 50       	subi	r18, 0x01	; 1
     79a:	31 09       	sbc	r19, r1
     79c:	3c 01       	movw	r6, r24
     79e:	62 0e       	add	r6, r18
     7a0:	73 1e       	adc	r7, r19
     7a2:	20 e0       	ldi	r18, 0x00	; 0
     7a4:	0f c0       	rjmp	.+30     	; 0x7c4 <prvInitialiseNewTask+0x52>
     7a6:	82 2f       	mov	r24, r18
     7a8:	90 e0       	ldi	r25, 0x00	; 0
     7aa:	fb 01       	movw	r30, r22
     7ac:	e8 0f       	add	r30, r24
     7ae:	f9 1f       	adc	r31, r25
     7b0:	30 81       	ld	r19, Z
     7b2:	d5 01       	movw	r26, r10
     7b4:	a8 0f       	add	r26, r24
     7b6:	b9 1f       	adc	r27, r25
     7b8:	59 96       	adiw	r26, 0x19	; 25
     7ba:	3c 93       	st	X, r19
     7bc:	80 81       	ld	r24, Z
     7be:	88 23       	and	r24, r24
     7c0:	19 f0       	breq	.+6      	; 0x7c8 <prvInitialiseNewTask+0x56>
     7c2:	2f 5f       	subi	r18, 0xFF	; 255
     7c4:	28 30       	cpi	r18, 0x08	; 8
     7c6:	78 f3       	brcs	.-34     	; 0x7a6 <prvInitialiseNewTask+0x34>
     7c8:	f5 01       	movw	r30, r10
     7ca:	10 a2       	std	Z+32, r1	; 0x20
     7cc:	f3 e0       	ldi	r31, 0x03	; 3
     7ce:	fe 15       	cp	r31, r14
     7d0:	20 f4       	brcc	.+8      	; 0x7da <prvInitialiseNewTask+0x68>
     7d2:	0f 2e       	mov	r0, r31
     7d4:	f3 e0       	ldi	r31, 0x03	; 3
     7d6:	ef 2e       	mov	r14, r31
     7d8:	f0 2d       	mov	r31, r0
     7da:	f5 01       	movw	r30, r10
     7dc:	e6 8a       	std	Z+22, r14	; 0x16
     7de:	c5 01       	movw	r24, r10
     7e0:	02 96       	adiw	r24, 0x02	; 2
     7e2:	0e 94 84 00 	call	0x108	; 0x108 <vListInitialiseItem>
     7e6:	c5 01       	movw	r24, r10
     7e8:	0c 96       	adiw	r24, 0x0c	; 12
     7ea:	0e 94 84 00 	call	0x108	; 0x108 <vListInitialiseItem>
     7ee:	f5 01       	movw	r30, r10
     7f0:	b1 86       	std	Z+9, r11	; 0x09
     7f2:	a0 86       	std	Z+8, r10	; 0x08
     7f4:	84 e0       	ldi	r24, 0x04	; 4
     7f6:	90 e0       	ldi	r25, 0x00	; 0
     7f8:	8e 19       	sub	r24, r14
     7fa:	91 09       	sbc	r25, r1
     7fc:	95 87       	std	Z+13, r25	; 0x0d
     7fe:	84 87       	std	Z+12, r24	; 0x0c
     800:	b3 8a       	std	Z+19, r11	; 0x13
     802:	a2 8a       	std	Z+18, r10	; 0x12
     804:	11 a2       	std	Z+33, r1	; 0x21
     806:	12 a2       	std	Z+34, r1	; 0x22
     808:	13 a2       	std	Z+35, r1	; 0x23
     80a:	14 a2       	std	Z+36, r1	; 0x24
     80c:	15 a2       	std	Z+37, r1	; 0x25
     80e:	a8 01       	movw	r20, r16
     810:	b4 01       	movw	r22, r8
     812:	c3 01       	movw	r24, r6
     814:	0e 94 09 01 	call	0x212	; 0x212 <pxPortInitialiseStack>
     818:	f5 01       	movw	r30, r10
     81a:	91 83       	std	Z+1, r25	; 0x01
     81c:	80 83       	st	Z, r24
     81e:	c1 14       	cp	r12, r1
     820:	d1 04       	cpc	r13, r1
     822:	19 f0       	breq	.+6      	; 0x82a <__DATA_REGION_LENGTH__+0x2a>
     824:	f6 01       	movw	r30, r12
     826:	b1 82       	std	Z+1, r11	; 0x01
     828:	a0 82       	st	Z, r10
     82a:	df 91       	pop	r29
     82c:	cf 91       	pop	r28
     82e:	1f 91       	pop	r17
     830:	0f 91       	pop	r16
     832:	ef 90       	pop	r14
     834:	df 90       	pop	r13
     836:	cf 90       	pop	r12
     838:	bf 90       	pop	r11
     83a:	af 90       	pop	r10
     83c:	9f 90       	pop	r9
     83e:	8f 90       	pop	r8
     840:	7f 90       	pop	r7
     842:	6f 90       	pop	r6
     844:	08 95       	ret

00000846 <prvIdleTask>:
     846:	80 91 25 07 	lds	r24, 0x0725	; 0x800725 <pxReadyTasksLists>
     84a:	82 30       	cpi	r24, 0x02	; 2
     84c:	e0 f3       	brcs	.-8      	; 0x846 <prvIdleTask>
     84e:	0e 94 a4 01 	call	0x348	; 0x348 <vPortYield>
     852:	f9 cf       	rjmp	.-14     	; 0x846 <prvIdleTask>

00000854 <prvInitialiseTaskLists>:
     854:	cf 93       	push	r28
     856:	c0 e0       	ldi	r28, 0x00	; 0
     858:	10 c0       	rjmp	.+32     	; 0x87a <__stack+0x1b>
     85a:	8c 2f       	mov	r24, r28
     85c:	90 e0       	ldi	r25, 0x00	; 0
     85e:	9c 01       	movw	r18, r24
     860:	22 0f       	add	r18, r18
     862:	33 1f       	adc	r19, r19
     864:	22 0f       	add	r18, r18
     866:	33 1f       	adc	r19, r19
     868:	22 0f       	add	r18, r18
     86a:	33 1f       	adc	r19, r19
     86c:	82 0f       	add	r24, r18
     86e:	93 1f       	adc	r25, r19
     870:	8b 5d       	subi	r24, 0xDB	; 219
     872:	98 4f       	sbci	r25, 0xF8	; 248
     874:	0e 94 76 00 	call	0xec	; 0xec <vListInitialise>
     878:	cf 5f       	subi	r28, 0xFF	; 255
     87a:	c4 30       	cpi	r28, 0x04	; 4
     87c:	70 f3       	brcs	.-36     	; 0x85a <prvInitialiseTaskLists+0x6>
     87e:	8c e1       	ldi	r24, 0x1C	; 28
     880:	97 e0       	ldi	r25, 0x07	; 7
     882:	0e 94 76 00 	call	0xec	; 0xec <vListInitialise>
     886:	83 e1       	ldi	r24, 0x13	; 19
     888:	97 e0       	ldi	r25, 0x07	; 7
     88a:	0e 94 76 00 	call	0xec	; 0xec <vListInitialise>
     88e:	86 e0       	ldi	r24, 0x06	; 6
     890:	97 e0       	ldi	r25, 0x07	; 7
     892:	0e 94 76 00 	call	0xec	; 0xec <vListInitialise>
     896:	8c e1       	ldi	r24, 0x1C	; 28
     898:	97 e0       	ldi	r25, 0x07	; 7
     89a:	90 93 12 07 	sts	0x0712, r25	; 0x800712 <pxDelayedTaskList+0x1>
     89e:	80 93 11 07 	sts	0x0711, r24	; 0x800711 <pxDelayedTaskList>
     8a2:	83 e1       	ldi	r24, 0x13	; 19
     8a4:	97 e0       	ldi	r25, 0x07	; 7
     8a6:	90 93 10 07 	sts	0x0710, r25	; 0x800710 <pxOverflowDelayedTaskList+0x1>
     8aa:	80 93 0f 07 	sts	0x070F, r24	; 0x80070f <pxOverflowDelayedTaskList>
     8ae:	cf 91       	pop	r28
     8b0:	08 95       	ret

000008b2 <prvAddNewTaskToReadyList>:
     8b2:	cf 93       	push	r28
     8b4:	df 93       	push	r29
     8b6:	ec 01       	movw	r28, r24
     8b8:	0f b6       	in	r0, 0x3f	; 63
     8ba:	f8 94       	cli
     8bc:	0f 92       	push	r0
     8be:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxCurrentNumberOfTasks>
     8c2:	8f 5f       	subi	r24, 0xFF	; 255
     8c4:	80 93 05 07 	sts	0x0705, r24	; 0x800705 <uxCurrentNumberOfTasks>
     8c8:	80 91 49 07 	lds	r24, 0x0749	; 0x800749 <pxCurrentTCB>
     8cc:	90 91 4a 07 	lds	r25, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     8d0:	89 2b       	or	r24, r25
     8d2:	59 f4       	brne	.+22     	; 0x8ea <prvAddNewTaskToReadyList+0x38>
     8d4:	d0 93 4a 07 	sts	0x074A, r29	; 0x80074a <pxCurrentTCB+0x1>
     8d8:	c0 93 49 07 	sts	0x0749, r28	; 0x800749 <pxCurrentTCB>
     8dc:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxCurrentNumberOfTasks>
     8e0:	81 30       	cpi	r24, 0x01	; 1
     8e2:	99 f4       	brne	.+38     	; 0x90a <prvAddNewTaskToReadyList+0x58>
     8e4:	0e 94 2a 04 	call	0x854	; 0x854 <prvInitialiseTaskLists>
     8e8:	10 c0       	rjmp	.+32     	; 0x90a <prvAddNewTaskToReadyList+0x58>
     8ea:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <xSchedulerRunning>
     8ee:	81 11       	cpse	r24, r1
     8f0:	0c c0       	rjmp	.+24     	; 0x90a <prvAddNewTaskToReadyList+0x58>
     8f2:	e0 91 49 07 	lds	r30, 0x0749	; 0x800749 <pxCurrentTCB>
     8f6:	f0 91 4a 07 	lds	r31, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     8fa:	96 89       	ldd	r25, Z+22	; 0x16
     8fc:	8e 89       	ldd	r24, Y+22	; 0x16
     8fe:	89 17       	cp	r24, r25
     900:	20 f0       	brcs	.+8      	; 0x90a <prvAddNewTaskToReadyList+0x58>
     902:	d0 93 4a 07 	sts	0x074A, r29	; 0x80074a <pxCurrentTCB+0x1>
     906:	c0 93 49 07 	sts	0x0749, r28	; 0x800749 <pxCurrentTCB>
     90a:	80 91 fd 06 	lds	r24, 0x06FD	; 0x8006fd <uxTaskNumber>
     90e:	8f 5f       	subi	r24, 0xFF	; 255
     910:	80 93 fd 06 	sts	0x06FD, r24	; 0x8006fd <uxTaskNumber>
     914:	8e 89       	ldd	r24, Y+22	; 0x16
     916:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <uxTopReadyPriority>
     91a:	98 17       	cp	r25, r24
     91c:	10 f4       	brcc	.+4      	; 0x922 <prvAddNewTaskToReadyList+0x70>
     91e:	80 93 02 07 	sts	0x0702, r24	; 0x800702 <uxTopReadyPriority>
     922:	90 e0       	ldi	r25, 0x00	; 0
     924:	9c 01       	movw	r18, r24
     926:	22 0f       	add	r18, r18
     928:	33 1f       	adc	r19, r19
     92a:	22 0f       	add	r18, r18
     92c:	33 1f       	adc	r19, r19
     92e:	22 0f       	add	r18, r18
     930:	33 1f       	adc	r19, r19
     932:	82 0f       	add	r24, r18
     934:	93 1f       	adc	r25, r19
     936:	be 01       	movw	r22, r28
     938:	6e 5f       	subi	r22, 0xFE	; 254
     93a:	7f 4f       	sbci	r23, 0xFF	; 255
     93c:	8b 5d       	subi	r24, 0xDB	; 219
     93e:	98 4f       	sbci	r25, 0xF8	; 248
     940:	0e 94 88 00 	call	0x110	; 0x110 <vListInsertEnd>
     944:	0f 90       	pop	r0
     946:	0f be       	out	0x3f, r0	; 63
     948:	80 91 01 07 	lds	r24, 0x0701	; 0x800701 <xSchedulerRunning>
     94c:	88 23       	and	r24, r24
     94e:	51 f0       	breq	.+20     	; 0x964 <prvAddNewTaskToReadyList+0xb2>
     950:	e0 91 49 07 	lds	r30, 0x0749	; 0x800749 <pxCurrentTCB>
     954:	f0 91 4a 07 	lds	r31, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     958:	96 89       	ldd	r25, Z+22	; 0x16
     95a:	8e 89       	ldd	r24, Y+22	; 0x16
     95c:	98 17       	cp	r25, r24
     95e:	10 f4       	brcc	.+4      	; 0x964 <prvAddNewTaskToReadyList+0xb2>
     960:	0e 94 a4 01 	call	0x348	; 0x348 <vPortYield>
     964:	df 91       	pop	r29
     966:	cf 91       	pop	r28
     968:	08 95       	ret

0000096a <prvAddCurrentTaskToDelayedList>:
     96a:	0f 93       	push	r16
     96c:	1f 93       	push	r17
     96e:	cf 93       	push	r28
     970:	df 93       	push	r29
     972:	ec 01       	movw	r28, r24
     974:	00 91 03 07 	lds	r16, 0x0703	; 0x800703 <xTickCount>
     978:	10 91 04 07 	lds	r17, 0x0704	; 0x800704 <xTickCount+0x1>
     97c:	80 91 49 07 	lds	r24, 0x0749	; 0x800749 <pxCurrentTCB>
     980:	90 91 4a 07 	lds	r25, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     984:	02 96       	adiw	r24, 0x02	; 2
     986:	0e 94 da 00 	call	0x1b4	; 0x1b4 <uxListRemove>
     98a:	c0 0f       	add	r28, r16
     98c:	d1 1f       	adc	r29, r17
     98e:	e0 91 49 07 	lds	r30, 0x0749	; 0x800749 <pxCurrentTCB>
     992:	f0 91 4a 07 	lds	r31, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     996:	d3 83       	std	Z+3, r29	; 0x03
     998:	c2 83       	std	Z+2, r28	; 0x02
     99a:	c0 17       	cp	r28, r16
     99c:	d1 07       	cpc	r29, r17
     99e:	68 f4       	brcc	.+26     	; 0x9ba <prvAddCurrentTaskToDelayedList+0x50>
     9a0:	60 91 49 07 	lds	r22, 0x0749	; 0x800749 <pxCurrentTCB>
     9a4:	70 91 4a 07 	lds	r23, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     9a8:	80 91 0f 07 	lds	r24, 0x070F	; 0x80070f <pxOverflowDelayedTaskList>
     9ac:	90 91 10 07 	lds	r25, 0x0710	; 0x800710 <pxOverflowDelayedTaskList+0x1>
     9b0:	6e 5f       	subi	r22, 0xFE	; 254
     9b2:	7f 4f       	sbci	r23, 0xFF	; 255
     9b4:	0e 94 a9 00 	call	0x152	; 0x152 <vListInsert>
     9b8:	17 c0       	rjmp	.+46     	; 0x9e8 <prvAddCurrentTaskToDelayedList+0x7e>
     9ba:	60 91 49 07 	lds	r22, 0x0749	; 0x800749 <pxCurrentTCB>
     9be:	70 91 4a 07 	lds	r23, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     9c2:	80 91 11 07 	lds	r24, 0x0711	; 0x800711 <pxDelayedTaskList>
     9c6:	90 91 12 07 	lds	r25, 0x0712	; 0x800712 <pxDelayedTaskList+0x1>
     9ca:	6e 5f       	subi	r22, 0xFE	; 254
     9cc:	7f 4f       	sbci	r23, 0xFF	; 255
     9ce:	0e 94 a9 00 	call	0x152	; 0x152 <vListInsert>
     9d2:	80 91 fb 06 	lds	r24, 0x06FB	; 0x8006fb <xNextTaskUnblockTime>
     9d6:	90 91 fc 06 	lds	r25, 0x06FC	; 0x8006fc <xNextTaskUnblockTime+0x1>
     9da:	c8 17       	cp	r28, r24
     9dc:	d9 07       	cpc	r29, r25
     9de:	20 f4       	brcc	.+8      	; 0x9e8 <prvAddCurrentTaskToDelayedList+0x7e>
     9e0:	d0 93 fc 06 	sts	0x06FC, r29	; 0x8006fc <xNextTaskUnblockTime+0x1>
     9e4:	c0 93 fb 06 	sts	0x06FB, r28	; 0x8006fb <xNextTaskUnblockTime>
     9e8:	df 91       	pop	r29
     9ea:	cf 91       	pop	r28
     9ec:	1f 91       	pop	r17
     9ee:	0f 91       	pop	r16
     9f0:	08 95       	ret

000009f2 <xTaskCreate>:
     9f2:	2f 92       	push	r2
     9f4:	3f 92       	push	r3
     9f6:	4f 92       	push	r4
     9f8:	5f 92       	push	r5
     9fa:	6f 92       	push	r6
     9fc:	7f 92       	push	r7
     9fe:	8f 92       	push	r8
     a00:	9f 92       	push	r9
     a02:	af 92       	push	r10
     a04:	bf 92       	push	r11
     a06:	cf 92       	push	r12
     a08:	df 92       	push	r13
     a0a:	ef 92       	push	r14
     a0c:	ff 92       	push	r15
     a0e:	0f 93       	push	r16
     a10:	1f 93       	push	r17
     a12:	cf 93       	push	r28
     a14:	df 93       	push	r29
     a16:	3c 01       	movw	r6, r24
     a18:	1b 01       	movw	r2, r22
     a1a:	5a 01       	movw	r10, r20
     a1c:	29 01       	movw	r4, r18
     a1e:	ca 01       	movw	r24, r20
     a20:	0e 94 cf 02 	call	0x59e	; 0x59e <pvPortMalloc>
     a24:	6c 01       	movw	r12, r24
     a26:	89 2b       	or	r24, r25
     a28:	71 f0       	breq	.+28     	; 0xa46 <xTaskCreate+0x54>
     a2a:	86 e2       	ldi	r24, 0x26	; 38
     a2c:	90 e0       	ldi	r25, 0x00	; 0
     a2e:	0e 94 cf 02 	call	0x59e	; 0x59e <pvPortMalloc>
     a32:	ec 01       	movw	r28, r24
     a34:	89 2b       	or	r24, r25
     a36:	19 f0       	breq	.+6      	; 0xa3e <xTaskCreate+0x4c>
     a38:	d8 8e       	std	Y+24, r13	; 0x18
     a3a:	cf 8a       	std	Y+23, r12	; 0x17
     a3c:	06 c0       	rjmp	.+12     	; 0xa4a <xTaskCreate+0x58>
     a3e:	c6 01       	movw	r24, r12
     a40:	0e 94 65 03 	call	0x6ca	; 0x6ca <vPortFree>
     a44:	02 c0       	rjmp	.+4      	; 0xa4a <xTaskCreate+0x58>
     a46:	c0 e0       	ldi	r28, 0x00	; 0
     a48:	d0 e0       	ldi	r29, 0x00	; 0
     a4a:	20 97       	sbiw	r28, 0x00	; 0
     a4c:	91 f0       	breq	.+36     	; 0xa72 <xTaskCreate+0x80>
     a4e:	95 01       	movw	r18, r10
     a50:	40 e0       	ldi	r20, 0x00	; 0
     a52:	50 e0       	ldi	r21, 0x00	; 0
     a54:	81 2c       	mov	r8, r1
     a56:	91 2c       	mov	r9, r1
     a58:	5e 01       	movw	r10, r28
     a5a:	67 01       	movw	r12, r14
     a5c:	e0 2e       	mov	r14, r16
     a5e:	82 01       	movw	r16, r4
     a60:	b1 01       	movw	r22, r2
     a62:	c3 01       	movw	r24, r6
     a64:	0e 94 b9 03 	call	0x772	; 0x772 <prvInitialiseNewTask>
     a68:	ce 01       	movw	r24, r28
     a6a:	0e 94 59 04 	call	0x8b2	; 0x8b2 <prvAddNewTaskToReadyList>
     a6e:	81 e0       	ldi	r24, 0x01	; 1
     a70:	01 c0       	rjmp	.+2      	; 0xa74 <xTaskCreate+0x82>
     a72:	8f ef       	ldi	r24, 0xFF	; 255
     a74:	df 91       	pop	r29
     a76:	cf 91       	pop	r28
     a78:	1f 91       	pop	r17
     a7a:	0f 91       	pop	r16
     a7c:	ff 90       	pop	r15
     a7e:	ef 90       	pop	r14
     a80:	df 90       	pop	r13
     a82:	cf 90       	pop	r12
     a84:	bf 90       	pop	r11
     a86:	af 90       	pop	r10
     a88:	9f 90       	pop	r9
     a8a:	8f 90       	pop	r8
     a8c:	7f 90       	pop	r7
     a8e:	6f 90       	pop	r6
     a90:	5f 90       	pop	r5
     a92:	4f 90       	pop	r4
     a94:	3f 90       	pop	r3
     a96:	2f 90       	pop	r2
     a98:	08 95       	ret

00000a9a <vTaskStartScheduler>:
     a9a:	ef 92       	push	r14
     a9c:	ff 92       	push	r15
     a9e:	0f 93       	push	r16
     aa0:	0f 2e       	mov	r0, r31
     aa2:	f9 ef       	ldi	r31, 0xF9	; 249
     aa4:	ef 2e       	mov	r14, r31
     aa6:	f6 e0       	ldi	r31, 0x06	; 6
     aa8:	ff 2e       	mov	r15, r31
     aaa:	f0 2d       	mov	r31, r0
     aac:	00 e0       	ldi	r16, 0x00	; 0
     aae:	20 e0       	ldi	r18, 0x00	; 0
     ab0:	30 e0       	ldi	r19, 0x00	; 0
     ab2:	45 e5       	ldi	r20, 0x55	; 85
     ab4:	50 e0       	ldi	r21, 0x00	; 0
     ab6:	6f e6       	ldi	r22, 0x6F	; 111
     ab8:	70 e0       	ldi	r23, 0x00	; 0
     aba:	83 e2       	ldi	r24, 0x23	; 35
     abc:	94 e0       	ldi	r25, 0x04	; 4
     abe:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskCreate>
     ac2:	81 30       	cpi	r24, 0x01	; 1
     ac4:	81 f4       	brne	.+32     	; 0xae6 <vTaskStartScheduler+0x4c>
     ac6:	f8 94       	cli
     ac8:	8f ef       	ldi	r24, 0xFF	; 255
     aca:	9f ef       	ldi	r25, 0xFF	; 255
     acc:	90 93 fc 06 	sts	0x06FC, r25	; 0x8006fc <xNextTaskUnblockTime+0x1>
     ad0:	80 93 fb 06 	sts	0x06FB, r24	; 0x8006fb <xNextTaskUnblockTime>
     ad4:	81 e0       	ldi	r24, 0x01	; 1
     ad6:	80 93 01 07 	sts	0x0701, r24	; 0x800701 <xSchedulerRunning>
     ada:	10 92 04 07 	sts	0x0704, r1	; 0x800704 <xTickCount+0x1>
     ade:	10 92 03 07 	sts	0x0703, r1	; 0x800703 <xTickCount>
     ae2:	0e 94 75 01 	call	0x2ea	; 0x2ea <xPortStartScheduler>
     ae6:	0f 91       	pop	r16
     ae8:	ff 90       	pop	r15
     aea:	ef 90       	pop	r14
     aec:	08 95       	ret

00000aee <vTaskSuspendAll>:
     aee:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <uxSchedulerSuspended>
     af2:	8f 5f       	subi	r24, 0xFF	; 255
     af4:	80 93 f8 06 	sts	0x06F8, r24	; 0x8006f8 <uxSchedulerSuspended>
     af8:	08 95       	ret

00000afa <xTaskGetTickCount>:
     afa:	0f b6       	in	r0, 0x3f	; 63
     afc:	f8 94       	cli
     afe:	0f 92       	push	r0
     b00:	80 91 03 07 	lds	r24, 0x0703	; 0x800703 <xTickCount>
     b04:	90 91 04 07 	lds	r25, 0x0704	; 0x800704 <xTickCount+0x1>
     b08:	0f 90       	pop	r0
     b0a:	0f be       	out	0x3f, r0	; 63
     b0c:	08 95       	ret

00000b0e <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     b0e:	df 92       	push	r13
     b10:	ef 92       	push	r14
     b12:	ff 92       	push	r15
     b14:	0f 93       	push	r16
     b16:	1f 93       	push	r17
     b18:	cf 93       	push	r28
     b1a:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     b1c:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <uxSchedulerSuspended>
     b20:	81 11       	cpse	r24, r1
     b22:	97 c0       	rjmp	.+302    	; 0xc52 <xTaskIncrementTick+0x144>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
     b24:	e0 90 03 07 	lds	r14, 0x0703	; 0x800703 <xTickCount>
     b28:	f0 90 04 07 	lds	r15, 0x0704	; 0x800704 <xTickCount+0x1>
     b2c:	8f ef       	ldi	r24, 0xFF	; 255
     b2e:	e8 1a       	sub	r14, r24
     b30:	f8 0a       	sbc	r15, r24

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     b32:	f0 92 04 07 	sts	0x0704, r15	; 0x800704 <xTickCount+0x1>
     b36:	e0 92 03 07 	sts	0x0703, r14	; 0x800703 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U )
     b3a:	e1 14       	cp	r14, r1
     b3c:	f1 04       	cpc	r15, r1
     b3e:	b9 f4       	brne	.+46     	; 0xb6e <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     b40:	80 91 11 07 	lds	r24, 0x0711	; 0x800711 <pxDelayedTaskList>
     b44:	90 91 12 07 	lds	r25, 0x0712	; 0x800712 <pxDelayedTaskList+0x1>
     b48:	20 91 0f 07 	lds	r18, 0x070F	; 0x80070f <pxOverflowDelayedTaskList>
     b4c:	30 91 10 07 	lds	r19, 0x0710	; 0x800710 <pxOverflowDelayedTaskList+0x1>
     b50:	30 93 12 07 	sts	0x0712, r19	; 0x800712 <pxDelayedTaskList+0x1>
     b54:	20 93 11 07 	sts	0x0711, r18	; 0x800711 <pxDelayedTaskList>
     b58:	90 93 10 07 	sts	0x0710, r25	; 0x800710 <pxOverflowDelayedTaskList+0x1>
     b5c:	80 93 0f 07 	sts	0x070F, r24	; 0x80070f <pxOverflowDelayedTaskList>
     b60:	80 91 fe 06 	lds	r24, 0x06FE	; 0x8006fe <xNumOfOverflows>
     b64:	8f 5f       	subi	r24, 0xFF	; 255
     b66:	80 93 fe 06 	sts	0x06FE, r24	; 0x8006fe <xNumOfOverflows>
     b6a:	0e 94 9a 03 	call	0x734	; 0x734 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     b6e:	80 91 fb 06 	lds	r24, 0x06FB	; 0x8006fb <xNextTaskUnblockTime>
     b72:	90 91 fc 06 	lds	r25, 0x06FC	; 0x8006fc <xNextTaskUnblockTime+0x1>
     b76:	e8 16       	cp	r14, r24
     b78:	f9 06       	cpc	r15, r25
     b7a:	28 f4       	brcc	.+10     	; 0xb86 <xTaskIncrementTick+0x78>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     b7c:	d1 2c       	mov	r13, r1
     b7e:	53 c0       	rjmp	.+166    	; 0xc26 <xTaskIncrementTick+0x118>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
     b80:	dd 24       	eor	r13, r13
     b82:	d3 94       	inc	r13
     b84:	01 c0       	rjmp	.+2      	; 0xb88 <xTaskIncrementTick+0x7a>
     b86:	d1 2c       	mov	r13, r1
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     b88:	e0 91 11 07 	lds	r30, 0x0711	; 0x800711 <pxDelayedTaskList>
     b8c:	f0 91 12 07 	lds	r31, 0x0712	; 0x800712 <pxDelayedTaskList+0x1>
     b90:	80 81       	ld	r24, Z
     b92:	81 11       	cpse	r24, r1
     b94:	07 c0       	rjmp	.+14     	; 0xba4 <xTaskIncrementTick+0x96>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     b96:	8f ef       	ldi	r24, 0xFF	; 255
     b98:	9f ef       	ldi	r25, 0xFF	; 255
     b9a:	90 93 fc 06 	sts	0x06FC, r25	; 0x8006fc <xNextTaskUnblockTime+0x1>
     b9e:	80 93 fb 06 	sts	0x06FB, r24	; 0x8006fb <xNextTaskUnblockTime>
					break;
     ba2:	41 c0       	rjmp	.+130    	; 0xc26 <xTaskIncrementTick+0x118>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     ba4:	e0 91 11 07 	lds	r30, 0x0711	; 0x800711 <pxDelayedTaskList>
     ba8:	f0 91 12 07 	lds	r31, 0x0712	; 0x800712 <pxDelayedTaskList+0x1>
     bac:	05 80       	ldd	r0, Z+5	; 0x05
     bae:	f6 81       	ldd	r31, Z+6	; 0x06
     bb0:	e0 2d       	mov	r30, r0
     bb2:	c6 81       	ldd	r28, Z+6	; 0x06
     bb4:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     bb6:	8a 81       	ldd	r24, Y+2	; 0x02
     bb8:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
     bba:	e8 16       	cp	r14, r24
     bbc:	f9 06       	cpc	r15, r25
     bbe:	28 f4       	brcc	.+10     	; 0xbca <xTaskIncrementTick+0xbc>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     bc0:	90 93 fc 06 	sts	0x06FC, r25	; 0x8006fc <xNextTaskUnblockTime+0x1>
     bc4:	80 93 fb 06 	sts	0x06FB, r24	; 0x8006fb <xNextTaskUnblockTime>
						break;
     bc8:	2e c0       	rjmp	.+92     	; 0xc26 <xTaskIncrementTick+0x118>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     bca:	8e 01       	movw	r16, r28
     bcc:	0e 5f       	subi	r16, 0xFE	; 254
     bce:	1f 4f       	sbci	r17, 0xFF	; 255
     bd0:	c8 01       	movw	r24, r16
     bd2:	0e 94 da 00 	call	0x1b4	; 0x1b4 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     bd6:	8c 89       	ldd	r24, Y+20	; 0x14
     bd8:	9d 89       	ldd	r25, Y+21	; 0x15
     bda:	89 2b       	or	r24, r25
     bdc:	21 f0       	breq	.+8      	; 0xbe6 <xTaskIncrementTick+0xd8>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     bde:	ce 01       	movw	r24, r28
     be0:	0c 96       	adiw	r24, 0x0c	; 12
     be2:	0e 94 da 00 	call	0x1b4	; 0x1b4 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     be6:	8e 89       	ldd	r24, Y+22	; 0x16
     be8:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <uxTopReadyPriority>
     bec:	98 17       	cp	r25, r24
     bee:	10 f4       	brcc	.+4      	; 0xbf4 <xTaskIncrementTick+0xe6>
     bf0:	80 93 02 07 	sts	0x0702, r24	; 0x800702 <uxTopReadyPriority>
     bf4:	90 e0       	ldi	r25, 0x00	; 0
     bf6:	9c 01       	movw	r18, r24
     bf8:	22 0f       	add	r18, r18
     bfa:	33 1f       	adc	r19, r19
     bfc:	22 0f       	add	r18, r18
     bfe:	33 1f       	adc	r19, r19
     c00:	22 0f       	add	r18, r18
     c02:	33 1f       	adc	r19, r19
     c04:	82 0f       	add	r24, r18
     c06:	93 1f       	adc	r25, r19
     c08:	b8 01       	movw	r22, r16
     c0a:	8b 5d       	subi	r24, 0xDB	; 219
     c0c:	98 4f       	sbci	r25, 0xF8	; 248
     c0e:	0e 94 88 00 	call	0x110	; 0x110 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     c12:	9e 89       	ldd	r25, Y+22	; 0x16
     c14:	e0 91 49 07 	lds	r30, 0x0749	; 0x800749 <pxCurrentTCB>
     c18:	f0 91 4a 07 	lds	r31, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     c1c:	86 89       	ldd	r24, Z+22	; 0x16
     c1e:	98 17       	cp	r25, r24
     c20:	08 f0       	brcs	.+2      	; 0xc24 <xTaskIncrementTick+0x116>
     c22:	ae cf       	rjmp	.-164    	; 0xb80 <xTaskIncrementTick+0x72>
     c24:	b1 cf       	rjmp	.-158    	; 0xb88 <xTaskIncrementTick+0x7a>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     c26:	e0 91 49 07 	lds	r30, 0x0749	; 0x800749 <pxCurrentTCB>
     c2a:	f0 91 4a 07 	lds	r31, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     c2e:	86 89       	ldd	r24, Z+22	; 0x16
     c30:	90 e0       	ldi	r25, 0x00	; 0
     c32:	fc 01       	movw	r30, r24
     c34:	ee 0f       	add	r30, r30
     c36:	ff 1f       	adc	r31, r31
     c38:	ee 0f       	add	r30, r30
     c3a:	ff 1f       	adc	r31, r31
     c3c:	ee 0f       	add	r30, r30
     c3e:	ff 1f       	adc	r31, r31
     c40:	8e 0f       	add	r24, r30
     c42:	9f 1f       	adc	r25, r31
     c44:	fc 01       	movw	r30, r24
     c46:	eb 5d       	subi	r30, 0xDB	; 219
     c48:	f8 4f       	sbci	r31, 0xF8	; 248
     c4a:	80 81       	ld	r24, Z
     c4c:	82 30       	cpi	r24, 0x02	; 2
     c4e:	40 f4       	brcc	.+16     	; 0xc60 <xTaskIncrementTick+0x152>
     c50:	09 c0       	rjmp	.+18     	; 0xc64 <xTaskIncrementTick+0x156>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     c52:	80 91 00 07 	lds	r24, 0x0700	; 0x800700 <uxPendedTicks>
     c56:	8f 5f       	subi	r24, 0xFF	; 255
     c58:	80 93 00 07 	sts	0x0700, r24	; 0x800700 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     c5c:	d1 2c       	mov	r13, r1
     c5e:	02 c0       	rjmp	.+4      	; 0xc64 <xTaskIncrementTick+0x156>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
     c60:	dd 24       	eor	r13, r13
     c62:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     c64:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <xYieldPending>
     c68:	88 23       	and	r24, r24
     c6a:	11 f0       	breq	.+4      	; 0xc70 <xTaskIncrementTick+0x162>
		{
			xSwitchRequired = pdTRUE;
     c6c:	dd 24       	eor	r13, r13
     c6e:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     c70:	8d 2d       	mov	r24, r13
     c72:	df 91       	pop	r29
     c74:	cf 91       	pop	r28
     c76:	1f 91       	pop	r17
     c78:	0f 91       	pop	r16
     c7a:	ff 90       	pop	r15
     c7c:	ef 90       	pop	r14
     c7e:	df 90       	pop	r13
     c80:	08 95       	ret

00000c82 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     c82:	0f 93       	push	r16
     c84:	1f 93       	push	r17
     c86:	cf 93       	push	r28
     c88:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     c8a:	0f b6       	in	r0, 0x3f	; 63
     c8c:	f8 94       	cli
     c8e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     c90:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <uxSchedulerSuspended>
     c94:	81 50       	subi	r24, 0x01	; 1
     c96:	80 93 f8 06 	sts	0x06F8, r24	; 0x8006f8 <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c9a:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <uxSchedulerSuspended>
     c9e:	81 11       	cpse	r24, r1
     ca0:	58 c0       	rjmp	.+176    	; 0xd52 <xTaskResumeAll+0xd0>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     ca2:	80 91 05 07 	lds	r24, 0x0705	; 0x800705 <uxCurrentNumberOfTasks>
     ca6:	81 11       	cpse	r24, r1
     ca8:	33 c0       	rjmp	.+102    	; 0xd10 <xTaskResumeAll+0x8e>
     caa:	56 c0       	rjmp	.+172    	; 0xd58 <xTaskResumeAll+0xd6>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     cac:	e0 91 0b 07 	lds	r30, 0x070B	; 0x80070b <xPendingReadyList+0x5>
     cb0:	f0 91 0c 07 	lds	r31, 0x070C	; 0x80070c <xPendingReadyList+0x6>
     cb4:	c6 81       	ldd	r28, Z+6	; 0x06
     cb6:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     cb8:	ce 01       	movw	r24, r28
     cba:	0c 96       	adiw	r24, 0x0c	; 12
     cbc:	0e 94 da 00 	call	0x1b4	; 0x1b4 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     cc0:	8e 01       	movw	r16, r28
     cc2:	0e 5f       	subi	r16, 0xFE	; 254
     cc4:	1f 4f       	sbci	r17, 0xFF	; 255
     cc6:	c8 01       	movw	r24, r16
     cc8:	0e 94 da 00 	call	0x1b4	; 0x1b4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     ccc:	8e 89       	ldd	r24, Y+22	; 0x16
     cce:	90 91 02 07 	lds	r25, 0x0702	; 0x800702 <uxTopReadyPriority>
     cd2:	98 17       	cp	r25, r24
     cd4:	10 f4       	brcc	.+4      	; 0xcda <xTaskResumeAll+0x58>
     cd6:	80 93 02 07 	sts	0x0702, r24	; 0x800702 <uxTopReadyPriority>
     cda:	90 e0       	ldi	r25, 0x00	; 0
     cdc:	9c 01       	movw	r18, r24
     cde:	22 0f       	add	r18, r18
     ce0:	33 1f       	adc	r19, r19
     ce2:	22 0f       	add	r18, r18
     ce4:	33 1f       	adc	r19, r19
     ce6:	22 0f       	add	r18, r18
     ce8:	33 1f       	adc	r19, r19
     cea:	82 0f       	add	r24, r18
     cec:	93 1f       	adc	r25, r19
     cee:	b8 01       	movw	r22, r16
     cf0:	8b 5d       	subi	r24, 0xDB	; 219
     cf2:	98 4f       	sbci	r25, 0xF8	; 248
     cf4:	0e 94 88 00 	call	0x110	; 0x110 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     cf8:	9e 89       	ldd	r25, Y+22	; 0x16
     cfa:	e0 91 49 07 	lds	r30, 0x0749	; 0x800749 <pxCurrentTCB>
     cfe:	f0 91 4a 07 	lds	r31, 0x074A	; 0x80074a <pxCurrentTCB+0x1>
     d02:	86 89       	ldd	r24, Z+22	; 0x16
     d04:	98 17       	cp	r25, r24
     d06:	30 f0       	brcs	.+12     	; 0xd14 <xTaskResumeAll+0x92>
					{
						xYieldPending = pdTRUE;
     d08:	81 e0       	ldi	r24, 0x01	; 1
     d0a:	80 93 ff 06 	sts	0x06FF, r24	; 0x8006ff <xYieldPending>
     d0e:	02 c0       	rjmp	.+4      	; 0xd14 <xTaskResumeAll+0x92>
     d10:	c0 e0       	ldi	r28, 0x00	; 0
     d12:	d0 e0       	ldi	r29, 0x00	; 0
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     d14:	80 91 06 07 	lds	r24, 0x0706	; 0x800706 <xPendingReadyList>
     d18:	81 11       	cpse	r24, r1
     d1a:	c8 cf       	rjmp	.-112    	; 0xcac <xTaskResumeAll+0x2a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     d1c:	cd 2b       	or	r28, r29
     d1e:	11 f0       	breq	.+4      	; 0xd24 <xTaskResumeAll+0xa2>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     d20:	0e 94 9a 03 	call	0x734	; 0x734 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     d24:	c0 91 00 07 	lds	r28, 0x0700	; 0x800700 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     d28:	cc 23       	and	r28, r28
     d2a:	59 f0       	breq	.+22     	; 0xd42 <xTaskResumeAll+0xc0>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     d2c:	0e 94 87 05 	call	0xb0e	; 0xb0e <xTaskIncrementTick>
     d30:	88 23       	and	r24, r24
     d32:	19 f0       	breq	.+6      	; 0xd3a <xTaskResumeAll+0xb8>
							{
								xYieldPending = pdTRUE;
     d34:	81 e0       	ldi	r24, 0x01	; 1
     d36:	80 93 ff 06 	sts	0x06FF, r24	; 0x8006ff <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     d3a:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     d3c:	b9 f7       	brne	.-18     	; 0xd2c <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
     d3e:	10 92 00 07 	sts	0x0700, r1	; 0x800700 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     d42:	80 91 ff 06 	lds	r24, 0x06FF	; 0x8006ff <xYieldPending>
     d46:	88 23       	and	r24, r24
     d48:	31 f0       	breq	.+12     	; 0xd56 <xTaskResumeAll+0xd4>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     d4a:	0e 94 a4 01 	call	0x348	; 0x348 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     d4e:	81 e0       	ldi	r24, 0x01	; 1
     d50:	03 c0       	rjmp	.+6      	; 0xd58 <xTaskResumeAll+0xd6>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     d52:	80 e0       	ldi	r24, 0x00	; 0
     d54:	01 c0       	rjmp	.+2      	; 0xd58 <xTaskResumeAll+0xd6>
     d56:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     d58:	0f 90       	pop	r0
     d5a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     d5c:	df 91       	pop	r29
     d5e:	cf 91       	pop	r28
     d60:	1f 91       	pop	r17
     d62:	0f 91       	pop	r16
     d64:	08 95       	ret

00000d66 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     d66:	0f 93       	push	r16
     d68:	1f 93       	push	r17
     d6a:	cf 93       	push	r28
     d6c:	df 93       	push	r29
     d6e:	8c 01       	movw	r16, r24
     d70:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     d72:	0e 94 77 05 	call	0xaee	; 0xaee <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     d76:	40 91 03 07 	lds	r20, 0x0703	; 0x800703 <xTickCount>
     d7a:	50 91 04 07 	lds	r21, 0x0704	; 0x800704 <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     d7e:	f8 01       	movw	r30, r16
     d80:	20 81       	ld	r18, Z
     d82:	31 81       	ldd	r19, Z+1	; 0x01
     d84:	c9 01       	movw	r24, r18
     d86:	8c 0f       	add	r24, r28
     d88:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     d8a:	42 17       	cp	r20, r18
     d8c:	53 07       	cpc	r21, r19
     d8e:	40 f4       	brcc	.+16     	; 0xda0 <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     d90:	82 17       	cp	r24, r18
     d92:	93 07       	cpc	r25, r19
     d94:	68 f4       	brcc	.+26     	; 0xdb0 <vTaskDelayUntil+0x4a>
     d96:	48 17       	cp	r20, r24
     d98:	59 07       	cpc	r21, r25
     d9a:	60 f0       	brcs	.+24     	; 0xdb4 <vTaskDelayUntil+0x4e>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     d9c:	20 e0       	ldi	r18, 0x00	; 0
     d9e:	0f c0       	rjmp	.+30     	; 0xdbe <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     da0:	82 17       	cp	r24, r18
     da2:	93 07       	cpc	r25, r19
     da4:	48 f0       	brcs	.+18     	; 0xdb8 <vTaskDelayUntil+0x52>
     da6:	48 17       	cp	r20, r24
     da8:	59 07       	cpc	r21, r25
     daa:	40 f0       	brcs	.+16     	; 0xdbc <vTaskDelayUntil+0x56>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     dac:	20 e0       	ldi	r18, 0x00	; 0
     dae:	07 c0       	rjmp	.+14     	; 0xdbe <vTaskDelayUntil+0x58>
     db0:	20 e0       	ldi	r18, 0x00	; 0
     db2:	05 c0       	rjmp	.+10     	; 0xdbe <vTaskDelayUntil+0x58>
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     db4:	21 e0       	ldi	r18, 0x01	; 1
     db6:	03 c0       	rjmp	.+6      	; 0xdbe <vTaskDelayUntil+0x58>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     db8:	21 e0       	ldi	r18, 0x01	; 1
     dba:	01 c0       	rjmp	.+2      	; 0xdbe <vTaskDelayUntil+0x58>
     dbc:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     dbe:	f8 01       	movw	r30, r16
     dc0:	91 83       	std	Z+1, r25	; 0x01
     dc2:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     dc4:	22 23       	and	r18, r18
     dc6:	29 f0       	breq	.+10     	; 0xdd2 <vTaskDelayUntil+0x6c>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     dc8:	60 e0       	ldi	r22, 0x00	; 0
     dca:	84 1b       	sub	r24, r20
     dcc:	95 0b       	sbc	r25, r21
     dce:	0e 94 b5 04 	call	0x96a	; 0x96a <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     dd2:	0e 94 41 06 	call	0xc82	; 0xc82 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     dd6:	81 11       	cpse	r24, r1
     dd8:	02 c0       	rjmp	.+4      	; 0xdde <vTaskDelayUntil+0x78>
		{
			portYIELD_WITHIN_API();
     dda:	0e 94 a4 01 	call	0x348	; 0x348 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     dde:	df 91       	pop	r29
     de0:	cf 91       	pop	r28
     de2:	1f 91       	pop	r17
     de4:	0f 91       	pop	r16
     de6:	08 95       	ret

00000de8 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     de8:	80 91 f8 06 	lds	r24, 0x06F8	; 0x8006f8 <uxSchedulerSuspended>
     dec:	88 23       	and	r24, r24
     dee:	21 f0       	breq	.+8      	; 0xdf8 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     df0:	81 e0       	ldi	r24, 0x01	; 1
     df2:	80 93 ff 06 	sts	0x06FF, r24	; 0x8006ff <xYieldPending>
     df6:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     df8:	10 92 ff 06 	sts	0x06FF, r1	; 0x8006ff <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     dfc:	20 91 02 07 	lds	r18, 0x0702	; 0x800702 <uxTopReadyPriority>
     e00:	01 c0       	rjmp	.+2      	; 0xe04 <vTaskSwitchContext+0x1c>
     e02:	21 50       	subi	r18, 0x01	; 1
     e04:	82 2f       	mov	r24, r18
     e06:	90 e0       	ldi	r25, 0x00	; 0
     e08:	fc 01       	movw	r30, r24
     e0a:	ee 0f       	add	r30, r30
     e0c:	ff 1f       	adc	r31, r31
     e0e:	ee 0f       	add	r30, r30
     e10:	ff 1f       	adc	r31, r31
     e12:	ee 0f       	add	r30, r30
     e14:	ff 1f       	adc	r31, r31
     e16:	e8 0f       	add	r30, r24
     e18:	f9 1f       	adc	r31, r25
     e1a:	eb 5d       	subi	r30, 0xDB	; 219
     e1c:	f8 4f       	sbci	r31, 0xF8	; 248
     e1e:	30 81       	ld	r19, Z
     e20:	33 23       	and	r19, r19
     e22:	79 f3       	breq	.-34     	; 0xe02 <vTaskSwitchContext+0x1a>
     e24:	ac 01       	movw	r20, r24
     e26:	44 0f       	add	r20, r20
     e28:	55 1f       	adc	r21, r21
     e2a:	44 0f       	add	r20, r20
     e2c:	55 1f       	adc	r21, r21
     e2e:	44 0f       	add	r20, r20
     e30:	55 1f       	adc	r21, r21
     e32:	48 0f       	add	r20, r24
     e34:	59 1f       	adc	r21, r25
     e36:	df 01       	movw	r26, r30
     e38:	01 80       	ldd	r0, Z+1	; 0x01
     e3a:	f2 81       	ldd	r31, Z+2	; 0x02
     e3c:	e0 2d       	mov	r30, r0
     e3e:	02 80       	ldd	r0, Z+2	; 0x02
     e40:	f3 81       	ldd	r31, Z+3	; 0x03
     e42:	e0 2d       	mov	r30, r0
     e44:	12 96       	adiw	r26, 0x02	; 2
     e46:	fc 93       	st	X, r31
     e48:	ee 93       	st	-X, r30
     e4a:	11 97       	sbiw	r26, 0x01	; 1
     e4c:	48 5d       	subi	r20, 0xD8	; 216
     e4e:	58 4f       	sbci	r21, 0xF8	; 248
     e50:	e4 17       	cp	r30, r20
     e52:	f5 07       	cpc	r31, r21
     e54:	29 f4       	brne	.+10     	; 0xe60 <vTaskSwitchContext+0x78>
     e56:	42 81       	ldd	r20, Z+2	; 0x02
     e58:	53 81       	ldd	r21, Z+3	; 0x03
     e5a:	fd 01       	movw	r30, r26
     e5c:	52 83       	std	Z+2, r21	; 0x02
     e5e:	41 83       	std	Z+1, r20	; 0x01
     e60:	fc 01       	movw	r30, r24
     e62:	ee 0f       	add	r30, r30
     e64:	ff 1f       	adc	r31, r31
     e66:	ee 0f       	add	r30, r30
     e68:	ff 1f       	adc	r31, r31
     e6a:	ee 0f       	add	r30, r30
     e6c:	ff 1f       	adc	r31, r31
     e6e:	8e 0f       	add	r24, r30
     e70:	9f 1f       	adc	r25, r31
     e72:	fc 01       	movw	r30, r24
     e74:	eb 5d       	subi	r30, 0xDB	; 219
     e76:	f8 4f       	sbci	r31, 0xF8	; 248
     e78:	01 80       	ldd	r0, Z+1	; 0x01
     e7a:	f2 81       	ldd	r31, Z+2	; 0x02
     e7c:	e0 2d       	mov	r30, r0
     e7e:	86 81       	ldd	r24, Z+6	; 0x06
     e80:	97 81       	ldd	r25, Z+7	; 0x07
     e82:	90 93 4a 07 	sts	0x074A, r25	; 0x80074a <pxCurrentTCB+0x1>
     e86:	80 93 49 07 	sts	0x0749, r24	; 0x800749 <pxCurrentTCB>
     e8a:	20 93 02 07 	sts	0x0702, r18	; 0x800702 <uxTopReadyPriority>
     e8e:	08 95       	ret

00000e90 <KP_Init>:
* @param [in]  KP_CH   -  Keypad channel number.
*
* @return function error state.
*/
extern ERROR_STATE_t KP_Init(uint8_t KP_CH)
{
     e90:	ff 92       	push	r15
     e92:	0f 93       	push	r16
     e94:	1f 93       	push	r17
     e96:	cf 93       	push	r28
     e98:	df 93       	push	r29
   ERROR_STATE_t KP_ErrorState;
   
   if(KP_INVALID_CH <= KP_CH)
     e9a:	81 11       	cpse	r24, r1
     e9c:	4e c0       	rjmp	.+156    	; 0xf3a <KP_Init+0xaa>
     e9e:	08 2f       	mov	r16, r24
     ea0:	10 e0       	ldi	r17, 0x00	; 0
     ea2:	17 c0       	rjmp	.+46     	; 0xed2 <KP_Init+0x42>
   else
   {
      /* Set columns pins to output initially High */
      for(uint8_t u8_Counter = 0; u8_Counter < aSTR_KPConfig[KP_CH].u8_KPCols; u8_Counter++)
      {
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_Counter) , PIN_INPUT);
     ea4:	9e 01       	movw	r18, r28
     ea6:	22 0f       	add	r18, r18
     ea8:	33 1f       	adc	r19, r19
     eaa:	f9 01       	movw	r30, r18
     eac:	ec 0f       	add	r30, r28
     eae:	fd 1f       	adc	r31, r29
     eb0:	ee 0f       	add	r30, r30
     eb2:	ff 1f       	adc	r31, r31
     eb4:	e4 52       	subi	r30, 0x24	; 36
     eb6:	ff 4f       	sbci	r31, 0xFF	; 255
     eb8:	f5 80       	ldd	r15, Z+5	; 0x05
     eba:	f1 0e       	add	r15, r17
     ebc:	c4 81       	ldd	r28, Z+4	; 0x04
     ebe:	40 e0       	ldi	r20, 0x00	; 0
     ec0:	6f 2d       	mov	r22, r15
     ec2:	8c 2f       	mov	r24, r28
     ec4:	0e 94 0c 0a 	call	0x1418	; 0x1418 <DIO_SetPinDirection>
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_Counter));
     ec8:	6f 2d       	mov	r22, r15
     eca:	8c 2f       	mov	r24, r28
     ecc:	0e 94 21 0b 	call	0x1642	; 0x1642 <DIO_EnablePinPullup>
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_INVALID_CH);
   }
   else
   {
      /* Set columns pins to output initially High */
      for(uint8_t u8_Counter = 0; u8_Counter < aSTR_KPConfig[KP_CH].u8_KPCols; u8_Counter++)
     ed0:	1f 5f       	subi	r17, 0xFF	; 255
     ed2:	c0 2f       	mov	r28, r16
     ed4:	d0 e0       	ldi	r29, 0x00	; 0
     ed6:	fe 01       	movw	r30, r28
     ed8:	ee 0f       	add	r30, r30
     eda:	ff 1f       	adc	r31, r31
     edc:	ec 0f       	add	r30, r28
     ede:	fd 1f       	adc	r31, r29
     ee0:	ee 0f       	add	r30, r30
     ee2:	ff 1f       	adc	r31, r31
     ee4:	e4 52       	subi	r30, 0x24	; 36
     ee6:	ff 4f       	sbci	r31, 0xFF	; 255
     ee8:	83 81       	ldd	r24, Z+3	; 0x03
     eea:	18 17       	cp	r17, r24
     eec:	d8 f2       	brcs	.-74     	; 0xea4 <KP_Init+0x14>
     eee:	10 e0       	ldi	r17, 0x00	; 0
     ef0:	16 c0       	rjmp	.+44     	; 0xf1e <KP_Init+0x8e>
      }
      
      /* Set rows pins to input and set pull up resistors */
      for(uint8_t u8_Counter = 0; u8_Counter < aSTR_KPConfig[KP_CH].u8_KPRows; u8_Counter++)
      {
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_Counter) , PIN_INPUT);
     ef2:	fe 01       	movw	r30, r28
     ef4:	ee 0f       	add	r30, r30
     ef6:	ff 1f       	adc	r31, r31
     ef8:	ec 0f       	add	r30, r28
     efa:	fd 1f       	adc	r31, r29
     efc:	ee 0f       	add	r30, r30
     efe:	ff 1f       	adc	r31, r31
     f00:	e4 52       	subi	r30, 0x24	; 36
     f02:	ff 4f       	sbci	r31, 0xFF	; 255
     f04:	02 81       	ldd	r16, Z+2	; 0x02
     f06:	01 0f       	add	r16, r17
     f08:	f1 80       	ldd	r15, Z+1	; 0x01
     f0a:	40 e0       	ldi	r20, 0x00	; 0
     f0c:	60 2f       	mov	r22, r16
     f0e:	8f 2d       	mov	r24, r15
     f10:	0e 94 0c 0a 	call	0x1418	; 0x1418 <DIO_SetPinDirection>
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_Counter));
     f14:	60 2f       	mov	r22, r16
     f16:	8f 2d       	mov	r24, r15
     f18:	0e 94 21 0b 	call	0x1642	; 0x1642 <DIO_EnablePinPullup>
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_Counter) , PIN_INPUT);
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_Counter));
      }
      
      /* Set rows pins to input and set pull up resistors */
      for(uint8_t u8_Counter = 0; u8_Counter < aSTR_KPConfig[KP_CH].u8_KPRows; u8_Counter++)
     f1c:	1f 5f       	subi	r17, 0xFF	; 255
     f1e:	fe 01       	movw	r30, r28
     f20:	ee 0f       	add	r30, r30
     f22:	ff 1f       	adc	r31, r31
     f24:	ec 0f       	add	r30, r28
     f26:	fd 1f       	adc	r31, r29
     f28:	ee 0f       	add	r30, r30
     f2a:	ff 1f       	adc	r31, r31
     f2c:	e4 52       	subi	r30, 0x24	; 36
     f2e:	ff 4f       	sbci	r31, 0xFF	; 255
     f30:	80 81       	ld	r24, Z
     f32:	18 17       	cp	r17, r24
     f34:	f0 f2       	brcs	.-68     	; 0xef2 <KP_Init+0x62>
      {
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_Counter) , PIN_INPUT);
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_Counter));
      }
      KP_ErrorState = ERROR_OK;
     f36:	80 e0       	ldi	r24, 0x00	; 0
     f38:	01 c0       	rjmp	.+2      	; 0xf3c <KP_Init+0xac>
{
   ERROR_STATE_t KP_ErrorState;
   
   if(KP_INVALID_CH <= KP_CH)
   {
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_INVALID_CH);
     f3a:	82 ee       	ldi	r24, 0xE2	; 226
      KP_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return KP_ErrorState;
}
     f3c:	df 91       	pop	r29
     f3e:	cf 91       	pop	r28
     f40:	1f 91       	pop	r17
     f42:	0f 91       	pop	r16
     f44:	ff 90       	pop	r15
     f46:	08 95       	ret

00000f48 <KP_GetPressedValue>:
* @param [out] Data     -  Pressed Key Value.
*
* @return function error state.
*/
ERROR_STATE_t KP_GetPressedValue(uint8_t KP_CH, uint32_t * const Data)
{
     f48:	5f 92       	push	r5
     f4a:	6f 92       	push	r6
     f4c:	7f 92       	push	r7
     f4e:	8f 92       	push	r8
     f50:	9f 92       	push	r9
     f52:	af 92       	push	r10
     f54:	bf 92       	push	r11
     f56:	cf 92       	push	r12
     f58:	df 92       	push	r13
     f5a:	ef 92       	push	r14
     f5c:	ff 92       	push	r15
     f5e:	0f 93       	push	r16
     f60:	1f 93       	push	r17
     f62:	cf 93       	push	r28
     f64:	df 93       	push	r29
     f66:	1f 92       	push	r1
     f68:	cd b7       	in	r28, 0x3d	; 61
     f6a:	de b7       	in	r29, 0x3e	; 62
   ERROR_STATE_t KP_ErrorState;
      
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Data)
     f6c:	61 15       	cp	r22, r1
     f6e:	71 05       	cpc	r23, r1
     f70:	09 f4       	brne	.+2      	; 0xf74 <KP_GetPressedValue+0x2c>
     f72:	9e c0       	rjmp	.+316    	; 0x10b0 <KP_GetPressedValue+0x168>
   {
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_NULL_PTR);
   }
   else if(KP_INVALID_CH <= KP_CH)
     f74:	81 11       	cpse	r24, r1
     f76:	9e c0       	rjmp	.+316    	; 0x10b4 <KP_GetPressedValue+0x16c>
     f78:	6b 01       	movw	r12, r22
     f7a:	e8 2e       	mov	r14, r24
     f7c:	61 2c       	mov	r6, r1
     f7e:	81 2c       	mov	r8, r1
     f80:	91 2c       	mov	r9, r1
     f82:	54 01       	movw	r10, r8
     f84:	68 c0       	rjmp	.+208    	; 0x1056 <KP_GetPressedValue+0x10e>
      
      /* loops on every column */
      for(uint8_t u8_ColCounter = 0; u8_ColCounter < aSTR_KPConfig[KP_CH].u8_KPCols; u8_ColCounter++)
      {
         /* set column value to low */
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter) , PIN_OUTPUT);
     f86:	f8 01       	movw	r30, r16
     f88:	ee 0f       	add	r30, r30
     f8a:	ff 1f       	adc	r31, r31
     f8c:	e0 0f       	add	r30, r16
     f8e:	f1 1f       	adc	r31, r17
     f90:	ee 0f       	add	r30, r30
     f92:	ff 1f       	adc	r31, r31
     f94:	e4 52       	subi	r30, 0x24	; 36
     f96:	ff 4f       	sbci	r31, 0xFF	; 255
     f98:	75 80       	ldd	r7, Z+5	; 0x05
     f9a:	76 0c       	add	r7, r6
     f9c:	54 80       	ldd	r5, Z+4	; 0x04
     f9e:	41 e0       	ldi	r20, 0x01	; 1
     fa0:	67 2d       	mov	r22, r7
     fa2:	85 2d       	mov	r24, r5
     fa4:	0e 94 0c 0a 	call	0x1418	; 0x1418 <DIO_SetPinDirection>
         DIO_WritePin(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter), PIN_LOW);
     fa8:	40 e0       	ldi	r20, 0x00	; 0
     faa:	67 2d       	mov	r22, r7
     fac:	85 2d       	mov	r24, r5
     fae:	0e 94 75 0a 	call	0x14ea	; 0x14ea <DIO_WritePin>
         
         /* loops on every row */
         for(uint8_t u8_RowCounter = 0; u8_RowCounter < aSTR_KPConfig[KP_CH].u8_KPRows; u8_RowCounter++)
     fb2:	f1 2c       	mov	r15, r1
     fb4:	39 c0       	rjmp	.+114    	; 0x1028 <KP_GetPressedValue+0xe0>
         {
            /* read row value */
            DIO_ReadPin(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_RowCounter), &u8_KeyState);
     fb6:	f8 01       	movw	r30, r16
     fb8:	ee 0f       	add	r30, r30
     fba:	ff 1f       	adc	r31, r31
     fbc:	e0 0f       	add	r30, r16
     fbe:	f1 1f       	adc	r31, r17
     fc0:	ee 0f       	add	r30, r30
     fc2:	ff 1f       	adc	r31, r31
     fc4:	e4 52       	subi	r30, 0x24	; 36
     fc6:	ff 4f       	sbci	r31, 0xFF	; 255
     fc8:	62 81       	ldd	r22, Z+2	; 0x02
     fca:	6f 0d       	add	r22, r15
     fcc:	ae 01       	movw	r20, r28
     fce:	4f 5f       	subi	r20, 0xFF	; 255
     fd0:	5f 4f       	sbci	r21, 0xFF	; 255
     fd2:	81 81       	ldd	r24, Z+1	; 0x01
     fd4:	0e 94 de 0a 	call	0x15bc	; 0x15bc <DIO_ReadPin>
            /* check if row is pressed */
            if(u8_KeyState == PRESSED)
     fd8:	89 81       	ldd	r24, Y+1	; 0x01
     fda:	81 11       	cpse	r24, r1
     fdc:	24 c0       	rjmp	.+72     	; 0x1026 <KP_GetPressedValue+0xde>
            {
               if(u32_NewState > 0)
     fde:	81 14       	cp	r8, r1
     fe0:	91 04       	cpc	r9, r1
     fe2:	a1 04       	cpc	r10, r1
     fe4:	b1 04       	cpc	r11, r1
     fe6:	11 f0       	breq	.+4      	; 0xfec <KP_GetPressedValue+0xa4>
               {
                  u32_NewState |= 1;
     fe8:	68 94       	set
     fea:	80 f8       	bld	r8, 0
               }
               switch(KP_CH)
     fec:	e1 10       	cpse	r14, r1
     fee:	1b c0       	rjmp	.+54     	; 0x1026 <KP_GetPressedValue+0xde>
               {
                  #ifdef KP_CH_0
                  case KP_CH_0:
                     u32_NewState |= (1<<KP_Ch0Map[u8_RowCounter][u8_ColCounter]);
     ff0:	8f 2d       	mov	r24, r15
     ff2:	90 e0       	ldi	r25, 0x00	; 0
     ff4:	fc 01       	movw	r30, r24
     ff6:	ee 0f       	add	r30, r30
     ff8:	ff 1f       	adc	r31, r31
     ffa:	e8 0f       	add	r30, r24
     ffc:	f9 1f       	adc	r31, r25
     ffe:	e0 53       	subi	r30, 0x30	; 48
    1000:	ff 4f       	sbci	r31, 0xFF	; 255
    1002:	e6 0d       	add	r30, r6
    1004:	f1 1d       	adc	r31, r1
    1006:	81 e0       	ldi	r24, 0x01	; 1
    1008:	90 e0       	ldi	r25, 0x00	; 0
    100a:	00 80       	ld	r0, Z
    100c:	02 c0       	rjmp	.+4      	; 0x1012 <KP_GetPressedValue+0xca>
    100e:	88 0f       	add	r24, r24
    1010:	99 1f       	adc	r25, r25
    1012:	0a 94       	dec	r0
    1014:	e2 f7       	brpl	.-8      	; 0x100e <KP_GetPressedValue+0xc6>
    1016:	09 2e       	mov	r0, r25
    1018:	00 0c       	add	r0, r0
    101a:	aa 0b       	sbc	r26, r26
    101c:	bb 0b       	sbc	r27, r27
    101e:	88 2a       	or	r8, r24
    1020:	99 2a       	or	r9, r25
    1022:	aa 2a       	or	r10, r26
    1024:	bb 2a       	or	r11, r27
         /* set column value to low */
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter) , PIN_OUTPUT);
         DIO_WritePin(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter), PIN_LOW);
         
         /* loops on every row */
         for(uint8_t u8_RowCounter = 0; u8_RowCounter < aSTR_KPConfig[KP_CH].u8_KPRows; u8_RowCounter++)
    1026:	f3 94       	inc	r15
    1028:	f8 01       	movw	r30, r16
    102a:	ee 0f       	add	r30, r30
    102c:	ff 1f       	adc	r31, r31
    102e:	e0 0f       	add	r30, r16
    1030:	f1 1f       	adc	r31, r17
    1032:	ee 0f       	add	r30, r30
    1034:	ff 1f       	adc	r31, r31
    1036:	e4 52       	subi	r30, 0x24	; 36
    1038:	ff 4f       	sbci	r31, 0xFF	; 255
    103a:	80 81       	ld	r24, Z
    103c:	f8 16       	cp	r15, r24
    103e:	08 f4       	brcc	.+2      	; 0x1042 <KP_GetPressedValue+0xfa>
    1040:	ba cf       	rjmp	.-140    	; 0xfb6 <KP_GetPressedValue+0x6e>
               }
            }
         }
         
         /* return column value to HIGH */
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter) , PIN_INPUT);
    1042:	40 e0       	ldi	r20, 0x00	; 0
    1044:	67 2d       	mov	r22, r7
    1046:	85 2d       	mov	r24, r5
    1048:	0e 94 0c 0a 	call	0x1418	; 0x1418 <DIO_SetPinDirection>
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter));
    104c:	67 2d       	mov	r22, r7
    104e:	85 2d       	mov	r24, r5
    1050:	0e 94 21 0b 	call	0x1642	; 0x1642 <DIO_EnablePinPullup>
      static uint32_t u32_OldState = 0x00;
      uint32_t u32_NewState = 0x00;
      uint8_t u8_KeyState;
      
      /* loops on every column */
      for(uint8_t u8_ColCounter = 0; u8_ColCounter < aSTR_KPConfig[KP_CH].u8_KPCols; u8_ColCounter++)
    1054:	63 94       	inc	r6
    1056:	0e 2d       	mov	r16, r14
    1058:	10 e0       	ldi	r17, 0x00	; 0
    105a:	f8 01       	movw	r30, r16
    105c:	ee 0f       	add	r30, r30
    105e:	ff 1f       	adc	r31, r31
    1060:	e0 0f       	add	r30, r16
    1062:	f1 1f       	adc	r31, r17
    1064:	ee 0f       	add	r30, r30
    1066:	ff 1f       	adc	r31, r31
    1068:	e4 52       	subi	r30, 0x24	; 36
    106a:	ff 4f       	sbci	r31, 0xFF	; 255
    106c:	83 81       	ldd	r24, Z+3	; 0x03
    106e:	68 16       	cp	r6, r24
    1070:	08 f4       	brcc	.+2      	; 0x1074 <KP_GetPressedValue+0x12c>
    1072:	89 cf       	rjmp	.-238    	; 0xf86 <KP_GetPressedValue+0x3e>
         /* return column value to HIGH */
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter) , PIN_INPUT);
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter));
      }
      
      if(u32_OldState == u32_NewState)
    1074:	80 91 4b 07 	lds	r24, 0x074B	; 0x80074b <u32_OldState.1655>
    1078:	90 91 4c 07 	lds	r25, 0x074C	; 0x80074c <u32_OldState.1655+0x1>
    107c:	a0 91 4d 07 	lds	r26, 0x074D	; 0x80074d <u32_OldState.1655+0x2>
    1080:	b0 91 4e 07 	lds	r27, 0x074E	; 0x80074e <u32_OldState.1655+0x3>
    1084:	88 16       	cp	r8, r24
    1086:	99 06       	cpc	r9, r25
    1088:	aa 06       	cpc	r10, r26
    108a:	bb 06       	cpc	r11, r27
    108c:	39 f4       	brne	.+14     	; 0x109c <KP_GetPressedValue+0x154>
      {
         *Data = u32_NewState;
    108e:	f6 01       	movw	r30, r12
    1090:	80 82       	st	Z, r8
    1092:	91 82       	std	Z+1, r9	; 0x01
    1094:	a2 82       	std	Z+2, r10	; 0x02
    1096:	b3 82       	std	Z+3, r11	; 0x03
         KP_ErrorState = ERROR_OK;
    1098:	80 e0       	ldi	r24, 0x00	; 0
    109a:	01 c0       	rjmp	.+2      	; 0x109e <KP_GetPressedValue+0x156>
      }
      else
      {
         KP_ErrorState = ERROR_NOK;
    109c:	81 e0       	ldi	r24, 0x01	; 1
      }
      u32_OldState = u32_NewState;
    109e:	80 92 4b 07 	sts	0x074B, r8	; 0x80074b <u32_OldState.1655>
    10a2:	90 92 4c 07 	sts	0x074C, r9	; 0x80074c <u32_OldState.1655+0x1>
    10a6:	a0 92 4d 07 	sts	0x074D, r10	; 0x80074d <u32_OldState.1655+0x2>
    10aa:	b0 92 4e 07 	sts	0x074E, r11	; 0x80074e <u32_OldState.1655+0x3>
    10ae:	03 c0       	rjmp	.+6      	; 0x10b6 <KP_GetPressedValue+0x16e>
   ERROR_STATE_t KP_ErrorState;
      
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Data)
   {
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_NULL_PTR);
    10b0:	81 ee       	ldi	r24, 0xE1	; 225
    10b2:	01 c0       	rjmp	.+2      	; 0x10b6 <KP_GetPressedValue+0x16e>
   }
   else if(KP_INVALID_CH <= KP_CH)
   {
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_INVALID_CH);
    10b4:	82 ee       	ldi	r24, 0xE2	; 226
      
   }
   
   /* return Error state. */
   return KP_ErrorState;
    10b6:	0f 90       	pop	r0
    10b8:	df 91       	pop	r29
    10ba:	cf 91       	pop	r28
    10bc:	1f 91       	pop	r17
    10be:	0f 91       	pop	r16
    10c0:	ff 90       	pop	r15
    10c2:	ef 90       	pop	r14
    10c4:	df 90       	pop	r13
    10c6:	cf 90       	pop	r12
    10c8:	bf 90       	pop	r11
    10ca:	af 90       	pop	r10
    10cc:	9f 90       	pop	r9
    10ce:	8f 90       	pop	r8
    10d0:	7f 90       	pop	r7
    10d2:	6f 90       	pop	r6
    10d4:	5f 90       	pop	r5
    10d6:	08 95       	ret

000010d8 <LED_Init>:
* @param [in]  LED_ch   -  LED channel number.
*
* @return function error state.
*/
extern ERROR_STATE_t LED_Init(uint8_t LED_ch)
{
    10d8:	ef 92       	push	r14
    10da:	ff 92       	push	r15
    10dc:	0f 93       	push	r16
    10de:	1f 93       	push	r17
    10e0:	cf 93       	push	r28
    10e2:	df 93       	push	r29
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    10e4:	81 11       	cpse	r24, r1
    10e6:	4e c0       	rjmp	.+156    	; 0x1184 <LED_Init+0xac>
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function was called before */
   else if(INIT == gu8_IsLEDInit[LED_ch])
    10e8:	c8 2f       	mov	r28, r24
    10ea:	d0 e0       	ldi	r29, 0x00	; 0
    10ec:	fe 01       	movw	r30, r28
    10ee:	e1 5b       	subi	r30, 0xB1	; 177
    10f0:	f8 4f       	sbci	r31, 0xF8	; 248
    10f2:	80 81       	ld	r24, Z
    10f4:	81 30       	cpi	r24, 0x01	; 1
    10f6:	09 f4       	brne	.+2      	; 0x10fa <LED_Init+0x22>
    10f8:	47 c0       	rjmp	.+142    	; 0x1188 <LED_Init+0xb0>
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INIT_BEFORE);
   }
   else
   {
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    10fa:	fe 01       	movw	r30, r28
    10fc:	ee 0f       	add	r30, r30
    10fe:	ff 1f       	adc	r31, r31
    1100:	ee 0f       	add	r30, r30
    1102:	ff 1f       	adc	r31, r31
    1104:	ee 51       	subi	r30, 0x1E	; 30
    1106:	ff 4f       	sbci	r31, 0xFF	; 255
    1108:	82 81       	ldd	r24, Z+2	; 0x02
    110a:	81 11       	cpse	r24, r1
    110c:	14 c0       	rjmp	.+40     	; 0x1136 <LED_Init+0x5e>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* configure LED pin */
         DIO_ErrorState = DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
    110e:	fe 01       	movw	r30, r28
    1110:	ee 0f       	add	r30, r30
    1112:	ff 1f       	adc	r31, r31
    1114:	ee 0f       	add	r30, r30
    1116:	ff 1f       	adc	r31, r31
    1118:	ee 51       	subi	r30, 0x1E	; 30
    111a:	ff 4f       	sbci	r31, 0xFF	; 255
    111c:	61 81       	ldd	r22, Z+1	; 0x01
    111e:	41 e0       	ldi	r20, 0x01	; 1
    1120:	80 81       	ld	r24, Z
    1122:	0e 94 0c 0a 	call	0x1418	; 0x1418 <DIO_SetPinDirection>
         /* make sure pin configuration is successful */
         if(ERROR_OK != DIO_ErrorState)
    1126:	81 11       	cpse	r24, r1
    1128:	31 c0       	rjmp	.+98     	; 0x118c <LED_Init+0xb4>
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            gu8_IsLEDInit[LED_ch] = INIT;
    112a:	c1 5b       	subi	r28, 0xB1	; 177
    112c:	d8 4f       	sbci	r29, 0xF8	; 248
    112e:	81 e0       	ldi	r24, 0x01	; 1
    1130:	88 83       	st	Y, r24
            LED_ErrorState = ERROR_OK;
    1132:	80 e0       	ldi	r24, 0x00	; 0
    1134:	30 c0       	rjmp	.+96     	; 0x1196 <LED_Init+0xbe>
         }
      }
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
    1136:	81 30       	cpi	r24, 0x01	; 1
    1138:	59 f5       	brne	.+86     	; 0x1190 <LED_Init+0xb8>
      {
         ERROR_STATE_t ErrorState;
         
         ErrorState = PWM_Init(gSTR_LEDConfig[LED_ch].u8_PWMCh);
    113a:	ce 01       	movw	r24, r28
    113c:	88 0f       	add	r24, r24
    113e:	99 1f       	adc	r25, r25
    1140:	88 0f       	add	r24, r24
    1142:	99 1f       	adc	r25, r25
    1144:	9c 01       	movw	r18, r24
    1146:	2e 51       	subi	r18, 0x1E	; 30
    1148:	3f 4f       	sbci	r19, 0xFF	; 255
    114a:	79 01       	movw	r14, r18
    114c:	f9 01       	movw	r30, r18
    114e:	03 81       	ldd	r16, Z+3	; 0x03
    1150:	80 2f       	mov	r24, r16
    1152:	0e 94 5f 0b 	call	0x16be	; 0x16be <PWM_Init>
    1156:	18 2f       	mov	r17, r24
         ErrorState |= DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
    1158:	41 e0       	ldi	r20, 0x01	; 1
    115a:	f7 01       	movw	r30, r14
    115c:	61 81       	ldd	r22, Z+1	; 0x01
    115e:	80 81       	ld	r24, Z
    1160:	0e 94 0c 0a 	call	0x1418	; 0x1418 <DIO_SetPinDirection>
    1164:	18 2b       	or	r17, r24
         /*START THE PWM WAVE*/
         ErrorState |= PWM_Start(gSTR_LEDConfig[LED_ch].u8_PWMCh);
    1166:	80 2f       	mov	r24, r16
    1168:	0e 94 90 0b 	call	0x1720	; 0x1720 <PWM_Start>
    116c:	18 2b       	or	r17, r24
         ErrorState |= PWM_Connect(gSTR_LEDConfig[LED_ch].u8_PWMCh);
    116e:	80 2f       	mov	r24, r16
    1170:	0e 94 9c 0b 	call	0x1738	; 0x1738 <PWM_Connect>
    1174:	81 2b       	or	r24, r17
         if(ERROR_OK != ErrorState)
    1176:	71 f4       	brne	.+28     	; 0x1194 <LED_Init+0xbc>
         {
            LED_ErrorState = ERROR_NOK;
         }  
         else
         {
            gu8_IsLEDInit[LED_ch] = INIT;
    1178:	c1 5b       	subi	r28, 0xB1	; 177
    117a:	d8 4f       	sbci	r29, 0xF8	; 248
    117c:	81 e0       	ldi	r24, 0x01	; 1
    117e:	88 83       	st	Y, r24
            LED_ErrorState = ERROR_OK;
    1180:	80 e0       	ldi	r24, 0x00	; 0
    1182:	09 c0       	rjmp	.+18     	; 0x1196 <LED_Init+0xbe>
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    1184:	81 ec       	ldi	r24, 0xC1	; 193
    1186:	07 c0       	rjmp	.+14     	; 0x1196 <LED_Init+0xbe>
   }
   /* check if init function was called before */
   else if(INIT == gu8_IsLEDInit[LED_ch])
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INIT_BEFORE);
    1188:	82 ec       	ldi	r24, 0xC2	; 194
    118a:	05 c0       	rjmp	.+10     	; 0x1196 <LED_Init+0xbe>
         /* configure LED pin */
         DIO_ErrorState = DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
         /* make sure pin configuration is successful */
         if(ERROR_OK != DIO_ErrorState)
         {
            LED_ErrorState = ERROR_NOK;
    118c:	81 e0       	ldi	r24, 0x01	; 1
    118e:	03 c0       	rjmp	.+6      	; 0x1196 <LED_Init+0xbe>
            LED_ErrorState = ERROR_OK;
         }          
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
    1190:	81 e0       	ldi	r24, 0x01	; 1
    1192:	01 c0       	rjmp	.+2      	; 0x1196 <LED_Init+0xbe>
         /*START THE PWM WAVE*/
         ErrorState |= PWM_Start(gSTR_LEDConfig[LED_ch].u8_PWMCh);
         ErrorState |= PWM_Connect(gSTR_LEDConfig[LED_ch].u8_PWMCh);
         if(ERROR_OK != ErrorState)
         {
            LED_ErrorState = ERROR_NOK;
    1194:	81 e0       	ldi	r24, 0x01	; 1
         LED_ErrorState = ERROR_NOK;
      }   
   }
   
   return LED_ErrorState;
}
    1196:	df 91       	pop	r29
    1198:	cf 91       	pop	r28
    119a:	1f 91       	pop	r17
    119c:	0f 91       	pop	r16
    119e:	ff 90       	pop	r15
    11a0:	ef 90       	pop	r14
    11a2:	08 95       	ret

000011a4 <LED_Off>:
extern ERROR_STATE_t LED_Off(uint8_t LED_ch)
{
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    11a4:	81 11       	cpse	r24, r1
    11a6:	32 c0       	rjmp	.+100    	; 0x120c <LED_Off+0x68>
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
    11a8:	90 e0       	ldi	r25, 0x00	; 0
    11aa:	fc 01       	movw	r30, r24
    11ac:	e1 5b       	subi	r30, 0xB1	; 177
    11ae:	f8 4f       	sbci	r31, 0xF8	; 248
    11b0:	20 81       	ld	r18, Z
    11b2:	21 30       	cpi	r18, 0x01	; 1
    11b4:	69 f5       	brne	.+90     	; 0x1210 <LED_Off+0x6c>
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   else
   {
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    11b6:	fc 01       	movw	r30, r24
    11b8:	ee 0f       	add	r30, r30
    11ba:	ff 1f       	adc	r31, r31
    11bc:	ee 0f       	add	r30, r30
    11be:	ff 1f       	adc	r31, r31
    11c0:	ee 51       	subi	r30, 0x1E	; 30
    11c2:	ff 4f       	sbci	r31, 0xFF	; 255
    11c4:	22 81       	ldd	r18, Z+2	; 0x02
    11c6:	21 11       	cpse	r18, r1
    11c8:	10 c0       	rjmp	.+32     	; 0x11ea <LED_Off+0x46>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* set LED pin to low */
         DIO_ErrorState = DIO_WritePin(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_LOW);
    11ca:	88 0f       	add	r24, r24
    11cc:	99 1f       	adc	r25, r25
    11ce:	88 0f       	add	r24, r24
    11d0:	99 1f       	adc	r25, r25
    11d2:	fc 01       	movw	r30, r24
    11d4:	ee 51       	subi	r30, 0x1E	; 30
    11d6:	ff 4f       	sbci	r31, 0xFF	; 255
    11d8:	61 81       	ldd	r22, Z+1	; 0x01
    11da:	40 e0       	ldi	r20, 0x00	; 0
    11dc:	80 81       	ld	r24, Z
    11de:	0e 94 75 0a 	call	0x14ea	; 0x14ea <DIO_WritePin>
         
         /* make sure DIO function was successful */
         if(ERROR_OK != DIO_ErrorState)
    11e2:	88 23       	and	r24, r24
    11e4:	b9 f0       	breq	.+46     	; 0x1214 <LED_Off+0x70>
         {
            LED_ErrorState = ERROR_NOK;
    11e6:	81 e0       	ldi	r24, 0x01	; 1
    11e8:	08 95       	ret
         else
         {
            LED_ErrorState = ERROR_OK;
         }
      }
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
    11ea:	21 30       	cpi	r18, 0x01	; 1
    11ec:	a9 f4       	brne	.+42     	; 0x1218 <LED_Off+0x74>
      {
         ERROR_STATE_t PWM_ErrorState;
         
         PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, 0);
    11ee:	88 0f       	add	r24, r24
    11f0:	99 1f       	adc	r25, r25
    11f2:	88 0f       	add	r24, r24
    11f4:	99 1f       	adc	r25, r25
    11f6:	fc 01       	movw	r30, r24
    11f8:	ee 51       	subi	r30, 0x1E	; 30
    11fa:	ff 4f       	sbci	r31, 0xFF	; 255
    11fc:	60 e0       	ldi	r22, 0x00	; 0
    11fe:	83 81       	ldd	r24, Z+3	; 0x03
    1200:	0e 94 ad 0b 	call	0x175a	; 0x175a <PWM_SetDuty>
         
         if(ERROR_OK != PWM_ErrorState)
    1204:	88 23       	and	r24, r24
    1206:	51 f0       	breq	.+20     	; 0x121c <LED_Off+0x78>
         {
            LED_ErrorState = ERROR_NOK;
    1208:	81 e0       	ldi	r24, 0x01	; 1
    120a:	08 95       	ret
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    120c:	81 ec       	ldi	r24, 0xC1	; 193
    120e:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
    1210:	83 ec       	ldi	r24, 0xC3	; 195
    1212:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    1214:	80 e0       	ldi	r24, 0x00	; 0
    1216:	08 95       	ret
            LED_ErrorState = ERROR_OK;
         }
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
    1218:	81 e0       	ldi	r24, 0x01	; 1
    121a:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    121c:	80 e0       	ldi	r24, 0x00	; 0
         LED_ErrorState = ERROR_NOK;
      }
   }
   
   return LED_ErrorState;
}
    121e:	08 95       	ret

00001220 <LED_On>:
extern ERROR_STATE_t LED_On(uint8_t LED_ch)
{
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    1220:	81 11       	cpse	r24, r1
    1222:	32 c0       	rjmp	.+100    	; 0x1288 <LED_On+0x68>
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
    1224:	90 e0       	ldi	r25, 0x00	; 0
    1226:	fc 01       	movw	r30, r24
    1228:	e1 5b       	subi	r30, 0xB1	; 177
    122a:	f8 4f       	sbci	r31, 0xF8	; 248
    122c:	20 81       	ld	r18, Z
    122e:	21 30       	cpi	r18, 0x01	; 1
    1230:	69 f5       	brne	.+90     	; 0x128c <LED_On+0x6c>
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   else
   {
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    1232:	fc 01       	movw	r30, r24
    1234:	ee 0f       	add	r30, r30
    1236:	ff 1f       	adc	r31, r31
    1238:	ee 0f       	add	r30, r30
    123a:	ff 1f       	adc	r31, r31
    123c:	ee 51       	subi	r30, 0x1E	; 30
    123e:	ff 4f       	sbci	r31, 0xFF	; 255
    1240:	22 81       	ldd	r18, Z+2	; 0x02
    1242:	21 11       	cpse	r18, r1
    1244:	10 c0       	rjmp	.+32     	; 0x1266 <LED_On+0x46>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* set LED pin to low */
         DIO_ErrorState = DIO_WritePin(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_HIGH);
    1246:	88 0f       	add	r24, r24
    1248:	99 1f       	adc	r25, r25
    124a:	88 0f       	add	r24, r24
    124c:	99 1f       	adc	r25, r25
    124e:	fc 01       	movw	r30, r24
    1250:	ee 51       	subi	r30, 0x1E	; 30
    1252:	ff 4f       	sbci	r31, 0xFF	; 255
    1254:	61 81       	ldd	r22, Z+1	; 0x01
    1256:	41 e0       	ldi	r20, 0x01	; 1
    1258:	80 81       	ld	r24, Z
    125a:	0e 94 75 0a 	call	0x14ea	; 0x14ea <DIO_WritePin>
         
         /* make sure DIO function was successful */
         if(ERROR_OK != DIO_ErrorState)
    125e:	88 23       	and	r24, r24
    1260:	b9 f0       	breq	.+46     	; 0x1290 <LED_On+0x70>
         {
            LED_ErrorState = ERROR_NOK;
    1262:	81 e0       	ldi	r24, 0x01	; 1
    1264:	08 95       	ret
         else
         {
            LED_ErrorState = ERROR_OK;
         }
      }
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
    1266:	21 30       	cpi	r18, 0x01	; 1
    1268:	a9 f4       	brne	.+42     	; 0x1294 <LED_On+0x74>
      {
         ERROR_STATE_t PWM_ErrorState;
         
         PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, 100);
    126a:	88 0f       	add	r24, r24
    126c:	99 1f       	adc	r25, r25
    126e:	88 0f       	add	r24, r24
    1270:	99 1f       	adc	r25, r25
    1272:	fc 01       	movw	r30, r24
    1274:	ee 51       	subi	r30, 0x1E	; 30
    1276:	ff 4f       	sbci	r31, 0xFF	; 255
    1278:	64 e6       	ldi	r22, 0x64	; 100
    127a:	83 81       	ldd	r24, Z+3	; 0x03
    127c:	0e 94 ad 0b 	call	0x175a	; 0x175a <PWM_SetDuty>
         
         if(ERROR_OK != PWM_ErrorState)
    1280:	88 23       	and	r24, r24
    1282:	51 f0       	breq	.+20     	; 0x1298 <LED_On+0x78>
         {
            LED_ErrorState = ERROR_NOK;
    1284:	81 e0       	ldi	r24, 0x01	; 1
    1286:	08 95       	ret
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    1288:	81 ec       	ldi	r24, 0xC1	; 193
    128a:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
    128c:	83 ec       	ldi	r24, 0xC3	; 195
    128e:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    1290:	80 e0       	ldi	r24, 0x00	; 0
    1292:	08 95       	ret
            LED_ErrorState = ERROR_OK;
         }
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
    1294:	81 e0       	ldi	r24, 0x01	; 1
    1296:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    1298:	80 e0       	ldi	r24, 0x00	; 0
         LED_ErrorState = ERROR_NOK;
      }
   }
   
   return LED_ErrorState;
}
    129a:	08 95       	ret

0000129c <LED_Dim>:
extern ERROR_STATE_t LED_Dim(uint8_t LED_ch, uint8_t Duty)
{
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    129c:	81 11       	cpse	r24, r1
    129e:	21 c0       	rjmp	.+66     	; 0x12e2 <LED_Dim+0x46>
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
    12a0:	90 e0       	ldi	r25, 0x00	; 0
    12a2:	fc 01       	movw	r30, r24
    12a4:	e1 5b       	subi	r30, 0xB1	; 177
    12a6:	f8 4f       	sbci	r31, 0xF8	; 248
    12a8:	20 81       	ld	r18, Z
    12aa:	21 30       	cpi	r18, 0x01	; 1
    12ac:	e1 f4       	brne	.+56     	; 0x12e6 <LED_Dim+0x4a>
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   else if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    12ae:	fc 01       	movw	r30, r24
    12b0:	ee 0f       	add	r30, r30
    12b2:	ff 1f       	adc	r31, r31
    12b4:	ee 0f       	add	r30, r30
    12b6:	ff 1f       	adc	r31, r31
    12b8:	ee 51       	subi	r30, 0x1E	; 30
    12ba:	ff 4f       	sbci	r31, 0xFF	; 255
    12bc:	22 81       	ldd	r18, Z+2	; 0x02
    12be:	22 23       	and	r18, r18
    12c0:	a1 f0       	breq	.+40     	; 0x12ea <LED_Dim+0x4e>
   {
      LED_ErrorState = ERROR_NOK;
   }
   else if(100 < Duty)
    12c2:	65 36       	cpi	r22, 0x65	; 101
    12c4:	a0 f4       	brcc	.+40     	; 0x12ee <LED_Dim+0x52>
   }     
   else
   {
      ERROR_STATE_t PWM_ErrorState;
         
      PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, Duty);
    12c6:	88 0f       	add	r24, r24
    12c8:	99 1f       	adc	r25, r25
    12ca:	88 0f       	add	r24, r24
    12cc:	99 1f       	adc	r25, r25
    12ce:	fc 01       	movw	r30, r24
    12d0:	ee 51       	subi	r30, 0x1E	; 30
    12d2:	ff 4f       	sbci	r31, 0xFF	; 255
    12d4:	83 81       	ldd	r24, Z+3	; 0x03
    12d6:	0e 94 ad 0b 	call	0x175a	; 0x175a <PWM_SetDuty>
         
      if(ERROR_OK != PWM_ErrorState)
    12da:	88 23       	and	r24, r24
    12dc:	51 f0       	breq	.+20     	; 0x12f2 <LED_Dim+0x56>
      {
         LED_ErrorState = ERROR_NOK;
    12de:	81 e0       	ldi	r24, 0x01	; 1
    12e0:	08 95       	ret
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    12e2:	81 ec       	ldi	r24, 0xC1	; 193
    12e4:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
    12e6:	83 ec       	ldi	r24, 0xC3	; 195
    12e8:	08 95       	ret
   }
   else if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
   {
      LED_ErrorState = ERROR_NOK;
    12ea:	81 e0       	ldi	r24, 0x01	; 1
    12ec:	08 95       	ret
   }
   else if(100 < Duty)
   {
      LED_ErrorState = ERROR_NOK;
    12ee:	81 e0       	ldi	r24, 0x01	; 1
    12f0:	08 95       	ret
      {
         LED_ErrorState = ERROR_NOK;
      }
      else
      {
         LED_ErrorState = ERROR_OK;
    12f2:	80 e0       	ldi	r24, 0x00	; 0
      }
   }
   
   return LED_ErrorState;
}
    12f4:	08 95       	ret

000012f6 <SevenSeg_ClearEnable>:
------------------------*/
/**
* @brief: This function Clear all Segments Enable Bits.
*/
static void SevenSeg_ClearEnable(void)
{
    12f6:	cf 93       	push	r28
   for(uint8_t u8_ChannelCounter = 0; u8_ChannelCounter < SEVEN_SEG_NUMBERS; u8_ChannelCounter++)
    12f8:	c0 e0       	ldi	r28, 0x00	; 0
    12fa:	0e c0       	rjmp	.+28     	; 0x1318 <SevenSeg_ClearEnable+0x22>
   {
      DIO_WritePin(aSTR_SevenSegConfig[u8_ChannelCounter].u8_EnPort, aSTR_SevenSegConfig[u8_ChannelCounter].u8_EnPin, PIN_LOW);
    12fc:	ec 2f       	mov	r30, r28
    12fe:	f0 e0       	ldi	r31, 0x00	; 0
    1300:	ee 0f       	add	r30, r30
    1302:	ff 1f       	adc	r31, r31
    1304:	ee 0f       	add	r30, r30
    1306:	ff 1f       	adc	r31, r31
    1308:	ea 51       	subi	r30, 0x1A	; 26
    130a:	ff 4f       	sbci	r31, 0xFF	; 255
    130c:	40 e0       	ldi	r20, 0x00	; 0
    130e:	61 81       	ldd	r22, Z+1	; 0x01
    1310:	80 81       	ld	r24, Z
    1312:	0e 94 75 0a 	call	0x14ea	; 0x14ea <DIO_WritePin>
/**
* @brief: This function Clear all Segments Enable Bits.
*/
static void SevenSeg_ClearEnable(void)
{
   for(uint8_t u8_ChannelCounter = 0; u8_ChannelCounter < SEVEN_SEG_NUMBERS; u8_ChannelCounter++)
    1316:	cf 5f       	subi	r28, 0xFF	; 255
    1318:	c2 30       	cpi	r28, 0x02	; 2
    131a:	80 f3       	brcs	.-32     	; 0x12fc <SevenSeg_ClearEnable+0x6>
   {
      DIO_WritePin(aSTR_SevenSegConfig[u8_ChannelCounter].u8_EnPort, aSTR_SevenSegConfig[u8_ChannelCounter].u8_EnPin, PIN_LOW);
   }
}
    131c:	cf 91       	pop	r28
    131e:	08 95       	ret

00001320 <SevenSeg_Init>:
* @param [in]  Channel   -  Channel number.
*
* @return function error state.
*/
extern ERROR_STATE_t SevenSeg_Init(const uint8_t Channel)
{
    1320:	1f 93       	push	r17
    1322:	cf 93       	push	r28
    1324:	df 93       	push	r29
   ERROR_STATE_t SevenSeg_ErrorState;
   
   if(SEVEN_SEG_INVALID_CH <= Channel)
    1326:	82 30       	cpi	r24, 0x02	; 2
    1328:	60 f5       	brcc	.+88     	; 0x1382 <SevenSeg_Init+0x62>
   {
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_CH);
   }
   else if(INIT == gu8_IsInit[Channel])
    132a:	c8 2f       	mov	r28, r24
    132c:	d0 e0       	ldi	r29, 0x00	; 0
    132e:	fe 01       	movw	r30, r28
    1330:	e0 5b       	subi	r30, 0xB0	; 176
    1332:	f8 4f       	sbci	r31, 0xF8	; 248
    1334:	80 81       	ld	r24, Z
    1336:	81 30       	cpi	r24, 0x01	; 1
    1338:	31 f1       	breq	.+76     	; 0x1386 <SevenSeg_Init+0x66>
   {
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INIT_BEFORE);
   }
   else
   {
      DIO_SetPinDirection(aSTR_SevenSegConfig[Channel].u8_EnPort, aSTR_SevenSegConfig[Channel].u8_EnPin, PIN_OUTPUT);
    133a:	fe 01       	movw	r30, r28
    133c:	ee 0f       	add	r30, r30
    133e:	ff 1f       	adc	r31, r31
    1340:	ee 0f       	add	r30, r30
    1342:	ff 1f       	adc	r31, r31
    1344:	ea 51       	subi	r30, 0x1A	; 26
    1346:	ff 4f       	sbci	r31, 0xFF	; 255
    1348:	41 e0       	ldi	r20, 0x01	; 1
    134a:	61 81       	ldd	r22, Z+1	; 0x01
    134c:	80 81       	ld	r24, Z
    134e:	0e 94 0c 0a 	call	0x1418	; 0x1418 <DIO_SetPinDirection>
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
    1352:	10 e0       	ldi	r17, 0x00	; 0
    1354:	0e c0       	rjmp	.+28     	; 0x1372 <SevenSeg_Init+0x52>
      {
         DIO_SetPinDirection(
            aSTR_SevenSegConfig[Channel].u8_DataPort, 
            (aSTR_SevenSegConfig[Channel].u8_DataPinStart + u8_DataPinsCounter), 
    1356:	fe 01       	movw	r30, r28
    1358:	ee 0f       	add	r30, r30
    135a:	ff 1f       	adc	r31, r31
    135c:	ee 0f       	add	r30, r30
    135e:	ff 1f       	adc	r31, r31
    1360:	ea 51       	subi	r30, 0x1A	; 26
    1362:	ff 4f       	sbci	r31, 0xFF	; 255
    1364:	63 81       	ldd	r22, Z+3	; 0x03
   else
   {
      DIO_SetPinDirection(aSTR_SevenSegConfig[Channel].u8_EnPort, aSTR_SevenSegConfig[Channel].u8_EnPin, PIN_OUTPUT);
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
      {
         DIO_SetPinDirection(
    1366:	61 0f       	add	r22, r17
    1368:	41 e0       	ldi	r20, 0x01	; 1
    136a:	82 81       	ldd	r24, Z+2	; 0x02
    136c:	0e 94 0c 0a 	call	0x1418	; 0x1418 <DIO_SetPinDirection>
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INIT_BEFORE);
   }
   else
   {
      DIO_SetPinDirection(aSTR_SevenSegConfig[Channel].u8_EnPort, aSTR_SevenSegConfig[Channel].u8_EnPin, PIN_OUTPUT);
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
    1370:	1f 5f       	subi	r17, 0xFF	; 255
    1372:	14 30       	cpi	r17, 0x04	; 4
    1374:	80 f3       	brcs	.-32     	; 0x1356 <SevenSeg_Init+0x36>
            aSTR_SevenSegConfig[Channel].u8_DataPort, 
            (aSTR_SevenSegConfig[Channel].u8_DataPinStart + u8_DataPinsCounter), 
            PIN_OUTPUT
         );
      }        
      gu8_IsInit[Channel] = INIT;
    1376:	c0 5b       	subi	r28, 0xB0	; 176
    1378:	d8 4f       	sbci	r29, 0xF8	; 248
    137a:	81 e0       	ldi	r24, 0x01	; 1
    137c:	88 83       	st	Y, r24
      SevenSeg_ErrorState = ERROR_OK;
    137e:	80 e0       	ldi	r24, 0x00	; 0
    1380:	03 c0       	rjmp	.+6      	; 0x1388 <SevenSeg_Init+0x68>
{
   ERROR_STATE_t SevenSeg_ErrorState;
   
   if(SEVEN_SEG_INVALID_CH <= Channel)
   {
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_CH);
    1382:	81 ea       	ldi	r24, 0xA1	; 161
    1384:	01 c0       	rjmp	.+2      	; 0x1388 <SevenSeg_Init+0x68>
   }
   else if(INIT == gu8_IsInit[Channel])
   {
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INIT_BEFORE);
    1386:	83 ea       	ldi	r24, 0xA3	; 163
      SevenSeg_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return SevenSeg_ErrorState;
}
    1388:	df 91       	pop	r29
    138a:	cf 91       	pop	r28
    138c:	1f 91       	pop	r17
    138e:	08 95       	ret

00001390 <SevenSeg_Display>:
* @param [out] Data     -  Pressed Key Value.
*
* @return function error state.
*/
ERROR_STATE_t SevenSeg_Display(const uint8_t Channel, const uint8_t Number)
{
    1390:	0f 93       	push	r16
    1392:	1f 93       	push	r17
    1394:	cf 93       	push	r28
    1396:	df 93       	push	r29
   ERROR_STATE_t SevenSeg_ErrorState;
   
   if(SEVEN_SEG_INVALID_CH <= Channel)
    1398:	82 30       	cpi	r24, 0x02	; 2
    139a:	a0 f5       	brcc	.+104    	; 0x1404 <SevenSeg_Display+0x74>
   {
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_CH);
   }
   else if(INIT != gu8_IsInit[Channel])
    139c:	c8 2f       	mov	r28, r24
    139e:	d0 e0       	ldi	r29, 0x00	; 0
    13a0:	fe 01       	movw	r30, r28
    13a2:	e0 5b       	subi	r30, 0xB0	; 176
    13a4:	f8 4f       	sbci	r31, 0xF8	; 248
    13a6:	80 81       	ld	r24, Z
    13a8:	81 30       	cpi	r24, 0x01	; 1
    13aa:	71 f5       	brne	.+92     	; 0x1408 <SevenSeg_Display+0x78>
   {
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_NOT_INIT);
   }
   else if(MAX_DISPLAY_NUMBER < Number)
    13ac:	6a 30       	cpi	r22, 0x0A	; 10
    13ae:	70 f5       	brcc	.+92     	; 0x140c <SevenSeg_Display+0x7c>
    13b0:	16 2f       	mov	r17, r22
   {
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_NUMBER);
   }
   else
   {
      SevenSeg_ClearEnable();
    13b2:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <SevenSeg_ClearEnable>
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
    13b6:	00 e0       	ldi	r16, 0x00	; 0
    13b8:	16 c0       	rjmp	.+44     	; 0x13e6 <SevenSeg_Display+0x56>
      {
         DIO_WritePin(
         aSTR_SevenSegConfig[Channel].u8_DataPort,
         (aSTR_SevenSegConfig[Channel].u8_DataPinStart + u8_DataPinsCounter),
         ((Number >> u8_DataPinsCounter) & (1))
    13ba:	41 2f       	mov	r20, r17
    13bc:	50 e0       	ldi	r21, 0x00	; 0
    13be:	00 2e       	mov	r0, r16
    13c0:	02 c0       	rjmp	.+4      	; 0x13c6 <SevenSeg_Display+0x36>
    13c2:	55 95       	asr	r21
    13c4:	47 95       	ror	r20
    13c6:	0a 94       	dec	r0
    13c8:	e2 f7       	brpl	.-8      	; 0x13c2 <SevenSeg_Display+0x32>
      SevenSeg_ClearEnable();
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
      {
         DIO_WritePin(
         aSTR_SevenSegConfig[Channel].u8_DataPort,
         (aSTR_SevenSegConfig[Channel].u8_DataPinStart + u8_DataPinsCounter),
    13ca:	fe 01       	movw	r30, r28
    13cc:	ee 0f       	add	r30, r30
    13ce:	ff 1f       	adc	r31, r31
    13d0:	ee 0f       	add	r30, r30
    13d2:	ff 1f       	adc	r31, r31
    13d4:	ea 51       	subi	r30, 0x1A	; 26
    13d6:	ff 4f       	sbci	r31, 0xFF	; 255
    13d8:	63 81       	ldd	r22, Z+3	; 0x03
   else
   {
      SevenSeg_ClearEnable();
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
      {
         DIO_WritePin(
    13da:	41 70       	andi	r20, 0x01	; 1
    13dc:	60 0f       	add	r22, r16
    13de:	82 81       	ldd	r24, Z+2	; 0x02
    13e0:	0e 94 75 0a 	call	0x14ea	; 0x14ea <DIO_WritePin>
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_NUMBER);
   }
   else
   {
      SevenSeg_ClearEnable();
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
    13e4:	0f 5f       	subi	r16, 0xFF	; 255
    13e6:	04 30       	cpi	r16, 0x04	; 4
    13e8:	40 f3       	brcs	.-48     	; 0x13ba <SevenSeg_Display+0x2a>
         aSTR_SevenSegConfig[Channel].u8_DataPort,
         (aSTR_SevenSegConfig[Channel].u8_DataPinStart + u8_DataPinsCounter),
         ((Number >> u8_DataPinsCounter) & (1))
         );
      }
      DIO_WritePin(aSTR_SevenSegConfig[Channel].u8_EnPort, aSTR_SevenSegConfig[Channel].u8_EnPin, PIN_HIGH);
    13ea:	cc 0f       	add	r28, r28
    13ec:	dd 1f       	adc	r29, r29
    13ee:	cc 0f       	add	r28, r28
    13f0:	dd 1f       	adc	r29, r29
    13f2:	ca 51       	subi	r28, 0x1A	; 26
    13f4:	df 4f       	sbci	r29, 0xFF	; 255
    13f6:	41 e0       	ldi	r20, 0x01	; 1
    13f8:	69 81       	ldd	r22, Y+1	; 0x01
    13fa:	88 81       	ld	r24, Y
    13fc:	0e 94 75 0a 	call	0x14ea	; 0x14ea <DIO_WritePin>
      SevenSeg_ErrorState = ERROR_OK;
    1400:	80 e0       	ldi	r24, 0x00	; 0
    1402:	05 c0       	rjmp	.+10     	; 0x140e <SevenSeg_Display+0x7e>
{
   ERROR_STATE_t SevenSeg_ErrorState;
   
   if(SEVEN_SEG_INVALID_CH <= Channel)
   {
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_CH);
    1404:	81 ea       	ldi	r24, 0xA1	; 161
    1406:	03 c0       	rjmp	.+6      	; 0x140e <SevenSeg_Display+0x7e>
   }
   else if(INIT != gu8_IsInit[Channel])
   {
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_NOT_INIT);
    1408:	82 ea       	ldi	r24, 0xA2	; 162
    140a:	01 c0       	rjmp	.+2      	; 0x140e <SevenSeg_Display+0x7e>
   }
   else if(MAX_DISPLAY_NUMBER < Number)
   {
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_NUMBER);
    140c:	83 ea       	ldi	r24, 0xA3	; 163
      SevenSeg_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return SevenSeg_ErrorState;
    140e:	df 91       	pop	r29
    1410:	cf 91       	pop	r28
    1412:	1f 91       	pop	r17
    1414:	0f 91       	pop	r16
    1416:	08 95       	ret

00001418 <DIO_SetPinDirection>:
				u8_ErrorState=ERROR_NOK;
				break;	
		}	
	}	
	return u8_ErrorState;
}
    1418:	42 30       	cpi	r20, 0x02	; 2
    141a:	08 f0       	brcs	.+2      	; 0x141e <DIO_SetPinDirection+0x6>
    141c:	60 c0       	rjmp	.+192    	; 0x14de <DIO_SetPinDirection+0xc6>
    141e:	68 30       	cpi	r22, 0x08	; 8
    1420:	08 f0       	brcs	.+2      	; 0x1424 <DIO_SetPinDirection+0xc>
    1422:	5f c0       	rjmp	.+190    	; 0x14e2 <DIO_SetPinDirection+0xca>
    1424:	81 30       	cpi	r24, 0x01	; 1
    1426:	e1 f0       	breq	.+56     	; 0x1460 <DIO_SetPinDirection+0x48>
    1428:	30 f0       	brcs	.+12     	; 0x1436 <DIO_SetPinDirection+0x1e>
    142a:	82 30       	cpi	r24, 0x02	; 2
    142c:	71 f1       	breq	.+92     	; 0x148a <DIO_SetPinDirection+0x72>
    142e:	83 30       	cpi	r24, 0x03	; 3
    1430:	09 f4       	brne	.+2      	; 0x1434 <DIO_SetPinDirection+0x1c>
    1432:	40 c0       	rjmp	.+128    	; 0x14b4 <DIO_SetPinDirection+0x9c>
    1434:	58 c0       	rjmp	.+176    	; 0x14e6 <DIO_SetPinDirection+0xce>
    1436:	2a b3       	in	r18, 0x1a	; 26
    1438:	81 e0       	ldi	r24, 0x01	; 1
    143a:	90 e0       	ldi	r25, 0x00	; 0
    143c:	06 2e       	mov	r0, r22
    143e:	02 c0       	rjmp	.+4      	; 0x1444 <DIO_SetPinDirection+0x2c>
    1440:	88 0f       	add	r24, r24
    1442:	99 1f       	adc	r25, r25
    1444:	0a 94       	dec	r0
    1446:	e2 f7       	brpl	.-8      	; 0x1440 <DIO_SetPinDirection+0x28>
    1448:	50 e0       	ldi	r21, 0x00	; 0
    144a:	02 c0       	rjmp	.+4      	; 0x1450 <DIO_SetPinDirection+0x38>
    144c:	44 0f       	add	r20, r20
    144e:	55 1f       	adc	r21, r21
    1450:	6a 95       	dec	r22
    1452:	e2 f7       	brpl	.-8      	; 0x144c <DIO_SetPinDirection+0x34>
    1454:	80 95       	com	r24
    1456:	82 23       	and	r24, r18
    1458:	48 2b       	or	r20, r24
    145a:	4a bb       	out	0x1a, r20	; 26
    145c:	80 e0       	ldi	r24, 0x00	; 0
    145e:	08 95       	ret
    1460:	27 b3       	in	r18, 0x17	; 23
    1462:	81 e0       	ldi	r24, 0x01	; 1
    1464:	90 e0       	ldi	r25, 0x00	; 0
    1466:	06 2e       	mov	r0, r22
    1468:	02 c0       	rjmp	.+4      	; 0x146e <DIO_SetPinDirection+0x56>
    146a:	88 0f       	add	r24, r24
    146c:	99 1f       	adc	r25, r25
    146e:	0a 94       	dec	r0
    1470:	e2 f7       	brpl	.-8      	; 0x146a <DIO_SetPinDirection+0x52>
    1472:	50 e0       	ldi	r21, 0x00	; 0
    1474:	02 c0       	rjmp	.+4      	; 0x147a <DIO_SetPinDirection+0x62>
    1476:	44 0f       	add	r20, r20
    1478:	55 1f       	adc	r21, r21
    147a:	6a 95       	dec	r22
    147c:	e2 f7       	brpl	.-8      	; 0x1476 <DIO_SetPinDirection+0x5e>
    147e:	80 95       	com	r24
    1480:	82 23       	and	r24, r18
    1482:	48 2b       	or	r20, r24
    1484:	47 bb       	out	0x17, r20	; 23
    1486:	80 e0       	ldi	r24, 0x00	; 0
    1488:	08 95       	ret
    148a:	24 b3       	in	r18, 0x14	; 20
    148c:	81 e0       	ldi	r24, 0x01	; 1
    148e:	90 e0       	ldi	r25, 0x00	; 0
    1490:	06 2e       	mov	r0, r22
    1492:	02 c0       	rjmp	.+4      	; 0x1498 <DIO_SetPinDirection+0x80>
    1494:	88 0f       	add	r24, r24
    1496:	99 1f       	adc	r25, r25
    1498:	0a 94       	dec	r0
    149a:	e2 f7       	brpl	.-8      	; 0x1494 <DIO_SetPinDirection+0x7c>
    149c:	50 e0       	ldi	r21, 0x00	; 0
    149e:	02 c0       	rjmp	.+4      	; 0x14a4 <DIO_SetPinDirection+0x8c>
    14a0:	44 0f       	add	r20, r20
    14a2:	55 1f       	adc	r21, r21
    14a4:	6a 95       	dec	r22
    14a6:	e2 f7       	brpl	.-8      	; 0x14a0 <DIO_SetPinDirection+0x88>
    14a8:	80 95       	com	r24
    14aa:	82 23       	and	r24, r18
    14ac:	48 2b       	or	r20, r24
    14ae:	44 bb       	out	0x14, r20	; 20
    14b0:	80 e0       	ldi	r24, 0x00	; 0
    14b2:	08 95       	ret
    14b4:	21 b3       	in	r18, 0x11	; 17
    14b6:	81 e0       	ldi	r24, 0x01	; 1
    14b8:	90 e0       	ldi	r25, 0x00	; 0
    14ba:	06 2e       	mov	r0, r22
    14bc:	02 c0       	rjmp	.+4      	; 0x14c2 <DIO_SetPinDirection+0xaa>
    14be:	88 0f       	add	r24, r24
    14c0:	99 1f       	adc	r25, r25
    14c2:	0a 94       	dec	r0
    14c4:	e2 f7       	brpl	.-8      	; 0x14be <DIO_SetPinDirection+0xa6>
    14c6:	50 e0       	ldi	r21, 0x00	; 0
    14c8:	02 c0       	rjmp	.+4      	; 0x14ce <DIO_SetPinDirection+0xb6>
    14ca:	44 0f       	add	r20, r20
    14cc:	55 1f       	adc	r21, r21
    14ce:	6a 95       	dec	r22
    14d0:	e2 f7       	brpl	.-8      	; 0x14ca <DIO_SetPinDirection+0xb2>
    14d2:	80 95       	com	r24
    14d4:	82 23       	and	r24, r18
    14d6:	48 2b       	or	r20, r24
    14d8:	41 bb       	out	0x11, r20	; 17
    14da:	80 e0       	ldi	r24, 0x00	; 0
    14dc:	08 95       	ret
    14de:	81 e0       	ldi	r24, 0x01	; 1
    14e0:	08 95       	ret
    14e2:	81 e0       	ldi	r24, 0x01	; 1
    14e4:	08 95       	ret
    14e6:	81 e0       	ldi	r24, 0x01	; 1
    14e8:	08 95       	ret

000014ea <DIO_WritePin>:
    14ea:	42 30       	cpi	r20, 0x02	; 2
    14ec:	08 f0       	brcs	.+2      	; 0x14f0 <DIO_WritePin+0x6>
    14ee:	60 c0       	rjmp	.+192    	; 0x15b0 <DIO_WritePin+0xc6>
    14f0:	68 30       	cpi	r22, 0x08	; 8
    14f2:	08 f0       	brcs	.+2      	; 0x14f6 <DIO_WritePin+0xc>
    14f4:	5f c0       	rjmp	.+190    	; 0x15b4 <DIO_WritePin+0xca>
    14f6:	81 30       	cpi	r24, 0x01	; 1
    14f8:	e1 f0       	breq	.+56     	; 0x1532 <DIO_WritePin+0x48>
    14fa:	30 f0       	brcs	.+12     	; 0x1508 <DIO_WritePin+0x1e>
    14fc:	82 30       	cpi	r24, 0x02	; 2
    14fe:	71 f1       	breq	.+92     	; 0x155c <DIO_WritePin+0x72>
    1500:	83 30       	cpi	r24, 0x03	; 3
    1502:	09 f4       	brne	.+2      	; 0x1506 <DIO_WritePin+0x1c>
    1504:	40 c0       	rjmp	.+128    	; 0x1586 <DIO_WritePin+0x9c>
    1506:	58 c0       	rjmp	.+176    	; 0x15b8 <DIO_WritePin+0xce>
    1508:	2b b3       	in	r18, 0x1b	; 27
    150a:	81 e0       	ldi	r24, 0x01	; 1
    150c:	90 e0       	ldi	r25, 0x00	; 0
    150e:	06 2e       	mov	r0, r22
    1510:	02 c0       	rjmp	.+4      	; 0x1516 <DIO_WritePin+0x2c>
    1512:	88 0f       	add	r24, r24
    1514:	99 1f       	adc	r25, r25
    1516:	0a 94       	dec	r0
    1518:	e2 f7       	brpl	.-8      	; 0x1512 <DIO_WritePin+0x28>
    151a:	50 e0       	ldi	r21, 0x00	; 0
    151c:	02 c0       	rjmp	.+4      	; 0x1522 <DIO_WritePin+0x38>
    151e:	44 0f       	add	r20, r20
    1520:	55 1f       	adc	r21, r21
    1522:	6a 95       	dec	r22
    1524:	e2 f7       	brpl	.-8      	; 0x151e <DIO_WritePin+0x34>
    1526:	80 95       	com	r24
    1528:	82 23       	and	r24, r18
    152a:	48 2b       	or	r20, r24
    152c:	4b bb       	out	0x1b, r20	; 27
    152e:	80 e0       	ldi	r24, 0x00	; 0
    1530:	08 95       	ret
    1532:	28 b3       	in	r18, 0x18	; 24
    1534:	81 e0       	ldi	r24, 0x01	; 1
    1536:	90 e0       	ldi	r25, 0x00	; 0
    1538:	06 2e       	mov	r0, r22
    153a:	02 c0       	rjmp	.+4      	; 0x1540 <DIO_WritePin+0x56>
    153c:	88 0f       	add	r24, r24
    153e:	99 1f       	adc	r25, r25
    1540:	0a 94       	dec	r0
    1542:	e2 f7       	brpl	.-8      	; 0x153c <DIO_WritePin+0x52>
    1544:	50 e0       	ldi	r21, 0x00	; 0
    1546:	02 c0       	rjmp	.+4      	; 0x154c <DIO_WritePin+0x62>
    1548:	44 0f       	add	r20, r20
    154a:	55 1f       	adc	r21, r21
    154c:	6a 95       	dec	r22
    154e:	e2 f7       	brpl	.-8      	; 0x1548 <DIO_WritePin+0x5e>
    1550:	80 95       	com	r24
    1552:	82 23       	and	r24, r18
    1554:	48 2b       	or	r20, r24
    1556:	48 bb       	out	0x18, r20	; 24
    1558:	80 e0       	ldi	r24, 0x00	; 0
    155a:	08 95       	ret
    155c:	25 b3       	in	r18, 0x15	; 21
    155e:	81 e0       	ldi	r24, 0x01	; 1
    1560:	90 e0       	ldi	r25, 0x00	; 0
    1562:	06 2e       	mov	r0, r22
    1564:	02 c0       	rjmp	.+4      	; 0x156a <DIO_WritePin+0x80>
    1566:	88 0f       	add	r24, r24
    1568:	99 1f       	adc	r25, r25
    156a:	0a 94       	dec	r0
    156c:	e2 f7       	brpl	.-8      	; 0x1566 <DIO_WritePin+0x7c>
    156e:	50 e0       	ldi	r21, 0x00	; 0
    1570:	02 c0       	rjmp	.+4      	; 0x1576 <DIO_WritePin+0x8c>
    1572:	44 0f       	add	r20, r20
    1574:	55 1f       	adc	r21, r21
    1576:	6a 95       	dec	r22
    1578:	e2 f7       	brpl	.-8      	; 0x1572 <DIO_WritePin+0x88>
    157a:	80 95       	com	r24
    157c:	82 23       	and	r24, r18
    157e:	48 2b       	or	r20, r24
    1580:	45 bb       	out	0x15, r20	; 21
    1582:	80 e0       	ldi	r24, 0x00	; 0
    1584:	08 95       	ret
    1586:	22 b3       	in	r18, 0x12	; 18
    1588:	81 e0       	ldi	r24, 0x01	; 1
    158a:	90 e0       	ldi	r25, 0x00	; 0
    158c:	06 2e       	mov	r0, r22
    158e:	02 c0       	rjmp	.+4      	; 0x1594 <DIO_WritePin+0xaa>
    1590:	88 0f       	add	r24, r24
    1592:	99 1f       	adc	r25, r25
    1594:	0a 94       	dec	r0
    1596:	e2 f7       	brpl	.-8      	; 0x1590 <DIO_WritePin+0xa6>
    1598:	50 e0       	ldi	r21, 0x00	; 0
    159a:	02 c0       	rjmp	.+4      	; 0x15a0 <DIO_WritePin+0xb6>
    159c:	44 0f       	add	r20, r20
    159e:	55 1f       	adc	r21, r21
    15a0:	6a 95       	dec	r22
    15a2:	e2 f7       	brpl	.-8      	; 0x159c <DIO_WritePin+0xb2>
    15a4:	80 95       	com	r24
    15a6:	82 23       	and	r24, r18
    15a8:	48 2b       	or	r20, r24
    15aa:	42 bb       	out	0x12, r20	; 18
    15ac:	80 e0       	ldi	r24, 0x00	; 0
    15ae:	08 95       	ret
    15b0:	81 e0       	ldi	r24, 0x01	; 1
    15b2:	08 95       	ret
    15b4:	81 e0       	ldi	r24, 0x01	; 1
    15b6:	08 95       	ret
    15b8:	81 e0       	ldi	r24, 0x01	; 1
    15ba:	08 95       	ret

000015bc <DIO_ReadPin>:
ERROR_STATE_t DIO_ReadPin(uint8_t PortName,uint8_t PinNo,ptr_uint8_t PinData)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PinNo>PIN7)
    15bc:	68 30       	cpi	r22, 0x08	; 8
    15be:	d8 f5       	brcc	.+118    	; 0x1636 <DIO_ReadPin+0x7a>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else if(NULL_PTR==PinData)
    15c0:	41 15       	cp	r20, r1
    15c2:	51 05       	cpc	r21, r1
    15c4:	d1 f1       	breq	.+116    	; 0x163a <DIO_ReadPin+0x7e>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{
		switch(PortName)
    15c6:	81 30       	cpi	r24, 0x01	; 1
    15c8:	91 f0       	breq	.+36     	; 0x15ee <DIO_ReadPin+0x32>
    15ca:	28 f0       	brcs	.+10     	; 0x15d6 <DIO_ReadPin+0x1a>
    15cc:	82 30       	cpi	r24, 0x02	; 2
    15ce:	d9 f0       	breq	.+54     	; 0x1606 <DIO_ReadPin+0x4a>
    15d0:	83 30       	cpi	r24, 0x03	; 3
    15d2:	29 f1       	breq	.+74     	; 0x161e <DIO_ReadPin+0x62>
    15d4:	34 c0       	rjmp	.+104    	; 0x163e <DIO_ReadPin+0x82>
		{
			case PORT_A:
				* PinData=BIT_GET(PINA,PinNo);
    15d6:	89 b3       	in	r24, 0x19	; 25
    15d8:	90 e0       	ldi	r25, 0x00	; 0
    15da:	02 c0       	rjmp	.+4      	; 0x15e0 <DIO_ReadPin+0x24>
    15dc:	95 95       	asr	r25
    15de:	87 95       	ror	r24
    15e0:	6a 95       	dec	r22
    15e2:	e2 f7       	brpl	.-8      	; 0x15dc <DIO_ReadPin+0x20>
    15e4:	81 70       	andi	r24, 0x01	; 1
    15e6:	fa 01       	movw	r30, r20
    15e8:	80 83       	st	Z, r24
				u8_ErrorState=ERROR_OK;
    15ea:	80 e0       	ldi	r24, 0x00	; 0
				break;
    15ec:	08 95       	ret
			case PORT_B:
				* PinData=BIT_GET(PINB,PinNo);
    15ee:	86 b3       	in	r24, 0x16	; 22
    15f0:	90 e0       	ldi	r25, 0x00	; 0
    15f2:	02 c0       	rjmp	.+4      	; 0x15f8 <DIO_ReadPin+0x3c>
    15f4:	95 95       	asr	r25
    15f6:	87 95       	ror	r24
    15f8:	6a 95       	dec	r22
    15fa:	e2 f7       	brpl	.-8      	; 0x15f4 <DIO_ReadPin+0x38>
    15fc:	81 70       	andi	r24, 0x01	; 1
    15fe:	fa 01       	movw	r30, r20
    1600:	80 83       	st	Z, r24
				u8_ErrorState=ERROR_OK;
    1602:	80 e0       	ldi	r24, 0x00	; 0
				break;
    1604:	08 95       	ret
			case PORT_C:
				* PinData=BIT_GET(PINC,PinNo);
    1606:	83 b3       	in	r24, 0x13	; 19
    1608:	90 e0       	ldi	r25, 0x00	; 0
    160a:	02 c0       	rjmp	.+4      	; 0x1610 <DIO_ReadPin+0x54>
    160c:	95 95       	asr	r25
    160e:	87 95       	ror	r24
    1610:	6a 95       	dec	r22
    1612:	e2 f7       	brpl	.-8      	; 0x160c <DIO_ReadPin+0x50>
    1614:	81 70       	andi	r24, 0x01	; 1
    1616:	fa 01       	movw	r30, r20
    1618:	80 83       	st	Z, r24
				u8_ErrorState=ERROR_OK;
    161a:	80 e0       	ldi	r24, 0x00	; 0
				break;
    161c:	08 95       	ret
			case PORT_D:
				* PinData=BIT_GET(PIND,PinNo);
    161e:	80 b3       	in	r24, 0x10	; 16
    1620:	90 e0       	ldi	r25, 0x00	; 0
    1622:	02 c0       	rjmp	.+4      	; 0x1628 <DIO_ReadPin+0x6c>
    1624:	95 95       	asr	r25
    1626:	87 95       	ror	r24
    1628:	6a 95       	dec	r22
    162a:	e2 f7       	brpl	.-8      	; 0x1624 <DIO_ReadPin+0x68>
    162c:	81 70       	andi	r24, 0x01	; 1
    162e:	fa 01       	movw	r30, r20
    1630:	80 83       	st	Z, r24
				u8_ErrorState=ERROR_OK;
    1632:	80 e0       	ldi	r24, 0x00	; 0
				break;
    1634:	08 95       	ret
ERROR_STATE_t DIO_ReadPin(uint8_t PortName,uint8_t PinNo,ptr_uint8_t PinData)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PinNo>PIN7)
	{
		u8_ErrorState=ERROR_NOK;
    1636:	81 e0       	ldi	r24, 0x01	; 1
    1638:	08 95       	ret
	}
	else if(NULL_PTR==PinData)
	{
		u8_ErrorState=ERROR_NOK;
    163a:	81 e0       	ldi	r24, 0x01	; 1
    163c:	08 95       	ret
			case PORT_D:
				* PinData=BIT_GET(PIND,PinNo);
				u8_ErrorState=ERROR_OK;
				break;
			default:
				u8_ErrorState=ERROR_NOK;
    163e:	81 e0       	ldi	r24, 0x01	; 1
				break;
		}
	}	
	return u8_ErrorState;
}
    1640:	08 95       	ret

00001642 <DIO_EnablePinPullup>:


ERROR_STATE_t DIO_EnablePinPullup(uint8_t PortName,uint8_t PinNo)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PinNo>PIN7)
    1642:	68 30       	cpi	r22, 0x08	; 8
    1644:	c0 f5       	brcc	.+112    	; 0x16b6 <DIO_EnablePinPullup+0x74>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{	
		switch(PortName)
    1646:	81 30       	cpi	r24, 0x01	; 1
    1648:	91 f0       	breq	.+36     	; 0x166e <DIO_EnablePinPullup+0x2c>
    164a:	28 f0       	brcs	.+10     	; 0x1656 <DIO_EnablePinPullup+0x14>
    164c:	82 30       	cpi	r24, 0x02	; 2
    164e:	d9 f0       	breq	.+54     	; 0x1686 <DIO_EnablePinPullup+0x44>
    1650:	83 30       	cpi	r24, 0x03	; 3
    1652:	29 f1       	breq	.+74     	; 0x169e <DIO_EnablePinPullup+0x5c>
    1654:	32 c0       	rjmp	.+100    	; 0x16ba <DIO_EnablePinPullup+0x78>
		{
			case PORT_A:
				BIT_WRITE(PORTA,PinNo,PIN_HIGH);
    1656:	81 e0       	ldi	r24, 0x01	; 1
    1658:	90 e0       	ldi	r25, 0x00	; 0
    165a:	02 c0       	rjmp	.+4      	; 0x1660 <DIO_EnablePinPullup+0x1e>
    165c:	88 0f       	add	r24, r24
    165e:	99 1f       	adc	r25, r25
    1660:	6a 95       	dec	r22
    1662:	e2 f7       	brpl	.-8      	; 0x165c <DIO_EnablePinPullup+0x1a>
    1664:	9b b3       	in	r25, 0x1b	; 27
    1666:	89 2b       	or	r24, r25
    1668:	8b bb       	out	0x1b, r24	; 27
				u8_ErrorState=ERROR_OK;
    166a:	80 e0       	ldi	r24, 0x00	; 0
				break;
    166c:	08 95       	ret
			case PORT_B:
				BIT_WRITE(PORTB,PinNo,PIN_HIGH);
    166e:	81 e0       	ldi	r24, 0x01	; 1
    1670:	90 e0       	ldi	r25, 0x00	; 0
    1672:	02 c0       	rjmp	.+4      	; 0x1678 <DIO_EnablePinPullup+0x36>
    1674:	88 0f       	add	r24, r24
    1676:	99 1f       	adc	r25, r25
    1678:	6a 95       	dec	r22
    167a:	e2 f7       	brpl	.-8      	; 0x1674 <DIO_EnablePinPullup+0x32>
    167c:	98 b3       	in	r25, 0x18	; 24
    167e:	89 2b       	or	r24, r25
    1680:	88 bb       	out	0x18, r24	; 24
				u8_ErrorState=ERROR_OK;
    1682:	80 e0       	ldi	r24, 0x00	; 0
				break;                            
    1684:	08 95       	ret
			case PORT_C:                          
				BIT_WRITE(PORTC,PinNo,PIN_HIGH);
    1686:	81 e0       	ldi	r24, 0x01	; 1
    1688:	90 e0       	ldi	r25, 0x00	; 0
    168a:	02 c0       	rjmp	.+4      	; 0x1690 <DIO_EnablePinPullup+0x4e>
    168c:	88 0f       	add	r24, r24
    168e:	99 1f       	adc	r25, r25
    1690:	6a 95       	dec	r22
    1692:	e2 f7       	brpl	.-8      	; 0x168c <DIO_EnablePinPullup+0x4a>
    1694:	95 b3       	in	r25, 0x15	; 21
    1696:	89 2b       	or	r24, r25
    1698:	85 bb       	out	0x15, r24	; 21
				u8_ErrorState=ERROR_OK;
    169a:	80 e0       	ldi	r24, 0x00	; 0
				break;                            
    169c:	08 95       	ret
			case PORT_D:                          
				BIT_WRITE(PORTD,PinNo,PIN_HIGH);
    169e:	81 e0       	ldi	r24, 0x01	; 1
    16a0:	90 e0       	ldi	r25, 0x00	; 0
    16a2:	02 c0       	rjmp	.+4      	; 0x16a8 <DIO_EnablePinPullup+0x66>
    16a4:	88 0f       	add	r24, r24
    16a6:	99 1f       	adc	r25, r25
    16a8:	6a 95       	dec	r22
    16aa:	e2 f7       	brpl	.-8      	; 0x16a4 <DIO_EnablePinPullup+0x62>
    16ac:	92 b3       	in	r25, 0x12	; 18
    16ae:	89 2b       	or	r24, r25
    16b0:	82 bb       	out	0x12, r24	; 18
				u8_ErrorState=ERROR_OK;
    16b2:	80 e0       	ldi	r24, 0x00	; 0
				break;
    16b4:	08 95       	ret
ERROR_STATE_t DIO_EnablePinPullup(uint8_t PortName,uint8_t PinNo)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PinNo>PIN7)
	{
		u8_ErrorState=ERROR_NOK;
    16b6:	81 e0       	ldi	r24, 0x01	; 1
    16b8:	08 95       	ret
			case PORT_D:                          
				BIT_WRITE(PORTD,PinNo,PIN_HIGH);
				u8_ErrorState=ERROR_OK;
				break;
			default:
				u8_ErrorState=ERROR_NOK;
    16ba:	81 e0       	ldi	r24, 0x01	; 1
				break;
		}	
	}	
	return u8_ErrorState;
    16bc:	08 95       	ret

000016be <PWM_Init>:
		default:
			u8_ErrorState=ERROR_NOK;
			break;			
	}
	return u8_ErrorState;
}
    16be:	83 30       	cpi	r24, 0x03	; 3
    16c0:	69 f5       	brne	.+90     	; 0x171c <PWM_Init+0x5e>
    16c2:	85 b5       	in	r24, 0x25	; 37
    16c4:	e3 e6       	ldi	r30, 0x63	; 99
    16c6:	f0 e0       	ldi	r31, 0x00	; 0
    16c8:	92 85       	ldd	r25, Z+10	; 0x0a
    16ca:	49 2f       	mov	r20, r25
    16cc:	41 70       	andi	r20, 0x01	; 1
    16ce:	50 e0       	ldi	r21, 0x00	; 0
    16d0:	00 24       	eor	r0, r0
    16d2:	56 95       	lsr	r21
    16d4:	47 95       	ror	r20
    16d6:	07 94       	ror	r0
    16d8:	56 95       	lsr	r21
    16da:	47 95       	ror	r20
    16dc:	07 94       	ror	r0
    16de:	54 2f       	mov	r21, r20
    16e0:	40 2d       	mov	r20, r0
    16e2:	8f 7b       	andi	r24, 0xBF	; 191
    16e4:	48 2b       	or	r20, r24
    16e6:	91 fb       	bst	r25, 1
    16e8:	22 27       	eor	r18, r18
    16ea:	20 f9       	bld	r18, 0
    16ec:	30 e0       	ldi	r19, 0x00	; 0
    16ee:	22 0f       	add	r18, r18
    16f0:	33 1f       	adc	r19, r19
    16f2:	22 0f       	add	r18, r18
    16f4:	33 1f       	adc	r19, r19
    16f6:	22 0f       	add	r18, r18
    16f8:	33 1f       	adc	r19, r19
    16fa:	47 7f       	andi	r20, 0xF7	; 247
    16fc:	24 2b       	or	r18, r20
    16fe:	83 85       	ldd	r24, Z+11	; 0x0b
    1700:	30 e1       	ldi	r19, 0x10	; 16
    1702:	83 9f       	mul	r24, r19
    1704:	c0 01       	movw	r24, r0
    1706:	11 24       	eor	r1, r1
    1708:	2f 7c       	andi	r18, 0xCF	; 207
    170a:	28 2b       	or	r18, r24
    170c:	25 bd       	out	0x25, r18	; 37
    170e:	41 e0       	ldi	r20, 0x01	; 1
    1710:	67 e0       	ldi	r22, 0x07	; 7
    1712:	83 e0       	ldi	r24, 0x03	; 3
    1714:	0e 94 0c 0a 	call	0x1418	; 0x1418 <DIO_SetPinDirection>
    1718:	80 e0       	ldi	r24, 0x00	; 0
    171a:	08 95       	ret
    171c:	81 e0       	ldi	r24, 0x01	; 1
    171e:	08 95       	ret

00001720 <PWM_Start>:
    1720:	83 30       	cpi	r24, 0x03	; 3
    1722:	41 f4       	brne	.+16     	; 0x1734 <PWM_Start+0x14>
    1724:	85 b5       	in	r24, 0x25	; 37
    1726:	90 91 6c 00 	lds	r25, 0x006C	; 0x80006c <gastr_PWMConfig+0x9>
    172a:	88 7f       	andi	r24, 0xF8	; 248
    172c:	89 2b       	or	r24, r25
    172e:	85 bd       	out	0x25, r24	; 37
    1730:	80 e0       	ldi	r24, 0x00	; 0
    1732:	08 95       	ret
    1734:	81 e0       	ldi	r24, 0x01	; 1
    1736:	08 95       	ret

00001738 <PWM_Connect>:
    1738:	83 30       	cpi	r24, 0x03	; 3
    173a:	69 f4       	brne	.+26     	; 0x1756 <PWM_Connect+0x1e>
    173c:	25 b5       	in	r18, 0x25	; 37
    173e:	90 91 6e 00 	lds	r25, 0x006E	; 0x80006e <gastr_PWMConfig+0xb>
    1742:	30 e1       	ldi	r19, 0x10	; 16
    1744:	93 9f       	mul	r25, r19
    1746:	c0 01       	movw	r24, r0
    1748:	11 24       	eor	r1, r1
    174a:	92 2f       	mov	r25, r18
    174c:	9f 7c       	andi	r25, 0xCF	; 207
    174e:	89 2b       	or	r24, r25
    1750:	85 bd       	out	0x25, r24	; 37
    1752:	80 e0       	ldi	r24, 0x00	; 0
    1754:	08 95       	ret
    1756:	81 e0       	ldi	r24, 0x01	; 1
    1758:	08 95       	ret

0000175a <PWM_SetDuty>:

ERROR_STATE_t PWM_SetDuty(uint8_t PwmChannelNumber,uint8_t PwmDuty )
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PwmDuty==0||PwmDuty>100)
    175a:	9f ef       	ldi	r25, 0xFF	; 255
    175c:	96 0f       	add	r25, r22
    175e:	94 36       	cpi	r25, 0x64	; 100
    1760:	10 f5       	brcc	.+68     	; 0x17a6 <PWM_SetDuty+0x4c>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{
		switch(PwmChannelNumber)
    1762:	83 30       	cpi	r24, 0x03	; 3
    1764:	11 f5       	brne	.+68     	; 0x17aa <PWM_SetDuty+0x50>
					break;	
			#endif	
			
			#if OC2
				case PWM_CHANNEL_OC2:
					switch(gastr_PWMConfig[PWM_CHANNEL_OC2].PWMWaveformMode)
    1766:	80 91 6e 00 	lds	r24, 0x006E	; 0x80006e <gastr_PWMConfig+0xb>
    176a:	82 30       	cpi	r24, 0x02	; 2
    176c:	01 f5       	brne	.+64     	; 0x17ae <PWM_SetDuty+0x54>
					{
						case NON_INVERTING:
							OCR2 = (uint8_t)(((PwmDuty/100.0)*256.0)-1);
    176e:	70 e0       	ldi	r23, 0x00	; 0
    1770:	80 e0       	ldi	r24, 0x00	; 0
    1772:	90 e0       	ldi	r25, 0x00	; 0
    1774:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <__floatsisf>
    1778:	20 e0       	ldi	r18, 0x00	; 0
    177a:	30 e0       	ldi	r19, 0x00	; 0
    177c:	48 ec       	ldi	r20, 0xC8	; 200
    177e:	52 e4       	ldi	r21, 0x42	; 66
    1780:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <__divsf3>
    1784:	20 e0       	ldi	r18, 0x00	; 0
    1786:	30 e0       	ldi	r19, 0x00	; 0
    1788:	40 e8       	ldi	r20, 0x80	; 128
    178a:	53 e4       	ldi	r21, 0x43	; 67
    178c:	0e 94 f7 0f 	call	0x1fee	; 0x1fee <__mulsf3>
    1790:	20 e0       	ldi	r18, 0x00	; 0
    1792:	30 e0       	ldi	r19, 0x00	; 0
    1794:	40 e8       	ldi	r20, 0x80	; 128
    1796:	5f e3       	ldi	r21, 0x3F	; 63
    1798:	0e 94 0b 0e 	call	0x1c16	; 0x1c16 <__subsf3>
    179c:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <__fixunssfsi>
    17a0:	63 bd       	out	0x23, r22	; 35
							u8_ErrorState=ERROR_OK;
    17a2:	80 e0       	ldi	r24, 0x00	; 0
							break;
    17a4:	08 95       	ret
ERROR_STATE_t PWM_SetDuty(uint8_t PwmChannelNumber,uint8_t PwmDuty )
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PwmDuty==0||PwmDuty>100)
	{
		u8_ErrorState=ERROR_NOK;
    17a6:	81 e0       	ldi	r24, 0x01	; 1
    17a8:	08 95       	ret
							break;
					}
					break;
			#endif	
			default:
				u8_ErrorState=ERROR_NOK;
    17aa:	81 e0       	ldi	r24, 0x01	; 1
    17ac:	08 95       	ret
						case NON_INVERTING:
							OCR2 = (uint8_t)(((PwmDuty/100.0)*256.0)-1);
							u8_ErrorState=ERROR_OK;
							break;
						default:
							u8_ErrorState=ERROR_NOK;
    17ae:	81 e0       	ldi	r24, 0x01	; 1
				u8_ErrorState=ERROR_NOK;
				break;			
		}		
	}
	return u8_ErrorState;
    17b0:	08 95       	ret

000017b2 <Display_MainFunction>:
* @brief: This function is the Display main function.
*
* @return function error state.
*/
extern void Display_MainFunction(void)
{
    17b2:	0f 93       	push	r16
    17b4:	1f 93       	push	r17
    17b6:	cf 93       	push	r28
    17b8:	df 93       	push	r29
    17ba:	1f 92       	push	r1
    17bc:	cd b7       	in	r28, 0x3d	; 61
    17be:	de b7       	in	r29, 0x3e	; 62
   static uint8_t u8_Init = 0;  
   uint8_t u8_SevenSegmentNumber; 
   static Enu_DisplayStateMachine State = Display_FirstNumber;
   
   if (u8_Init == 0)
    17c0:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <u8_Init.1652>
    17c4:	81 11       	cpse	r24, r1
    17c6:	0d c0       	rjmp	.+26     	; 0x17e2 <Display_MainFunction+0x30>
   {
      SevenSeg_Init(STR_DisplaySegmentConfig.u8_SegmentCh0);
    17c8:	04 e7       	ldi	r16, 0x74	; 116
    17ca:	10 e0       	ldi	r17, 0x00	; 0
    17cc:	f8 01       	movw	r30, r16
    17ce:	80 81       	ld	r24, Z
    17d0:	0e 94 90 09 	call	0x1320	; 0x1320 <SevenSeg_Init>
      SevenSeg_Init(STR_DisplaySegmentConfig.u8_SegmentCh1);
    17d4:	f8 01       	movw	r30, r16
    17d6:	81 81       	ldd	r24, Z+1	; 0x01
    17d8:	0e 94 90 09 	call	0x1320	; 0x1320 <SevenSeg_Init>
      u8_Init = 1;
    17dc:	81 e0       	ldi	r24, 0x01	; 1
    17de:	80 93 53 07 	sts	0x0753, r24	; 0x800753 <u8_Init.1652>
   }
   
   Display_GetSevenSegment(&u8_SevenSegmentNumber);
    17e2:	ce 01       	movw	r24, r28
    17e4:	01 96       	adiw	r24, 0x01	; 1
    17e6:	0e 94 26 0c 	call	0x184c	; 0x184c <Display_GetSevenSegment>
   
   switch(State)
    17ea:	80 91 52 07 	lds	r24, 0x0752	; 0x800752 <State.1654>
    17ee:	88 23       	and	r24, r24
    17f0:	19 f0       	breq	.+6      	; 0x17f8 <Display_MainFunction+0x46>
    17f2:	81 30       	cpi	r24, 0x01	; 1
    17f4:	b9 f0       	breq	.+46     	; 0x1824 <Display_MainFunction+0x72>
    17f6:	24 c0       	rjmp	.+72     	; 0x1840 <Display_MainFunction+0x8e>
   {
      case Display_FirstNumber:
         SevenSeg_Display(STR_DisplaySegmentConfig.u8_SegmentCh0, u8_SevenSegmentNumber%10);
    17f8:	69 81       	ldd	r22, Y+1	; 0x01
    17fa:	8d ec       	ldi	r24, 0xCD	; 205
    17fc:	68 9f       	mul	r22, r24
    17fe:	81 2d       	mov	r24, r1
    1800:	11 24       	eor	r1, r1
    1802:	86 95       	lsr	r24
    1804:	86 95       	lsr	r24
    1806:	86 95       	lsr	r24
    1808:	88 0f       	add	r24, r24
    180a:	98 2f       	mov	r25, r24
    180c:	99 0f       	add	r25, r25
    180e:	99 0f       	add	r25, r25
    1810:	89 0f       	add	r24, r25
    1812:	68 1b       	sub	r22, r24
    1814:	80 91 74 00 	lds	r24, 0x0074	; 0x800074 <STR_DisplaySegmentConfig>
    1818:	0e 94 c8 09 	call	0x1390	; 0x1390 <SevenSeg_Display>
         State = Display_SecondNumber;
    181c:	81 e0       	ldi	r24, 0x01	; 1
    181e:	80 93 52 07 	sts	0x0752, r24	; 0x800752 <State.1654>
         break;
    1822:	0e c0       	rjmp	.+28     	; 0x1840 <Display_MainFunction+0x8e>
      case Display_SecondNumber:
         SevenSeg_Display(STR_DisplaySegmentConfig.u8_SegmentCh1, u8_SevenSegmentNumber/10);
    1824:	89 81       	ldd	r24, Y+1	; 0x01
    1826:	6d ec       	ldi	r22, 0xCD	; 205
    1828:	86 9f       	mul	r24, r22
    182a:	61 2d       	mov	r22, r1
    182c:	11 24       	eor	r1, r1
    182e:	66 95       	lsr	r22
    1830:	66 95       	lsr	r22
    1832:	66 95       	lsr	r22
    1834:	80 91 75 00 	lds	r24, 0x0075	; 0x800075 <STR_DisplaySegmentConfig+0x1>
    1838:	0e 94 c8 09 	call	0x1390	; 0x1390 <SevenSeg_Display>
         State = Display_FirstNumber;
    183c:	10 92 52 07 	sts	0x0752, r1	; 0x800752 <State.1654>
         break;
   }      
    1840:	0f 90       	pop	r0
    1842:	df 91       	pop	r29
    1844:	cf 91       	pop	r28
    1846:	1f 91       	pop	r17
    1848:	0f 91       	pop	r16
    184a:	08 95       	ret

0000184c <Display_GetSevenSegment>:
*/
extern ERROR_STATE_t Display_GetSevenSegment(uint8_t * Value)
{
   ERROR_STATE_t Display_ErrorState;
   
   if(NULL_PTR == Value)
    184c:	00 97       	sbiw	r24, 0x00	; 0
    184e:	31 f0       	breq	.+12     	; 0x185c <Display_GetSevenSegment+0x10>
   {
      Display_ErrorState = (E_DISPLAY_ID | E_DISPLAY_NULL_PTR);
   }
   else
   {
      *Value = gu8_SevenSegmentValue;
    1850:	20 91 54 07 	lds	r18, 0x0754	; 0x800754 <gu8_SevenSegmentValue>
    1854:	fc 01       	movw	r30, r24
    1856:	20 83       	st	Z, r18
      Display_ErrorState = ERROR_OK;
    1858:	80 e0       	ldi	r24, 0x00	; 0
    185a:	08 95       	ret
{
   ERROR_STATE_t Display_ErrorState;
   
   if(NULL_PTR == Value)
   {
      Display_ErrorState = (E_DISPLAY_ID | E_DISPLAY_NULL_PTR);
    185c:	82 e9       	ldi	r24, 0x92	; 146
      *Value = gu8_SevenSegmentValue;
      Display_ErrorState = ERROR_OK;
   }
   
   return Display_ErrorState;
}
    185e:	08 95       	ret

00001860 <Display_SetSevenSegment>:
*/
extern ERROR_STATE_t Display_SetSevenSegment(uint8_t Value)
{
   ERROR_STATE_t Display_ErrorState;
   
   if(INVALID_SEVEN_SEGMENT_VALUE <= Value)
    1860:	84 36       	cpi	r24, 0x64	; 100
    1862:	20 f4       	brcc	.+8      	; 0x186c <Display_SetSevenSegment+0xc>
   {
      Display_ErrorState = (E_DISPLAY_ID | E_DISPLAY_INVALID_VAL);
   }
   else
   {
      gu8_SevenSegmentValue = Value;
    1864:	80 93 54 07 	sts	0x0754, r24	; 0x800754 <gu8_SevenSegmentValue>
      Display_ErrorState = ERROR_OK;
    1868:	80 e0       	ldi	r24, 0x00	; 0
    186a:	08 95       	ret
{
   ERROR_STATE_t Display_ErrorState;
   
   if(INVALID_SEVEN_SEGMENT_VALUE <= Value)
   {
      Display_ErrorState = (E_DISPLAY_ID | E_DISPLAY_INVALID_VAL);
    186c:	81 e9       	ldi	r24, 0x91	; 145
      gu8_SevenSegmentValue = Value;
      Display_ErrorState = ERROR_OK;
   }
   
   return Display_ErrorState;
    186e:	08 95       	ret

00001870 <HMI_MainFunction>:
* @brief: This function is the HMI main function.
*
* @return function error state.
*/
extern void HMI_MainFunction(void)
{
    1870:	0f 93       	push	r16
    1872:	1f 93       	push	r17
    1874:	cf 93       	push	r28
    1876:	df 93       	push	r29
    1878:	00 d0       	rcall	.+0      	; 0x187a <HMI_MainFunction+0xa>
    187a:	00 d0       	rcall	.+0      	; 0x187c <HMI_MainFunction+0xc>
    187c:	cd b7       	in	r28, 0x3d	; 61
    187e:	de b7       	in	r29, 0x3e	; 62
   ERROR_STATE_t KP_ErrorState;
   static uint8_t u8_Init = 0;
   uint32_t u32_Key;
   static uint32_t u32_OldKey = 0;
   
   if (u8_Init == 0)
    1880:	80 91 59 07 	lds	r24, 0x0759	; 0x800759 <u8_Init.1752>
    1884:	81 11       	cpse	r24, r1
    1886:	0a c0       	rjmp	.+20     	; 0x189c <HMI_MainFunction+0x2c>
   {
      KP_Init(KP_UsedChannel);
    1888:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <KP_UsedChannel>
    188c:	0e 94 48 07 	call	0xe90	; 0xe90 <KP_Init>
      DDRB |= 0xF0;
    1890:	87 b3       	in	r24, 0x17	; 23
    1892:	80 6f       	ori	r24, 0xF0	; 240
    1894:	87 bb       	out	0x17, r24	; 23
      u8_Init = 1;
    1896:	81 e0       	ldi	r24, 0x01	; 1
    1898:	80 93 59 07 	sts	0x0759, r24	; 0x800759 <u8_Init.1752>
   }
   
   KP_ErrorState = KP_GetPressedValue(KP_UsedChannel, &u32_Key);
    189c:	be 01       	movw	r22, r28
    189e:	6f 5f       	subi	r22, 0xFF	; 255
    18a0:	7f 4f       	sbci	r23, 0xFF	; 255
    18a2:	80 91 76 00 	lds	r24, 0x0076	; 0x800076 <KP_UsedChannel>
    18a6:	0e 94 a4 07 	call	0xf48	; 0xf48 <KP_GetPressedValue>
   if(KP_ErrorState == ERROR_OK && u32_OldKey != u32_Key)
    18aa:	81 11       	cpse	r24, r1
    18ac:	5d c0       	rjmp	.+186    	; 0x1968 <HMI_MainFunction+0xf8>
    18ae:	00 91 55 07 	lds	r16, 0x0755	; 0x800755 <u32_OldKey.1754>
    18b2:	10 91 56 07 	lds	r17, 0x0756	; 0x800756 <u32_OldKey.1754+0x1>
    18b6:	20 91 57 07 	lds	r18, 0x0757	; 0x800757 <u32_OldKey.1754+0x2>
    18ba:	30 91 58 07 	lds	r19, 0x0758	; 0x800758 <u32_OldKey.1754+0x3>
    18be:	69 81       	ldd	r22, Y+1	; 0x01
    18c0:	7a 81       	ldd	r23, Y+2	; 0x02
    18c2:	8b 81       	ldd	r24, Y+3	; 0x03
    18c4:	9c 81       	ldd	r25, Y+4	; 0x04
    18c6:	06 17       	cp	r16, r22
    18c8:	17 07       	cpc	r17, r23
    18ca:	28 07       	cpc	r18, r24
    18cc:	39 07       	cpc	r19, r25
    18ce:	09 f4       	brne	.+2      	; 0x18d2 <HMI_MainFunction+0x62>
    18d0:	4b c0       	rjmp	.+150    	; 0x1968 <HMI_MainFunction+0xf8>
   {
      u32_OldKey = u32_Key;
    18d2:	60 93 55 07 	sts	0x0755, r22	; 0x800755 <u32_OldKey.1754>
    18d6:	70 93 56 07 	sts	0x0756, r23	; 0x800756 <u32_OldKey.1754+0x1>
    18da:	80 93 57 07 	sts	0x0757, r24	; 0x800757 <u32_OldKey.1754+0x2>
    18de:	90 93 58 07 	sts	0x0758, r25	; 0x800758 <u32_OldKey.1754+0x3>
      if(MULTI_PRESS_BIT & u32_Key)
    18e2:	60 ff       	sbrs	r22, 0
    18e4:	1d c0       	rjmp	.+58     	; 0x1920 <HMI_MainFunction+0xb0>
      {
         if(DEVICE_ERASE_VALUE == u32_Key)
    18e6:	63 34       	cpi	r22, 0x43	; 67
    18e8:	20 e1       	ldi	r18, 0x10	; 16
    18ea:	72 07       	cpc	r23, r18
    18ec:	81 05       	cpc	r24, r1
    18ee:	91 05       	cpc	r25, r1
    18f0:	39 f4       	brne	.+14     	; 0x1900 <HMI_MainFunction+0x90>
         {
            HMI_SetDeviceEraseFlag();
    18f2:	0e 94 bd 0c 	call	0x197a	; 0x197a <HMI_SetDeviceEraseFlag>
            PORTB &= ~(0xF0);
    18f6:	88 b3       	in	r24, 0x18	; 24
    18f8:	8f 70       	andi	r24, 0x0F	; 15
            PORTB |= (13<<4);
    18fa:	80 6d       	ori	r24, 0xD0	; 208
    18fc:	88 bb       	out	0x18, r24	; 24
    18fe:	34 c0       	rjmp	.+104    	; 0x1968 <HMI_MainFunction+0xf8>
         }
         else if(PASSWORD_CHANGE_VALUE == u32_Key)
    1900:	63 34       	cpi	r22, 0x43	; 67
    1902:	74 40       	sbci	r23, 0x04	; 4
    1904:	81 05       	cpc	r24, r1
    1906:	91 05       	cpc	r25, r1
    1908:	39 f4       	brne	.+14     	; 0x1918 <HMI_MainFunction+0xa8>
         {
            HMI_SetPasswordChangeFlag();
    190a:	0e 94 c2 0c 	call	0x1984	; 0x1984 <HMI_SetPasswordChangeFlag>
            PORTB &= ~(0xF0);
    190e:	88 b3       	in	r24, 0x18	; 24
    1910:	8f 70       	andi	r24, 0x0F	; 15
            PORTB |= (14<<4);
    1912:	80 6e       	ori	r24, 0xE0	; 224
    1914:	88 bb       	out	0x18, r24	; 24
    1916:	28 c0       	rjmp	.+80     	; 0x1968 <HMI_MainFunction+0xf8>
         }
         else
         {
            PORTB &= ~(0xF0);
    1918:	88 b3       	in	r24, 0x18	; 24
    191a:	8f 70       	andi	r24, 0x0F	; 15
    191c:	88 bb       	out	0x18, r24	; 24
    191e:	24 c0       	rjmp	.+72     	; 0x1968 <HMI_MainFunction+0xf8>
         }
      }
      else if(u32_Key != 0)
    1920:	61 15       	cp	r22, r1
    1922:	71 05       	cpc	r23, r1
    1924:	81 05       	cpc	r24, r1
    1926:	91 05       	cpc	r25, r1
    1928:	e1 f0       	breq	.+56     	; 0x1962 <HMI_MainFunction+0xf2>
      {
         u32_Key = (log(u32_Key)/log(2));
    192a:	0e 94 19 0f 	call	0x1e32	; 0x1e32 <__floatunsisf>
    192e:	0e 94 af 0f 	call	0x1f5e	; 0x1f5e <log>
    1932:	28 e1       	ldi	r18, 0x18	; 24
    1934:	32 e7       	ldi	r19, 0x72	; 114
    1936:	41 e3       	ldi	r20, 0x31	; 49
    1938:	5f e3       	ldi	r21, 0x3F	; 63
    193a:	0e 94 78 0e 	call	0x1cf0	; 0x1cf0 <__divsf3>
    193e:	0e 94 ea 0e 	call	0x1dd4	; 0x1dd4 <__fixunssfsi>
    1942:	69 83       	std	Y+1, r22	; 0x01
    1944:	7a 83       	std	Y+2, r23	; 0x02
    1946:	8b 83       	std	Y+3, r24	; 0x03
    1948:	9c 83       	std	Y+4, r25	; 0x04
         HMI_SetKeyPressed(u32_Key);
    194a:	86 2f       	mov	r24, r22
    194c:	0e 94 c7 0c 	call	0x198e	; 0x198e <HMI_SetKeyPressed>
         PORTB &= ~(0xF0);
    1950:	88 b3       	in	r24, 0x18	; 24
    1952:	98 2f       	mov	r25, r24
    1954:	9f 70       	andi	r25, 0x0F	; 15
         PORTB |= (u32_Key<<4);
    1956:	89 81       	ldd	r24, Y+1	; 0x01
    1958:	82 95       	swap	r24
    195a:	80 7f       	andi	r24, 0xF0	; 240
    195c:	89 2b       	or	r24, r25
    195e:	88 bb       	out	0x18, r24	; 24
    1960:	03 c0       	rjmp	.+6      	; 0x1968 <HMI_MainFunction+0xf8>
      }
      else
      {
         PORTB &= ~(0xF0);
    1962:	88 b3       	in	r24, 0x18	; 24
    1964:	8f 70       	andi	r24, 0x0F	; 15
    1966:	88 bb       	out	0x18, r24	; 24
      }
   }
    1968:	0f 90       	pop	r0
    196a:	0f 90       	pop	r0
    196c:	0f 90       	pop	r0
    196e:	0f 90       	pop	r0
    1970:	df 91       	pop	r29
    1972:	cf 91       	pop	r28
    1974:	1f 91       	pop	r17
    1976:	0f 91       	pop	r16
    1978:	08 95       	ret

0000197a <HMI_SetDeviceEraseFlag>:
*
* @return function error state.
*/
extern ERROR_STATE_t HMI_SetDeviceEraseFlag(void)
{
   gu8_DeviceEraseFlag = DEVICE_ERASE_FLAG;
    197a:	81 e0       	ldi	r24, 0x01	; 1
    197c:	80 93 5c 07 	sts	0x075C, r24	; 0x80075c <gu8_DeviceEraseFlag>
   return ERROR_OK;
}
    1980:	80 e0       	ldi	r24, 0x00	; 0
    1982:	08 95       	ret

00001984 <HMI_SetPasswordChangeFlag>:
*
* @return function error state.
*/
extern ERROR_STATE_t HMI_SetPasswordChangeFlag(void)
{
   gu8_PasswordChangeFlag = PASSWORD_CHANGE_FLAG;
    1984:	81 e0       	ldi	r24, 0x01	; 1
    1986:	80 93 5b 07 	sts	0x075B, r24	; 0x80075b <gu8_PasswordChangeFlag>
   return ERROR_OK;
}
    198a:	80 e0       	ldi	r24, 0x00	; 0
    198c:	08 95       	ret

0000198e <HMI_SetKeyPressed>:
*/
extern ERROR_STATE_t HMI_SetKeyPressed(uint8_t Value)
{
   ERROR_STATE_t HMI_ErrorState;
   
   if(INVALID_KEY_PRESSED_VALUE <= Value)
    198e:	8d 30       	cpi	r24, 0x0D	; 13
    1990:	20 f4       	brcc	.+8      	; 0x199a <HMI_SetKeyPressed+0xc>
   {
      HMI_ErrorState = (E_HMI_ID | E_HMI_INVALID_VAL);
   }
   else
   {
      gu8_KeyPressedValue = Value;
    1992:	80 93 5a 07 	sts	0x075A, r24	; 0x80075a <gu8_KeyPressedValue>
      HMI_ErrorState = ERROR_OK;
    1996:	80 e0       	ldi	r24, 0x00	; 0
    1998:	08 95       	ret
{
   ERROR_STATE_t HMI_ErrorState;
   
   if(INVALID_KEY_PRESSED_VALUE <= Value)
   {
      HMI_ErrorState = (E_HMI_ID | E_HMI_INVALID_VAL);
    199a:	82 ed       	ldi	r24, 0xD2	; 210
      gu8_KeyPressedValue = Value;
      HMI_ErrorState = ERROR_OK;
   }
   
   return HMI_ErrorState;
    199c:	08 95       	ret

0000199e <Indicator_MainFunction>:
* @brief: This function is the indicator main function.
*
* @return function error state.
*/
extern void Indicator_MainFunction(void)
{
    199e:	cf 93       	push	r28
    19a0:	df 93       	push	r29
    19a2:	00 d0       	rcall	.+0      	; 0x19a4 <Indicator_MainFunction+0x6>
    19a4:	1f 92       	push	r1
    19a6:	cd b7       	in	r28, 0x3d	; 61
    19a8:	de b7       	in	r29, 0x3e	; 62
   portTickType xLastWakeTime;
   xLastWakeTime=xTaskGetTickCount();
    19aa:	0e 94 7d 05 	call	0xafa	; 0xafa <xTaskGetTickCount>
    19ae:	9a 83       	std	Y+2, r25	; 0x02
    19b0:	89 83       	std	Y+1, r24	; 0x01
   uint8_t u8_Pattern;
   static uint8_t u8_OldPattern = INDICATOR_INVALID_PATTERN;
   static Enu_IndicatorStateMachine State = Indicator_LowTime;
   static uint8_t u8_Duty = 0;
   
   if (u8_Init == 0)
    19b2:	80 91 5f 07 	lds	r24, 0x075F	; 0x80075f <u8_Init.1970>
    19b6:	81 11       	cpse	r24, r1
    19b8:	0a c0       	rjmp	.+20     	; 0x19ce <Indicator_MainFunction+0x30>
   {
      Indicator_SetPattern(INDICATOR_SEARCH_PATTERN);
    19ba:	81 e0       	ldi	r24, 0x01	; 1
    19bc:	0e 94 8b 0d 	call	0x1b16	; 0x1b16 <Indicator_SetPattern>
      LED_Init(LED_UsedChannel);
    19c0:	80 91 cf 00 	lds	r24, 0x00CF	; 0x8000cf <LED_UsedChannel>
    19c4:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <LED_Init>
      u8_Init = 1;
    19c8:	81 e0       	ldi	r24, 0x01	; 1
    19ca:	80 93 5f 07 	sts	0x075F, r24	; 0x80075f <u8_Init.1970>
   }
   
   Indicator_GetPattern(&u8_Pattern);
    19ce:	ce 01       	movw	r24, r28
    19d0:	03 96       	adiw	r24, 0x03	; 3
    19d2:	0e 94 81 0d 	call	0x1b02	; 0x1b02 <Indicator_GetPattern>
   
   if( u8_Pattern != u8_OldPattern)
    19d6:	eb 81       	ldd	r30, Y+3	; 0x03
    19d8:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    19dc:	e8 17       	cp	r30, r24
    19de:	31 f0       	breq	.+12     	; 0x19ec <Indicator_MainFunction+0x4e>
   {
      u8_OldPattern = u8_Pattern;
    19e0:	e0 93 60 00 	sts	0x0060, r30	; 0x800060 <__DATA_REGION_ORIGIN__>
      State = Indicator_LowTime;
    19e4:	10 92 5e 07 	sts	0x075E, r1	; 0x80075e <State.1973>
      u8_Duty = 0;
    19e8:	10 92 5d 07 	sts	0x075D, r1	; 0x80075d <u8_Duty.1974>
   }
   
   if(INDICATOR_INVALID_PATTERN != u8_Pattern)
    19ec:	e4 30       	cpi	r30, 0x04	; 4
    19ee:	09 f4       	brne	.+2      	; 0x19f2 <Indicator_MainFunction+0x54>
    19f0:	82 c0       	rjmp	.+260    	; 0x1af6 <Indicator_MainFunction+0x158>
   {
      switch(State)
    19f2:	80 91 5e 07 	lds	r24, 0x075E	; 0x80075e <State.1973>
    19f6:	81 30       	cpi	r24, 0x01	; 1
    19f8:	f9 f0       	breq	.+62     	; 0x1a38 <Indicator_MainFunction+0x9a>
    19fa:	38 f0       	brcs	.+14     	; 0x1a0a <Indicator_MainFunction+0x6c>
    19fc:	82 30       	cpi	r24, 0x02	; 2
    19fe:	09 f4       	brne	.+2      	; 0x1a02 <Indicator_MainFunction+0x64>
    1a00:	40 c0       	rjmp	.+128    	; 0x1a82 <Indicator_MainFunction+0xe4>
    1a02:	83 30       	cpi	r24, 0x03	; 3
    1a04:	09 f4       	brne	.+2      	; 0x1a08 <Indicator_MainFunction+0x6a>
    1a06:	54 c0       	rjmp	.+168    	; 0x1ab0 <Indicator_MainFunction+0x112>
    1a08:	76 c0       	rjmp	.+236    	; 0x1af6 <Indicator_MainFunction+0x158>
      {
         case Indicator_LowTime:
            LED_Off(LED_UsedChannel);
    1a0a:	80 91 cf 00 	lds	r24, 0x00CF	; 0x8000cf <LED_UsedChannel>
    1a0e:	0e 94 d2 08 	call	0x11a4	; 0x11a4 <LED_Off>
            State = Indicator_RiseTime;
    1a12:	81 e0       	ldi	r24, 0x01	; 1
    1a14:	80 93 5e 07 	sts	0x075E, r24	; 0x80075e <State.1973>
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u32_LowTime);
    1a18:	eb 81       	ldd	r30, Y+3	; 0x03
    1a1a:	86 e1       	ldi	r24, 0x16	; 22
    1a1c:	e8 9f       	mul	r30, r24
    1a1e:	f0 01       	movw	r30, r0
    1a20:	11 24       	eor	r1, r1
    1a22:	e9 58       	subi	r30, 0x89	; 137
    1a24:	ff 4f       	sbci	r31, 0xFF	; 255
    1a26:	60 89       	ldd	r22, Z+16	; 0x10
    1a28:	71 89       	ldd	r23, Z+17	; 0x11
    1a2a:	82 89       	ldd	r24, Z+18	; 0x12
    1a2c:	93 89       	ldd	r25, Z+19	; 0x13
    1a2e:	ce 01       	movw	r24, r28
    1a30:	01 96       	adiw	r24, 0x01	; 1
    1a32:	0e 94 b3 06 	call	0xd66	; 0xd66 <vTaskDelayUntil>
            break;
    1a36:	5f c0       	rjmp	.+190    	; 0x1af6 <Indicator_MainFunction+0x158>
         case Indicator_RiseTime:
            u8_Duty += aSTR_IndicatorConfig[u8_Pattern].u8_RateOfChange;
    1a38:	86 e1       	ldi	r24, 0x16	; 22
    1a3a:	e8 9f       	mul	r30, r24
    1a3c:	f0 01       	movw	r30, r0
    1a3e:	11 24       	eor	r1, r1
    1a40:	e9 58       	subi	r30, 0x89	; 137
    1a42:	ff 4f       	sbci	r31, 0xFF	; 255
    1a44:	65 89       	ldd	r22, Z+21	; 0x15
    1a46:	80 91 5d 07 	lds	r24, 0x075D	; 0x80075d <u8_Duty.1974>
    1a4a:	68 0f       	add	r22, r24
    1a4c:	60 93 5d 07 	sts	0x075D, r22	; 0x80075d <u8_Duty.1974>
            LED_Dim(LED_UsedChannel, u8_Duty);
    1a50:	80 91 cf 00 	lds	r24, 0x00CF	; 0x8000cf <LED_UsedChannel>
    1a54:	0e 94 4e 09 	call	0x129c	; 0x129c <LED_Dim>
            if(u8_Duty == 100)
    1a58:	80 91 5d 07 	lds	r24, 0x075D	; 0x80075d <u8_Duty.1974>
    1a5c:	84 36       	cpi	r24, 0x64	; 100
    1a5e:	19 f4       	brne	.+6      	; 0x1a66 <Indicator_MainFunction+0xc8>
            {
               State = Indicator_HighTime;
    1a60:	82 e0       	ldi	r24, 0x02	; 2
    1a62:	80 93 5e 07 	sts	0x075E, r24	; 0x80075e <State.1973>
            }
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u8_StepTime);
    1a66:	eb 81       	ldd	r30, Y+3	; 0x03
    1a68:	86 e1       	ldi	r24, 0x16	; 22
    1a6a:	e8 9f       	mul	r30, r24
    1a6c:	f0 01       	movw	r30, r0
    1a6e:	11 24       	eor	r1, r1
    1a70:	e9 58       	subi	r30, 0x89	; 137
    1a72:	ff 4f       	sbci	r31, 0xFF	; 255
    1a74:	64 89       	ldd	r22, Z+20	; 0x14
    1a76:	70 e0       	ldi	r23, 0x00	; 0
    1a78:	ce 01       	movw	r24, r28
    1a7a:	01 96       	adiw	r24, 0x01	; 1
    1a7c:	0e 94 b3 06 	call	0xd66	; 0xd66 <vTaskDelayUntil>
            break;
    1a80:	3a c0       	rjmp	.+116    	; 0x1af6 <Indicator_MainFunction+0x158>
         case Indicator_HighTime:
            LED_On(LED_UsedChannel);
    1a82:	80 91 cf 00 	lds	r24, 0x00CF	; 0x8000cf <LED_UsedChannel>
    1a86:	0e 94 10 09 	call	0x1220	; 0x1220 <LED_On>
            State = Indicator_FallTime;
    1a8a:	83 e0       	ldi	r24, 0x03	; 3
    1a8c:	80 93 5e 07 	sts	0x075E, r24	; 0x80075e <State.1973>
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u32_HighTime);
    1a90:	eb 81       	ldd	r30, Y+3	; 0x03
    1a92:	86 e1       	ldi	r24, 0x16	; 22
    1a94:	e8 9f       	mul	r30, r24
    1a96:	f0 01       	movw	r30, r0
    1a98:	11 24       	eor	r1, r1
    1a9a:	e9 58       	subi	r30, 0x89	; 137
    1a9c:	ff 4f       	sbci	r31, 0xFF	; 255
    1a9e:	64 81       	ldd	r22, Z+4	; 0x04
    1aa0:	75 81       	ldd	r23, Z+5	; 0x05
    1aa2:	86 81       	ldd	r24, Z+6	; 0x06
    1aa4:	97 81       	ldd	r25, Z+7	; 0x07
    1aa6:	ce 01       	movw	r24, r28
    1aa8:	01 96       	adiw	r24, 0x01	; 1
    1aaa:	0e 94 b3 06 	call	0xd66	; 0xd66 <vTaskDelayUntil>
            break;
    1aae:	23 c0       	rjmp	.+70     	; 0x1af6 <Indicator_MainFunction+0x158>
         case Indicator_FallTime:
            u8_Duty -= aSTR_IndicatorConfig[u8_Pattern].u8_RateOfChange;
    1ab0:	86 e1       	ldi	r24, 0x16	; 22
    1ab2:	e8 9f       	mul	r30, r24
    1ab4:	f0 01       	movw	r30, r0
    1ab6:	11 24       	eor	r1, r1
    1ab8:	e9 58       	subi	r30, 0x89	; 137
    1aba:	ff 4f       	sbci	r31, 0xFF	; 255
    1abc:	85 89       	ldd	r24, Z+21	; 0x15
    1abe:	60 91 5d 07 	lds	r22, 0x075D	; 0x80075d <u8_Duty.1974>
    1ac2:	68 1b       	sub	r22, r24
    1ac4:	60 93 5d 07 	sts	0x075D, r22	; 0x80075d <u8_Duty.1974>
            LED_Dim(LED_UsedChannel, u8_Duty);
    1ac8:	80 91 cf 00 	lds	r24, 0x00CF	; 0x8000cf <LED_UsedChannel>
    1acc:	0e 94 4e 09 	call	0x129c	; 0x129c <LED_Dim>
            if(u8_Duty == 0)
    1ad0:	80 91 5d 07 	lds	r24, 0x075D	; 0x80075d <u8_Duty.1974>
    1ad4:	81 11       	cpse	r24, r1
    1ad6:	02 c0       	rjmp	.+4      	; 0x1adc <Indicator_MainFunction+0x13e>
            {
               State = Indicator_LowTime;
    1ad8:	10 92 5e 07 	sts	0x075E, r1	; 0x80075e <State.1973>
            }
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u8_StepTime);
    1adc:	eb 81       	ldd	r30, Y+3	; 0x03
    1ade:	86 e1       	ldi	r24, 0x16	; 22
    1ae0:	e8 9f       	mul	r30, r24
    1ae2:	f0 01       	movw	r30, r0
    1ae4:	11 24       	eor	r1, r1
    1ae6:	e9 58       	subi	r30, 0x89	; 137
    1ae8:	ff 4f       	sbci	r31, 0xFF	; 255
    1aea:	64 89       	ldd	r22, Z+20	; 0x14
    1aec:	70 e0       	ldi	r23, 0x00	; 0
    1aee:	ce 01       	movw	r24, r28
    1af0:	01 96       	adiw	r24, 0x01	; 1
    1af2:	0e 94 b3 06 	call	0xd66	; 0xd66 <vTaskDelayUntil>
            break;
      }
   }
    1af6:	0f 90       	pop	r0
    1af8:	0f 90       	pop	r0
    1afa:	0f 90       	pop	r0
    1afc:	df 91       	pop	r29
    1afe:	cf 91       	pop	r28
    1b00:	08 95       	ret

00001b02 <Indicator_GetPattern>:
*/
extern ERROR_STATE_t Indicator_GetPattern(uint8_t * Value)
{
   ERROR_STATE_t Indicator_ErrorState;
   
   if(NULL_PTR == Value)
    1b02:	00 97       	sbiw	r24, 0x00	; 0
    1b04:	31 f0       	breq	.+12     	; 0x1b12 <Indicator_GetPattern+0x10>
   {
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_NULL_PTR);
   }
   else
   {
      *Value = gu8_IndicatorPattern;
    1b06:	20 91 61 00 	lds	r18, 0x0061	; 0x800061 <gu8_IndicatorPattern>
    1b0a:	fc 01       	movw	r30, r24
    1b0c:	20 83       	st	Z, r18
      Indicator_ErrorState = ERROR_OK;
    1b0e:	80 e0       	ldi	r24, 0x00	; 0
    1b10:	08 95       	ret
{
   ERROR_STATE_t Indicator_ErrorState;
   
   if(NULL_PTR == Value)
   {
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_NULL_PTR);
    1b12:	82 eb       	ldi	r24, 0xB2	; 178
      *Value = gu8_IndicatorPattern;
      Indicator_ErrorState = ERROR_OK;
   }
   
   return Indicator_ErrorState;
}
    1b14:	08 95       	ret

00001b16 <Indicator_SetPattern>:
*/
extern ERROR_STATE_t Indicator_SetPattern(uint8_t Value)
{
   ERROR_STATE_t Indicator_ErrorState;
   
   if(INDICATOR_INVALID_PATTERN <= Value)
    1b16:	84 30       	cpi	r24, 0x04	; 4
    1b18:	20 f4       	brcc	.+8      	; 0x1b22 <Indicator_SetPattern+0xc>
   {
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_INVALID_VAL);
   }
   else
   {
      gu8_IndicatorPattern = Value;
    1b1a:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <gu8_IndicatorPattern>
      Indicator_ErrorState = ERROR_OK;
    1b1e:	80 e0       	ldi	r24, 0x00	; 0
    1b20:	08 95       	ret
{
   ERROR_STATE_t Indicator_ErrorState;
   
   if(INDICATOR_INVALID_PATTERN <= Value)
   {
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_INVALID_VAL);
    1b22:	81 eb       	ldi	r24, 0xB1	; 177
      gu8_IndicatorPattern = Value;
      Indicator_ErrorState = ERROR_OK;
   }
   
   return Indicator_ErrorState;
    1b24:	08 95       	ret

00001b26 <HMI_Task>:
#include "Indicator.h"
#include "FreeRTOS.h"
#include "task.h"

void HMI_Task( void *pvParameters )
{
    1b26:	cf 93       	push	r28
    1b28:	df 93       	push	r29
    1b2a:	00 d0       	rcall	.+0      	; 0x1b2c <HMI_Task+0x6>
    1b2c:	cd b7       	in	r28, 0x3d	; 61
    1b2e:	de b7       	in	r29, 0x3e	; 62
   portTickType xLastWakeTime;
   xLastWakeTime=xTaskGetTickCount();
    1b30:	0e 94 7d 05 	call	0xafa	; 0xafa <xTaskGetTickCount>
    1b34:	9a 83       	std	Y+2, r25	; 0x02
    1b36:	89 83       	std	Y+1, r24	; 0x01
   
   for( ;; )
   {
      HMI_MainFunction();
    1b38:	0e 94 38 0c 	call	0x1870	; 0x1870 <HMI_MainFunction>
      vTaskDelayUntil(&xLastWakeTime, 50);
    1b3c:	62 e3       	ldi	r22, 0x32	; 50
    1b3e:	70 e0       	ldi	r23, 0x00	; 0
    1b40:	ce 01       	movw	r24, r28
    1b42:	01 96       	adiw	r24, 0x01	; 1
    1b44:	0e 94 b3 06 	call	0xd66	; 0xd66 <vTaskDelayUntil>
    1b48:	f7 cf       	rjmp	.-18     	; 0x1b38 <HMI_Task+0x12>

00001b4a <Feedback_Task>:

void Feedback_Task( void *pvParameters )
{  
   for( ;; )
   {
      Indicator_MainFunction();
    1b4a:	0e 94 cf 0c 	call	0x199e	; 0x199e <Indicator_MainFunction>
    1b4e:	fd cf       	rjmp	.-6      	; 0x1b4a <Feedback_Task>

00001b50 <Display_Task>:
   }
}

void Display_Task( void *pvParameters )
{
    1b50:	cf 93       	push	r28
    1b52:	df 93       	push	r29
    1b54:	00 d0       	rcall	.+0      	; 0x1b56 <Display_Task+0x6>
    1b56:	cd b7       	in	r28, 0x3d	; 61
    1b58:	de b7       	in	r29, 0x3e	; 62
   portTickType xLastWakeTime;
   xLastWakeTime=xTaskGetTickCount();
    1b5a:	0e 94 7d 05 	call	0xafa	; 0xafa <xTaskGetTickCount>
    1b5e:	9a 83       	std	Y+2, r25	; 0x02
    1b60:	89 83       	std	Y+1, r24	; 0x01
   
   for( ;; )
   {
      Display_MainFunction();
    1b62:	0e 94 d9 0b 	call	0x17b2	; 0x17b2 <Display_MainFunction>
      vTaskDelayUntil(&xLastWakeTime, 10);
    1b66:	6a e0       	ldi	r22, 0x0A	; 10
    1b68:	70 e0       	ldi	r23, 0x00	; 0
    1b6a:	ce 01       	movw	r24, r28
    1b6c:	01 96       	adiw	r24, 0x01	; 1
    1b6e:	0e 94 b3 06 	call	0xd66	; 0xd66 <vTaskDelayUntil>
    1b72:	f7 cf       	rjmp	.-18     	; 0x1b62 <Display_Task+0x12>

00001b74 <NumberChange_Task>:
   }
}

#include "Display_Interface.h"
void NumberChange_Task( void *pvParameters )
{
    1b74:	cf 93       	push	r28
    1b76:	df 93       	push	r29
    1b78:	00 d0       	rcall	.+0      	; 0x1b7a <NumberChange_Task+0x6>
    1b7a:	cd b7       	in	r28, 0x3d	; 61
    1b7c:	de b7       	in	r29, 0x3e	; 62
   portTickType xLastWakeTime;
   xLastWakeTime=xTaskGetTickCount();
    1b7e:	0e 94 7d 05 	call	0xafa	; 0xafa <xTaskGetTickCount>
    1b82:	9a 83       	std	Y+2, r25	; 0x02
    1b84:	89 83       	std	Y+1, r24	; 0x01
   
   static uint8_t Number = 1;
   vTaskDelayUntil(&xLastWakeTime, 100);
    1b86:	64 e6       	ldi	r22, 0x64	; 100
    1b88:	70 e0       	ldi	r23, 0x00	; 0
    1b8a:	ce 01       	movw	r24, r28
    1b8c:	01 96       	adiw	r24, 0x01	; 1
    1b8e:	0e 94 b3 06 	call	0xd66	; 0xd66 <vTaskDelayUntil>
   for( ;; )
   {
      Display_SetSevenSegment(Number);
    1b92:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <Number.1965>
    1b96:	0e 94 30 0c 	call	0x1860	; 0x1860 <Display_SetSevenSegment>
      Number++;
    1b9a:	80 91 62 00 	lds	r24, 0x0062	; 0x800062 <Number.1965>
    1b9e:	8f 5f       	subi	r24, 0xFF	; 255
    1ba0:	80 93 62 00 	sts	0x0062, r24	; 0x800062 <Number.1965>
      if(Number > 99)
    1ba4:	84 36       	cpi	r24, 0x64	; 100
    1ba6:	10 f0       	brcs	.+4      	; 0x1bac <NumberChange_Task+0x38>
      {
         Number = 0;
    1ba8:	10 92 62 00 	sts	0x0062, r1	; 0x800062 <Number.1965>
      }
      vTaskDelayUntil(&xLastWakeTime, 100);
    1bac:	64 e6       	ldi	r22, 0x64	; 100
    1bae:	70 e0       	ldi	r23, 0x00	; 0
    1bb0:	ce 01       	movw	r24, r28
    1bb2:	01 96       	adiw	r24, 0x01	; 1
    1bb4:	0e 94 b3 06 	call	0xd66	; 0xd66 <vTaskDelayUntil>
   }
    1bb8:	ec cf       	rjmp	.-40     	; 0x1b92 <NumberChange_Task+0x1e>

00001bba <main>:
}

int main(void)
{   
   xTaskCreate( HMI_Task, "HMI", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );
    1bba:	e1 2c       	mov	r14, r1
    1bbc:	f1 2c       	mov	r15, r1
    1bbe:	01 e0       	ldi	r16, 0x01	; 1
    1bc0:	20 e0       	ldi	r18, 0x00	; 0
    1bc2:	30 e0       	ldi	r19, 0x00	; 0
    1bc4:	45 e5       	ldi	r20, 0x55	; 85
    1bc6:	50 e0       	ldi	r21, 0x00	; 0
    1bc8:	6e ee       	ldi	r22, 0xEE	; 238
    1bca:	70 e0       	ldi	r23, 0x00	; 0
    1bcc:	83 e9       	ldi	r24, 0x93	; 147
    1bce:	9d e0       	ldi	r25, 0x0D	; 13
    1bd0:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskCreate>
   xTaskCreate( Feedback_Task, "Indicator", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );
    1bd4:	20 e0       	ldi	r18, 0x00	; 0
    1bd6:	30 e0       	ldi	r19, 0x00	; 0
    1bd8:	45 e5       	ldi	r20, 0x55	; 85
    1bda:	50 e0       	ldi	r21, 0x00	; 0
    1bdc:	62 ef       	ldi	r22, 0xF2	; 242
    1bde:	70 e0       	ldi	r23, 0x00	; 0
    1be0:	85 ea       	ldi	r24, 0xA5	; 165
    1be2:	9d e0       	ldi	r25, 0x0D	; 13
    1be4:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskCreate>
   xTaskCreate( Display_Task, "SevenSegment", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );
    1be8:	20 e0       	ldi	r18, 0x00	; 0
    1bea:	30 e0       	ldi	r19, 0x00	; 0
    1bec:	45 e5       	ldi	r20, 0x55	; 85
    1bee:	50 e0       	ldi	r21, 0x00	; 0
    1bf0:	6c ef       	ldi	r22, 0xFC	; 252
    1bf2:	70 e0       	ldi	r23, 0x00	; 0
    1bf4:	88 ea       	ldi	r24, 0xA8	; 168
    1bf6:	9d e0       	ldi	r25, 0x0D	; 13
    1bf8:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskCreate>
   xTaskCreate( NumberChange_Task, "number", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );
    1bfc:	20 e0       	ldi	r18, 0x00	; 0
    1bfe:	30 e0       	ldi	r19, 0x00	; 0
    1c00:	45 e5       	ldi	r20, 0x55	; 85
    1c02:	50 e0       	ldi	r21, 0x00	; 0
    1c04:	69 e0       	ldi	r22, 0x09	; 9
    1c06:	71 e0       	ldi	r23, 0x01	; 1
    1c08:	8a eb       	ldi	r24, 0xBA	; 186
    1c0a:	9d e0       	ldi	r25, 0x0D	; 13
    1c0c:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskCreate>
   
   vTaskStartScheduler();
    1c10:	0e 94 4d 05 	call	0xa9a	; 0xa9a <vTaskStartScheduler>
    1c14:	ff cf       	rjmp	.-2      	; 0x1c14 <main+0x5a>

00001c16 <__subsf3>:
    1c16:	50 58       	subi	r21, 0x80	; 128

00001c18 <__addsf3>:
    1c18:	bb 27       	eor	r27, r27
    1c1a:	aa 27       	eor	r26, r26
    1c1c:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <__addsf3x>
    1c20:	0c 94 6d 0f 	jmp	0x1eda	; 0x1eda <__fp_round>
    1c24:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <__fp_pscA>
    1c28:	38 f0       	brcs	.+14     	; 0x1c38 <__addsf3+0x20>
    1c2a:	0e 94 66 0f 	call	0x1ecc	; 0x1ecc <__fp_pscB>
    1c2e:	20 f0       	brcs	.+8      	; 0x1c38 <__addsf3+0x20>
    1c30:	39 f4       	brne	.+14     	; 0x1c40 <__addsf3+0x28>
    1c32:	9f 3f       	cpi	r25, 0xFF	; 255
    1c34:	19 f4       	brne	.+6      	; 0x1c3c <__addsf3+0x24>
    1c36:	26 f4       	brtc	.+8      	; 0x1c40 <__addsf3+0x28>
    1c38:	0c 94 5c 0f 	jmp	0x1eb8	; 0x1eb8 <__fp_nan>
    1c3c:	0e f4       	brtc	.+2      	; 0x1c40 <__addsf3+0x28>
    1c3e:	e0 95       	com	r30
    1c40:	e7 fb       	bst	r30, 7
    1c42:	0c 94 56 0f 	jmp	0x1eac	; 0x1eac <__fp_inf>

00001c46 <__addsf3x>:
    1c46:	e9 2f       	mov	r30, r25
    1c48:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <__fp_split3>
    1c4c:	58 f3       	brcs	.-42     	; 0x1c24 <__addsf3+0xc>
    1c4e:	ba 17       	cp	r27, r26
    1c50:	62 07       	cpc	r22, r18
    1c52:	73 07       	cpc	r23, r19
    1c54:	84 07       	cpc	r24, r20
    1c56:	95 07       	cpc	r25, r21
    1c58:	20 f0       	brcs	.+8      	; 0x1c62 <__addsf3x+0x1c>
    1c5a:	79 f4       	brne	.+30     	; 0x1c7a <__addsf3x+0x34>
    1c5c:	a6 f5       	brtc	.+104    	; 0x1cc6 <__addsf3x+0x80>
    1c5e:	0c 94 a0 0f 	jmp	0x1f40	; 0x1f40 <__fp_zero>
    1c62:	0e f4       	brtc	.+2      	; 0x1c66 <__addsf3x+0x20>
    1c64:	e0 95       	com	r30
    1c66:	0b 2e       	mov	r0, r27
    1c68:	ba 2f       	mov	r27, r26
    1c6a:	a0 2d       	mov	r26, r0
    1c6c:	0b 01       	movw	r0, r22
    1c6e:	b9 01       	movw	r22, r18
    1c70:	90 01       	movw	r18, r0
    1c72:	0c 01       	movw	r0, r24
    1c74:	ca 01       	movw	r24, r20
    1c76:	a0 01       	movw	r20, r0
    1c78:	11 24       	eor	r1, r1
    1c7a:	ff 27       	eor	r31, r31
    1c7c:	59 1b       	sub	r21, r25
    1c7e:	99 f0       	breq	.+38     	; 0x1ca6 <__addsf3x+0x60>
    1c80:	59 3f       	cpi	r21, 0xF9	; 249
    1c82:	50 f4       	brcc	.+20     	; 0x1c98 <__addsf3x+0x52>
    1c84:	50 3e       	cpi	r21, 0xE0	; 224
    1c86:	68 f1       	brcs	.+90     	; 0x1ce2 <__addsf3x+0x9c>
    1c88:	1a 16       	cp	r1, r26
    1c8a:	f0 40       	sbci	r31, 0x00	; 0
    1c8c:	a2 2f       	mov	r26, r18
    1c8e:	23 2f       	mov	r18, r19
    1c90:	34 2f       	mov	r19, r20
    1c92:	44 27       	eor	r20, r20
    1c94:	58 5f       	subi	r21, 0xF8	; 248
    1c96:	f3 cf       	rjmp	.-26     	; 0x1c7e <__addsf3x+0x38>
    1c98:	46 95       	lsr	r20
    1c9a:	37 95       	ror	r19
    1c9c:	27 95       	ror	r18
    1c9e:	a7 95       	ror	r26
    1ca0:	f0 40       	sbci	r31, 0x00	; 0
    1ca2:	53 95       	inc	r21
    1ca4:	c9 f7       	brne	.-14     	; 0x1c98 <__addsf3x+0x52>
    1ca6:	7e f4       	brtc	.+30     	; 0x1cc6 <__addsf3x+0x80>
    1ca8:	1f 16       	cp	r1, r31
    1caa:	ba 0b       	sbc	r27, r26
    1cac:	62 0b       	sbc	r22, r18
    1cae:	73 0b       	sbc	r23, r19
    1cb0:	84 0b       	sbc	r24, r20
    1cb2:	ba f0       	brmi	.+46     	; 0x1ce2 <__addsf3x+0x9c>
    1cb4:	91 50       	subi	r25, 0x01	; 1
    1cb6:	a1 f0       	breq	.+40     	; 0x1ce0 <__addsf3x+0x9a>
    1cb8:	ff 0f       	add	r31, r31
    1cba:	bb 1f       	adc	r27, r27
    1cbc:	66 1f       	adc	r22, r22
    1cbe:	77 1f       	adc	r23, r23
    1cc0:	88 1f       	adc	r24, r24
    1cc2:	c2 f7       	brpl	.-16     	; 0x1cb4 <__addsf3x+0x6e>
    1cc4:	0e c0       	rjmp	.+28     	; 0x1ce2 <__addsf3x+0x9c>
    1cc6:	ba 0f       	add	r27, r26
    1cc8:	62 1f       	adc	r22, r18
    1cca:	73 1f       	adc	r23, r19
    1ccc:	84 1f       	adc	r24, r20
    1cce:	48 f4       	brcc	.+18     	; 0x1ce2 <__addsf3x+0x9c>
    1cd0:	87 95       	ror	r24
    1cd2:	77 95       	ror	r23
    1cd4:	67 95       	ror	r22
    1cd6:	b7 95       	ror	r27
    1cd8:	f7 95       	ror	r31
    1cda:	9e 3f       	cpi	r25, 0xFE	; 254
    1cdc:	08 f0       	brcs	.+2      	; 0x1ce0 <__addsf3x+0x9a>
    1cde:	b0 cf       	rjmp	.-160    	; 0x1c40 <__addsf3+0x28>
    1ce0:	93 95       	inc	r25
    1ce2:	88 0f       	add	r24, r24
    1ce4:	08 f0       	brcs	.+2      	; 0x1ce8 <__addsf3x+0xa2>
    1ce6:	99 27       	eor	r25, r25
    1ce8:	ee 0f       	add	r30, r30
    1cea:	97 95       	ror	r25
    1cec:	87 95       	ror	r24
    1cee:	08 95       	ret

00001cf0 <__divsf3>:
    1cf0:	0e 94 8c 0e 	call	0x1d18	; 0x1d18 <__divsf3x>
    1cf4:	0c 94 6d 0f 	jmp	0x1eda	; 0x1eda <__fp_round>
    1cf8:	0e 94 66 0f 	call	0x1ecc	; 0x1ecc <__fp_pscB>
    1cfc:	58 f0       	brcs	.+22     	; 0x1d14 <__divsf3+0x24>
    1cfe:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <__fp_pscA>
    1d02:	40 f0       	brcs	.+16     	; 0x1d14 <__divsf3+0x24>
    1d04:	29 f4       	brne	.+10     	; 0x1d10 <__divsf3+0x20>
    1d06:	5f 3f       	cpi	r21, 0xFF	; 255
    1d08:	29 f0       	breq	.+10     	; 0x1d14 <__divsf3+0x24>
    1d0a:	0c 94 56 0f 	jmp	0x1eac	; 0x1eac <__fp_inf>
    1d0e:	51 11       	cpse	r21, r1
    1d10:	0c 94 a1 0f 	jmp	0x1f42	; 0x1f42 <__fp_szero>
    1d14:	0c 94 5c 0f 	jmp	0x1eb8	; 0x1eb8 <__fp_nan>

00001d18 <__divsf3x>:
    1d18:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <__fp_split3>
    1d1c:	68 f3       	brcs	.-38     	; 0x1cf8 <__divsf3+0x8>

00001d1e <__divsf3_pse>:
    1d1e:	99 23       	and	r25, r25
    1d20:	b1 f3       	breq	.-20     	; 0x1d0e <__divsf3+0x1e>
    1d22:	55 23       	and	r21, r21
    1d24:	91 f3       	breq	.-28     	; 0x1d0a <__divsf3+0x1a>
    1d26:	95 1b       	sub	r25, r21
    1d28:	55 0b       	sbc	r21, r21
    1d2a:	bb 27       	eor	r27, r27
    1d2c:	aa 27       	eor	r26, r26
    1d2e:	62 17       	cp	r22, r18
    1d30:	73 07       	cpc	r23, r19
    1d32:	84 07       	cpc	r24, r20
    1d34:	38 f0       	brcs	.+14     	; 0x1d44 <__divsf3_pse+0x26>
    1d36:	9f 5f       	subi	r25, 0xFF	; 255
    1d38:	5f 4f       	sbci	r21, 0xFF	; 255
    1d3a:	22 0f       	add	r18, r18
    1d3c:	33 1f       	adc	r19, r19
    1d3e:	44 1f       	adc	r20, r20
    1d40:	aa 1f       	adc	r26, r26
    1d42:	a9 f3       	breq	.-22     	; 0x1d2e <__divsf3_pse+0x10>
    1d44:	35 d0       	rcall	.+106    	; 0x1db0 <__divsf3_pse+0x92>
    1d46:	0e 2e       	mov	r0, r30
    1d48:	3a f0       	brmi	.+14     	; 0x1d58 <__divsf3_pse+0x3a>
    1d4a:	e0 e8       	ldi	r30, 0x80	; 128
    1d4c:	32 d0       	rcall	.+100    	; 0x1db2 <__divsf3_pse+0x94>
    1d4e:	91 50       	subi	r25, 0x01	; 1
    1d50:	50 40       	sbci	r21, 0x00	; 0
    1d52:	e6 95       	lsr	r30
    1d54:	00 1c       	adc	r0, r0
    1d56:	ca f7       	brpl	.-14     	; 0x1d4a <__divsf3_pse+0x2c>
    1d58:	2b d0       	rcall	.+86     	; 0x1db0 <__divsf3_pse+0x92>
    1d5a:	fe 2f       	mov	r31, r30
    1d5c:	29 d0       	rcall	.+82     	; 0x1db0 <__divsf3_pse+0x92>
    1d5e:	66 0f       	add	r22, r22
    1d60:	77 1f       	adc	r23, r23
    1d62:	88 1f       	adc	r24, r24
    1d64:	bb 1f       	adc	r27, r27
    1d66:	26 17       	cp	r18, r22
    1d68:	37 07       	cpc	r19, r23
    1d6a:	48 07       	cpc	r20, r24
    1d6c:	ab 07       	cpc	r26, r27
    1d6e:	b0 e8       	ldi	r27, 0x80	; 128
    1d70:	09 f0       	breq	.+2      	; 0x1d74 <__divsf3_pse+0x56>
    1d72:	bb 0b       	sbc	r27, r27
    1d74:	80 2d       	mov	r24, r0
    1d76:	bf 01       	movw	r22, r30
    1d78:	ff 27       	eor	r31, r31
    1d7a:	93 58       	subi	r25, 0x83	; 131
    1d7c:	5f 4f       	sbci	r21, 0xFF	; 255
    1d7e:	3a f0       	brmi	.+14     	; 0x1d8e <__divsf3_pse+0x70>
    1d80:	9e 3f       	cpi	r25, 0xFE	; 254
    1d82:	51 05       	cpc	r21, r1
    1d84:	78 f0       	brcs	.+30     	; 0x1da4 <__divsf3_pse+0x86>
    1d86:	0c 94 56 0f 	jmp	0x1eac	; 0x1eac <__fp_inf>
    1d8a:	0c 94 a1 0f 	jmp	0x1f42	; 0x1f42 <__fp_szero>
    1d8e:	5f 3f       	cpi	r21, 0xFF	; 255
    1d90:	e4 f3       	brlt	.-8      	; 0x1d8a <__divsf3_pse+0x6c>
    1d92:	98 3e       	cpi	r25, 0xE8	; 232
    1d94:	d4 f3       	brlt	.-12     	; 0x1d8a <__divsf3_pse+0x6c>
    1d96:	86 95       	lsr	r24
    1d98:	77 95       	ror	r23
    1d9a:	67 95       	ror	r22
    1d9c:	b7 95       	ror	r27
    1d9e:	f7 95       	ror	r31
    1da0:	9f 5f       	subi	r25, 0xFF	; 255
    1da2:	c9 f7       	brne	.-14     	; 0x1d96 <__divsf3_pse+0x78>
    1da4:	88 0f       	add	r24, r24
    1da6:	91 1d       	adc	r25, r1
    1da8:	96 95       	lsr	r25
    1daa:	87 95       	ror	r24
    1dac:	97 f9       	bld	r25, 7
    1dae:	08 95       	ret
    1db0:	e1 e0       	ldi	r30, 0x01	; 1
    1db2:	66 0f       	add	r22, r22
    1db4:	77 1f       	adc	r23, r23
    1db6:	88 1f       	adc	r24, r24
    1db8:	bb 1f       	adc	r27, r27
    1dba:	62 17       	cp	r22, r18
    1dbc:	73 07       	cpc	r23, r19
    1dbe:	84 07       	cpc	r24, r20
    1dc0:	ba 07       	cpc	r27, r26
    1dc2:	20 f0       	brcs	.+8      	; 0x1dcc <__divsf3_pse+0xae>
    1dc4:	62 1b       	sub	r22, r18
    1dc6:	73 0b       	sbc	r23, r19
    1dc8:	84 0b       	sbc	r24, r20
    1dca:	ba 0b       	sbc	r27, r26
    1dcc:	ee 1f       	adc	r30, r30
    1dce:	88 f7       	brcc	.-30     	; 0x1db2 <__divsf3_pse+0x94>
    1dd0:	e0 95       	com	r30
    1dd2:	08 95       	ret

00001dd4 <__fixunssfsi>:
    1dd4:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <__fp_splitA>
    1dd8:	88 f0       	brcs	.+34     	; 0x1dfc <__fixunssfsi+0x28>
    1dda:	9f 57       	subi	r25, 0x7F	; 127
    1ddc:	98 f0       	brcs	.+38     	; 0x1e04 <__fixunssfsi+0x30>
    1dde:	b9 2f       	mov	r27, r25
    1de0:	99 27       	eor	r25, r25
    1de2:	b7 51       	subi	r27, 0x17	; 23
    1de4:	b0 f0       	brcs	.+44     	; 0x1e12 <__fixunssfsi+0x3e>
    1de6:	e1 f0       	breq	.+56     	; 0x1e20 <__fixunssfsi+0x4c>
    1de8:	66 0f       	add	r22, r22
    1dea:	77 1f       	adc	r23, r23
    1dec:	88 1f       	adc	r24, r24
    1dee:	99 1f       	adc	r25, r25
    1df0:	1a f0       	brmi	.+6      	; 0x1df8 <__fixunssfsi+0x24>
    1df2:	ba 95       	dec	r27
    1df4:	c9 f7       	brne	.-14     	; 0x1de8 <__fixunssfsi+0x14>
    1df6:	14 c0       	rjmp	.+40     	; 0x1e20 <__fixunssfsi+0x4c>
    1df8:	b1 30       	cpi	r27, 0x01	; 1
    1dfa:	91 f0       	breq	.+36     	; 0x1e20 <__fixunssfsi+0x4c>
    1dfc:	0e 94 a0 0f 	call	0x1f40	; 0x1f40 <__fp_zero>
    1e00:	b1 e0       	ldi	r27, 0x01	; 1
    1e02:	08 95       	ret
    1e04:	0c 94 a0 0f 	jmp	0x1f40	; 0x1f40 <__fp_zero>
    1e08:	67 2f       	mov	r22, r23
    1e0a:	78 2f       	mov	r23, r24
    1e0c:	88 27       	eor	r24, r24
    1e0e:	b8 5f       	subi	r27, 0xF8	; 248
    1e10:	39 f0       	breq	.+14     	; 0x1e20 <__fixunssfsi+0x4c>
    1e12:	b9 3f       	cpi	r27, 0xF9	; 249
    1e14:	cc f3       	brlt	.-14     	; 0x1e08 <__fixunssfsi+0x34>
    1e16:	86 95       	lsr	r24
    1e18:	77 95       	ror	r23
    1e1a:	67 95       	ror	r22
    1e1c:	b3 95       	inc	r27
    1e1e:	d9 f7       	brne	.-10     	; 0x1e16 <__fixunssfsi+0x42>
    1e20:	3e f4       	brtc	.+14     	; 0x1e30 <__fixunssfsi+0x5c>
    1e22:	90 95       	com	r25
    1e24:	80 95       	com	r24
    1e26:	70 95       	com	r23
    1e28:	61 95       	neg	r22
    1e2a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e2c:	8f 4f       	sbci	r24, 0xFF	; 255
    1e2e:	9f 4f       	sbci	r25, 0xFF	; 255
    1e30:	08 95       	ret

00001e32 <__floatunsisf>:
    1e32:	e8 94       	clt
    1e34:	09 c0       	rjmp	.+18     	; 0x1e48 <__floatsisf+0x12>

00001e36 <__floatsisf>:
    1e36:	97 fb       	bst	r25, 7
    1e38:	3e f4       	brtc	.+14     	; 0x1e48 <__floatsisf+0x12>
    1e3a:	90 95       	com	r25
    1e3c:	80 95       	com	r24
    1e3e:	70 95       	com	r23
    1e40:	61 95       	neg	r22
    1e42:	7f 4f       	sbci	r23, 0xFF	; 255
    1e44:	8f 4f       	sbci	r24, 0xFF	; 255
    1e46:	9f 4f       	sbci	r25, 0xFF	; 255
    1e48:	99 23       	and	r25, r25
    1e4a:	a9 f0       	breq	.+42     	; 0x1e76 <__floatsisf+0x40>
    1e4c:	f9 2f       	mov	r31, r25
    1e4e:	96 e9       	ldi	r25, 0x96	; 150
    1e50:	bb 27       	eor	r27, r27
    1e52:	93 95       	inc	r25
    1e54:	f6 95       	lsr	r31
    1e56:	87 95       	ror	r24
    1e58:	77 95       	ror	r23
    1e5a:	67 95       	ror	r22
    1e5c:	b7 95       	ror	r27
    1e5e:	f1 11       	cpse	r31, r1
    1e60:	f8 cf       	rjmp	.-16     	; 0x1e52 <__floatsisf+0x1c>
    1e62:	fa f4       	brpl	.+62     	; 0x1ea2 <__floatsisf+0x6c>
    1e64:	bb 0f       	add	r27, r27
    1e66:	11 f4       	brne	.+4      	; 0x1e6c <__floatsisf+0x36>
    1e68:	60 ff       	sbrs	r22, 0
    1e6a:	1b c0       	rjmp	.+54     	; 0x1ea2 <__floatsisf+0x6c>
    1e6c:	6f 5f       	subi	r22, 0xFF	; 255
    1e6e:	7f 4f       	sbci	r23, 0xFF	; 255
    1e70:	8f 4f       	sbci	r24, 0xFF	; 255
    1e72:	9f 4f       	sbci	r25, 0xFF	; 255
    1e74:	16 c0       	rjmp	.+44     	; 0x1ea2 <__floatsisf+0x6c>
    1e76:	88 23       	and	r24, r24
    1e78:	11 f0       	breq	.+4      	; 0x1e7e <__floatsisf+0x48>
    1e7a:	96 e9       	ldi	r25, 0x96	; 150
    1e7c:	11 c0       	rjmp	.+34     	; 0x1ea0 <__floatsisf+0x6a>
    1e7e:	77 23       	and	r23, r23
    1e80:	21 f0       	breq	.+8      	; 0x1e8a <__floatsisf+0x54>
    1e82:	9e e8       	ldi	r25, 0x8E	; 142
    1e84:	87 2f       	mov	r24, r23
    1e86:	76 2f       	mov	r23, r22
    1e88:	05 c0       	rjmp	.+10     	; 0x1e94 <__floatsisf+0x5e>
    1e8a:	66 23       	and	r22, r22
    1e8c:	71 f0       	breq	.+28     	; 0x1eaa <__floatsisf+0x74>
    1e8e:	96 e8       	ldi	r25, 0x86	; 134
    1e90:	86 2f       	mov	r24, r22
    1e92:	70 e0       	ldi	r23, 0x00	; 0
    1e94:	60 e0       	ldi	r22, 0x00	; 0
    1e96:	2a f0       	brmi	.+10     	; 0x1ea2 <__floatsisf+0x6c>
    1e98:	9a 95       	dec	r25
    1e9a:	66 0f       	add	r22, r22
    1e9c:	77 1f       	adc	r23, r23
    1e9e:	88 1f       	adc	r24, r24
    1ea0:	da f7       	brpl	.-10     	; 0x1e98 <__floatsisf+0x62>
    1ea2:	88 0f       	add	r24, r24
    1ea4:	96 95       	lsr	r25
    1ea6:	87 95       	ror	r24
    1ea8:	97 f9       	bld	r25, 7
    1eaa:	08 95       	ret

00001eac <__fp_inf>:
    1eac:	97 f9       	bld	r25, 7
    1eae:	9f 67       	ori	r25, 0x7F	; 127
    1eb0:	80 e8       	ldi	r24, 0x80	; 128
    1eb2:	70 e0       	ldi	r23, 0x00	; 0
    1eb4:	60 e0       	ldi	r22, 0x00	; 0
    1eb6:	08 95       	ret

00001eb8 <__fp_nan>:
    1eb8:	9f ef       	ldi	r25, 0xFF	; 255
    1eba:	80 ec       	ldi	r24, 0xC0	; 192
    1ebc:	08 95       	ret

00001ebe <__fp_pscA>:
    1ebe:	00 24       	eor	r0, r0
    1ec0:	0a 94       	dec	r0
    1ec2:	16 16       	cp	r1, r22
    1ec4:	17 06       	cpc	r1, r23
    1ec6:	18 06       	cpc	r1, r24
    1ec8:	09 06       	cpc	r0, r25
    1eca:	08 95       	ret

00001ecc <__fp_pscB>:
    1ecc:	00 24       	eor	r0, r0
    1ece:	0a 94       	dec	r0
    1ed0:	12 16       	cp	r1, r18
    1ed2:	13 06       	cpc	r1, r19
    1ed4:	14 06       	cpc	r1, r20
    1ed6:	05 06       	cpc	r0, r21
    1ed8:	08 95       	ret

00001eda <__fp_round>:
    1eda:	09 2e       	mov	r0, r25
    1edc:	03 94       	inc	r0
    1ede:	00 0c       	add	r0, r0
    1ee0:	11 f4       	brne	.+4      	; 0x1ee6 <__fp_round+0xc>
    1ee2:	88 23       	and	r24, r24
    1ee4:	52 f0       	brmi	.+20     	; 0x1efa <__fp_round+0x20>
    1ee6:	bb 0f       	add	r27, r27
    1ee8:	40 f4       	brcc	.+16     	; 0x1efa <__fp_round+0x20>
    1eea:	bf 2b       	or	r27, r31
    1eec:	11 f4       	brne	.+4      	; 0x1ef2 <__fp_round+0x18>
    1eee:	60 ff       	sbrs	r22, 0
    1ef0:	04 c0       	rjmp	.+8      	; 0x1efa <__fp_round+0x20>
    1ef2:	6f 5f       	subi	r22, 0xFF	; 255
    1ef4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ef6:	8f 4f       	sbci	r24, 0xFF	; 255
    1ef8:	9f 4f       	sbci	r25, 0xFF	; 255
    1efa:	08 95       	ret

00001efc <__fp_split3>:
    1efc:	57 fd       	sbrc	r21, 7
    1efe:	90 58       	subi	r25, 0x80	; 128
    1f00:	44 0f       	add	r20, r20
    1f02:	55 1f       	adc	r21, r21
    1f04:	59 f0       	breq	.+22     	; 0x1f1c <__fp_splitA+0x10>
    1f06:	5f 3f       	cpi	r21, 0xFF	; 255
    1f08:	71 f0       	breq	.+28     	; 0x1f26 <__fp_splitA+0x1a>
    1f0a:	47 95       	ror	r20

00001f0c <__fp_splitA>:
    1f0c:	88 0f       	add	r24, r24
    1f0e:	97 fb       	bst	r25, 7
    1f10:	99 1f       	adc	r25, r25
    1f12:	61 f0       	breq	.+24     	; 0x1f2c <__fp_splitA+0x20>
    1f14:	9f 3f       	cpi	r25, 0xFF	; 255
    1f16:	79 f0       	breq	.+30     	; 0x1f36 <__fp_splitA+0x2a>
    1f18:	87 95       	ror	r24
    1f1a:	08 95       	ret
    1f1c:	12 16       	cp	r1, r18
    1f1e:	13 06       	cpc	r1, r19
    1f20:	14 06       	cpc	r1, r20
    1f22:	55 1f       	adc	r21, r21
    1f24:	f2 cf       	rjmp	.-28     	; 0x1f0a <__fp_split3+0xe>
    1f26:	46 95       	lsr	r20
    1f28:	f1 df       	rcall	.-30     	; 0x1f0c <__fp_splitA>
    1f2a:	08 c0       	rjmp	.+16     	; 0x1f3c <__fp_splitA+0x30>
    1f2c:	16 16       	cp	r1, r22
    1f2e:	17 06       	cpc	r1, r23
    1f30:	18 06       	cpc	r1, r24
    1f32:	99 1f       	adc	r25, r25
    1f34:	f1 cf       	rjmp	.-30     	; 0x1f18 <__fp_splitA+0xc>
    1f36:	86 95       	lsr	r24
    1f38:	71 05       	cpc	r23, r1
    1f3a:	61 05       	cpc	r22, r1
    1f3c:	08 94       	sec
    1f3e:	08 95       	ret

00001f40 <__fp_zero>:
    1f40:	e8 94       	clt

00001f42 <__fp_szero>:
    1f42:	bb 27       	eor	r27, r27
    1f44:	66 27       	eor	r22, r22
    1f46:	77 27       	eor	r23, r23
    1f48:	cb 01       	movw	r24, r22
    1f4a:	97 f9       	bld	r25, 7
    1f4c:	08 95       	ret
    1f4e:	16 f0       	brts	.+4      	; 0x1f54 <__fp_szero+0x12>
    1f50:	0c 94 64 10 	jmp	0x20c8	; 0x20c8 <__fp_mpack>
    1f54:	0c 94 5c 0f 	jmp	0x1eb8	; 0x1eb8 <__fp_nan>
    1f58:	68 94       	set
    1f5a:	0c 94 56 0f 	jmp	0x1eac	; 0x1eac <__fp_inf>

00001f5e <log>:
    1f5e:	0e 94 86 0f 	call	0x1f0c	; 0x1f0c <__fp_splitA>
    1f62:	a8 f3       	brcs	.-22     	; 0x1f4e <__fp_szero+0xc>
    1f64:	99 23       	and	r25, r25
    1f66:	c1 f3       	breq	.-16     	; 0x1f58 <__fp_szero+0x16>
    1f68:	ae f3       	brts	.-22     	; 0x1f54 <__fp_szero+0x12>
    1f6a:	df 93       	push	r29
    1f6c:	cf 93       	push	r28
    1f6e:	1f 93       	push	r17
    1f70:	0f 93       	push	r16
    1f72:	ff 92       	push	r15
    1f74:	c9 2f       	mov	r28, r25
    1f76:	dd 27       	eor	r29, r29
    1f78:	88 23       	and	r24, r24
    1f7a:	2a f0       	brmi	.+10     	; 0x1f86 <log+0x28>
    1f7c:	21 97       	sbiw	r28, 0x01	; 1
    1f7e:	66 0f       	add	r22, r22
    1f80:	77 1f       	adc	r23, r23
    1f82:	88 1f       	adc	r24, r24
    1f84:	da f7       	brpl	.-10     	; 0x1f7c <log+0x1e>
    1f86:	20 e0       	ldi	r18, 0x00	; 0
    1f88:	30 e0       	ldi	r19, 0x00	; 0
    1f8a:	40 e8       	ldi	r20, 0x80	; 128
    1f8c:	5f eb       	ldi	r21, 0xBF	; 191
    1f8e:	9f e3       	ldi	r25, 0x3F	; 63
    1f90:	88 39       	cpi	r24, 0x98	; 152
    1f92:	20 f0       	brcs	.+8      	; 0x1f9c <log+0x3e>
    1f94:	80 3e       	cpi	r24, 0xE0	; 224
    1f96:	38 f0       	brcs	.+14     	; 0x1fa6 <log+0x48>
    1f98:	21 96       	adiw	r28, 0x01	; 1
    1f9a:	8f 77       	andi	r24, 0x7F	; 127
    1f9c:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <__addsf3>
    1fa0:	e4 e5       	ldi	r30, 0x54	; 84
    1fa2:	f0 e0       	ldi	r31, 0x00	; 0
    1fa4:	04 c0       	rjmp	.+8      	; 0x1fae <log+0x50>
    1fa6:	0e 94 0c 0e 	call	0x1c18	; 0x1c18 <__addsf3>
    1faa:	e1 e8       	ldi	r30, 0x81	; 129
    1fac:	f0 e0       	ldi	r31, 0x00	; 0
    1fae:	0e 94 72 10 	call	0x20e4	; 0x20e4 <__fp_powser>
    1fb2:	8b 01       	movw	r16, r22
    1fb4:	be 01       	movw	r22, r28
    1fb6:	ec 01       	movw	r28, r24
    1fb8:	fb 2e       	mov	r15, r27
    1fba:	6f 57       	subi	r22, 0x7F	; 127
    1fbc:	71 09       	sbc	r23, r1
    1fbe:	75 95       	asr	r23
    1fc0:	77 1f       	adc	r23, r23
    1fc2:	88 0b       	sbc	r24, r24
    1fc4:	99 0b       	sbc	r25, r25
    1fc6:	0e 94 1b 0f 	call	0x1e36	; 0x1e36 <__floatsisf>
    1fca:	28 e1       	ldi	r18, 0x18	; 24
    1fcc:	32 e7       	ldi	r19, 0x72	; 114
    1fce:	41 e3       	ldi	r20, 0x31	; 49
    1fd0:	5f e3       	ldi	r21, 0x3F	; 63
    1fd2:	0e 94 0a 10 	call	0x2014	; 0x2014 <__mulsf3x>
    1fd6:	af 2d       	mov	r26, r15
    1fd8:	98 01       	movw	r18, r16
    1fda:	ae 01       	movw	r20, r28
    1fdc:	ff 90       	pop	r15
    1fde:	0f 91       	pop	r16
    1fe0:	1f 91       	pop	r17
    1fe2:	cf 91       	pop	r28
    1fe4:	df 91       	pop	r29
    1fe6:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <__addsf3x>
    1fea:	0c 94 6d 0f 	jmp	0x1eda	; 0x1eda <__fp_round>

00001fee <__mulsf3>:
    1fee:	0e 94 0a 10 	call	0x2014	; 0x2014 <__mulsf3x>
    1ff2:	0c 94 6d 0f 	jmp	0x1eda	; 0x1eda <__fp_round>
    1ff6:	0e 94 5f 0f 	call	0x1ebe	; 0x1ebe <__fp_pscA>
    1ffa:	38 f0       	brcs	.+14     	; 0x200a <__mulsf3+0x1c>
    1ffc:	0e 94 66 0f 	call	0x1ecc	; 0x1ecc <__fp_pscB>
    2000:	20 f0       	brcs	.+8      	; 0x200a <__mulsf3+0x1c>
    2002:	95 23       	and	r25, r21
    2004:	11 f0       	breq	.+4      	; 0x200a <__mulsf3+0x1c>
    2006:	0c 94 56 0f 	jmp	0x1eac	; 0x1eac <__fp_inf>
    200a:	0c 94 5c 0f 	jmp	0x1eb8	; 0x1eb8 <__fp_nan>
    200e:	11 24       	eor	r1, r1
    2010:	0c 94 a1 0f 	jmp	0x1f42	; 0x1f42 <__fp_szero>

00002014 <__mulsf3x>:
    2014:	0e 94 7e 0f 	call	0x1efc	; 0x1efc <__fp_split3>
    2018:	70 f3       	brcs	.-36     	; 0x1ff6 <__mulsf3+0x8>

0000201a <__mulsf3_pse>:
    201a:	95 9f       	mul	r25, r21
    201c:	c1 f3       	breq	.-16     	; 0x200e <__mulsf3+0x20>
    201e:	95 0f       	add	r25, r21
    2020:	50 e0       	ldi	r21, 0x00	; 0
    2022:	55 1f       	adc	r21, r21
    2024:	62 9f       	mul	r22, r18
    2026:	f0 01       	movw	r30, r0
    2028:	72 9f       	mul	r23, r18
    202a:	bb 27       	eor	r27, r27
    202c:	f0 0d       	add	r31, r0
    202e:	b1 1d       	adc	r27, r1
    2030:	63 9f       	mul	r22, r19
    2032:	aa 27       	eor	r26, r26
    2034:	f0 0d       	add	r31, r0
    2036:	b1 1d       	adc	r27, r1
    2038:	aa 1f       	adc	r26, r26
    203a:	64 9f       	mul	r22, r20
    203c:	66 27       	eor	r22, r22
    203e:	b0 0d       	add	r27, r0
    2040:	a1 1d       	adc	r26, r1
    2042:	66 1f       	adc	r22, r22
    2044:	82 9f       	mul	r24, r18
    2046:	22 27       	eor	r18, r18
    2048:	b0 0d       	add	r27, r0
    204a:	a1 1d       	adc	r26, r1
    204c:	62 1f       	adc	r22, r18
    204e:	73 9f       	mul	r23, r19
    2050:	b0 0d       	add	r27, r0
    2052:	a1 1d       	adc	r26, r1
    2054:	62 1f       	adc	r22, r18
    2056:	83 9f       	mul	r24, r19
    2058:	a0 0d       	add	r26, r0
    205a:	61 1d       	adc	r22, r1
    205c:	22 1f       	adc	r18, r18
    205e:	74 9f       	mul	r23, r20
    2060:	33 27       	eor	r19, r19
    2062:	a0 0d       	add	r26, r0
    2064:	61 1d       	adc	r22, r1
    2066:	23 1f       	adc	r18, r19
    2068:	84 9f       	mul	r24, r20
    206a:	60 0d       	add	r22, r0
    206c:	21 1d       	adc	r18, r1
    206e:	82 2f       	mov	r24, r18
    2070:	76 2f       	mov	r23, r22
    2072:	6a 2f       	mov	r22, r26
    2074:	11 24       	eor	r1, r1
    2076:	9f 57       	subi	r25, 0x7F	; 127
    2078:	50 40       	sbci	r21, 0x00	; 0
    207a:	9a f0       	brmi	.+38     	; 0x20a2 <__mulsf3_pse+0x88>
    207c:	f1 f0       	breq	.+60     	; 0x20ba <__mulsf3_pse+0xa0>
    207e:	88 23       	and	r24, r24
    2080:	4a f0       	brmi	.+18     	; 0x2094 <__mulsf3_pse+0x7a>
    2082:	ee 0f       	add	r30, r30
    2084:	ff 1f       	adc	r31, r31
    2086:	bb 1f       	adc	r27, r27
    2088:	66 1f       	adc	r22, r22
    208a:	77 1f       	adc	r23, r23
    208c:	88 1f       	adc	r24, r24
    208e:	91 50       	subi	r25, 0x01	; 1
    2090:	50 40       	sbci	r21, 0x00	; 0
    2092:	a9 f7       	brne	.-22     	; 0x207e <__mulsf3_pse+0x64>
    2094:	9e 3f       	cpi	r25, 0xFE	; 254
    2096:	51 05       	cpc	r21, r1
    2098:	80 f0       	brcs	.+32     	; 0x20ba <__mulsf3_pse+0xa0>
    209a:	0c 94 56 0f 	jmp	0x1eac	; 0x1eac <__fp_inf>
    209e:	0c 94 a1 0f 	jmp	0x1f42	; 0x1f42 <__fp_szero>
    20a2:	5f 3f       	cpi	r21, 0xFF	; 255
    20a4:	e4 f3       	brlt	.-8      	; 0x209e <__mulsf3_pse+0x84>
    20a6:	98 3e       	cpi	r25, 0xE8	; 232
    20a8:	d4 f3       	brlt	.-12     	; 0x209e <__mulsf3_pse+0x84>
    20aa:	86 95       	lsr	r24
    20ac:	77 95       	ror	r23
    20ae:	67 95       	ror	r22
    20b0:	b7 95       	ror	r27
    20b2:	f7 95       	ror	r31
    20b4:	e7 95       	ror	r30
    20b6:	9f 5f       	subi	r25, 0xFF	; 255
    20b8:	c1 f7       	brne	.-16     	; 0x20aa <__mulsf3_pse+0x90>
    20ba:	fe 2b       	or	r31, r30
    20bc:	88 0f       	add	r24, r24
    20be:	91 1d       	adc	r25, r1
    20c0:	96 95       	lsr	r25
    20c2:	87 95       	ror	r24
    20c4:	97 f9       	bld	r25, 7
    20c6:	08 95       	ret

000020c8 <__fp_mpack>:
    20c8:	9f 3f       	cpi	r25, 0xFF	; 255
    20ca:	31 f0       	breq	.+12     	; 0x20d8 <__fp_mpack_finite+0xc>

000020cc <__fp_mpack_finite>:
    20cc:	91 50       	subi	r25, 0x01	; 1
    20ce:	20 f4       	brcc	.+8      	; 0x20d8 <__fp_mpack_finite+0xc>
    20d0:	87 95       	ror	r24
    20d2:	77 95       	ror	r23
    20d4:	67 95       	ror	r22
    20d6:	b7 95       	ror	r27
    20d8:	88 0f       	add	r24, r24
    20da:	91 1d       	adc	r25, r1
    20dc:	96 95       	lsr	r25
    20de:	87 95       	ror	r24
    20e0:	97 f9       	bld	r25, 7
    20e2:	08 95       	ret

000020e4 <__fp_powser>:
    20e4:	df 93       	push	r29
    20e6:	cf 93       	push	r28
    20e8:	1f 93       	push	r17
    20ea:	0f 93       	push	r16
    20ec:	ff 92       	push	r15
    20ee:	ef 92       	push	r14
    20f0:	df 92       	push	r13
    20f2:	7b 01       	movw	r14, r22
    20f4:	8c 01       	movw	r16, r24
    20f6:	68 94       	set
    20f8:	06 c0       	rjmp	.+12     	; 0x2106 <__fp_powser+0x22>
    20fa:	da 2e       	mov	r13, r26
    20fc:	ef 01       	movw	r28, r30
    20fe:	0e 94 0a 10 	call	0x2014	; 0x2014 <__mulsf3x>
    2102:	fe 01       	movw	r30, r28
    2104:	e8 94       	clt
    2106:	a5 91       	lpm	r26, Z+
    2108:	25 91       	lpm	r18, Z+
    210a:	35 91       	lpm	r19, Z+
    210c:	45 91       	lpm	r20, Z+
    210e:	55 91       	lpm	r21, Z+
    2110:	a6 f3       	brts	.-24     	; 0x20fa <__fp_powser+0x16>
    2112:	ef 01       	movw	r28, r30
    2114:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <__addsf3x>
    2118:	fe 01       	movw	r30, r28
    211a:	97 01       	movw	r18, r14
    211c:	a8 01       	movw	r20, r16
    211e:	da 94       	dec	r13
    2120:	69 f7       	brne	.-38     	; 0x20fc <__fp_powser+0x18>
    2122:	df 90       	pop	r13
    2124:	ef 90       	pop	r14
    2126:	ff 90       	pop	r15
    2128:	0f 91       	pop	r16
    212a:	1f 91       	pop	r17
    212c:	cf 91       	pop	r28
    212e:	df 91       	pop	r29
    2130:	08 95       	ret

00002132 <_exit>:
    2132:	f8 94       	cli

00002134 <__stop_program>:
    2134:	ff cf       	rjmp	.-2      	; 0x2134 <__stop_program>
