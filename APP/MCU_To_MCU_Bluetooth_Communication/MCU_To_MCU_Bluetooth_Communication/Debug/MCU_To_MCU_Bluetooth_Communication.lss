
MCU_To_MCU_Bluetooth_Communication.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001eb0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000092  00800060  00001eb0  00001f44  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000064b  008000f2  008000f2  00001fd6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001fd6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002008  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000448  00000000  00000000  00002044  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000424f  00000000  00000000  0000248c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001655  00000000  00000000  000066db  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002bee  00000000  00000000  00007d30  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000988  00000000  00000000  0000a920  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000188d  00000000  00000000  0000b2a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00003118  00000000  00000000  0000cb35  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000430  00000000  00000000  0000fc4d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 57 00 	jmp	0xae	; 0xae <__ctors_end>
       4:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
       8:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
       c:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      10:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      14:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      18:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      1c:	0c 94 59 02 	jmp	0x4b2	; 0x4b2 <__vector_7>
      20:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      24:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      28:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      2c:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      30:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      34:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      38:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      3c:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      40:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      44:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      48:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      4c:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      50:	0c 94 74 00 	jmp	0xe8	; 0xe8 <__bad_interrupt>
      54:	08 00       	.word	0x0008	; ????
      56:	00 00       	nop
      58:	be 92       	st	-X, r11
      5a:	24 49       	sbci	r18, 0x94	; 148
      5c:	12 3e       	cpi	r17, 0xE2	; 226
      5e:	ab aa       	std	Y+51, r10	; 0x33
      60:	aa 2a       	or	r10, r26
      62:	be cd       	rjmp	.-1156   	; 0xfffffbe0 <__eeprom_end+0xff7efbe0>
      64:	cc cc       	rjmp	.-1640   	; 0xfffff9fe <__eeprom_end+0xff7ef9fe>
      66:	4c 3e       	cpi	r20, 0xEC	; 236
      68:	00 00       	nop
      6a:	00 80       	ld	r0, Z
      6c:	be ab       	std	Y+54, r27	; 0x36
      6e:	aa aa       	std	Y+50, r10	; 0x32
      70:	aa 3e       	cpi	r26, 0xEA	; 234
      72:	00 00       	nop
      74:	00 00       	nop
      76:	bf 00       	.word	0x00bf	; ????
      78:	00 00       	nop
      7a:	80 3f       	cpi	r24, 0xF0	; 240
      7c:	00 00       	nop
      7e:	00 00       	nop
      80:	00 08       	sbc	r0, r0
      82:	41 78       	andi	r20, 0x81	; 129
      84:	d3 bb       	out	0x13, r29	; 19
      86:	43 87       	std	Z+11, r20	; 0x0b
      88:	d1 13       	cpse	r29, r17
      8a:	3d 19       	sub	r19, r13
      8c:	0e 3c       	cpi	r16, 0xCE	; 206
      8e:	c3 bd       	out	0x23, r28	; 35
      90:	42 82       	std	Z+2, r4	; 0x02
      92:	ad 2b       	or	r26, r29
      94:	3e 68       	ori	r19, 0x8E	; 142
      96:	ec 82       	std	Y+4, r14	; 0x04
      98:	76 be       	out	0x36, r7	; 54
      9a:	d9 8f       	std	Y+25, r29	; 0x19
      9c:	e1 a9       	ldd	r30, Z+49	; 0x31
      9e:	3e 4c       	sbci	r19, 0xCE	; 206
      a0:	80 ef       	ldi	r24, 0xF0	; 240
      a2:	ff be       	out	0x3f, r15	; 63
      a4:	01 c4       	rjmp	.+2050   	; 0x8a8 <__stack+0x49>
      a6:	ff 7f       	andi	r31, 0xFF	; 255
      a8:	3f 00       	.word	0x003f	; ????
      aa:	00 00       	nop
	...

000000ae <__ctors_end>:
      ae:	11 24       	eor	r1, r1
      b0:	1f be       	out	0x3f, r1	; 63
      b2:	cf e5       	ldi	r28, 0x5F	; 95
      b4:	d8 e0       	ldi	r29, 0x08	; 8
      b6:	de bf       	out	0x3e, r29	; 62
      b8:	cd bf       	out	0x3d, r28	; 61

000000ba <__do_copy_data>:
      ba:	10 e0       	ldi	r17, 0x00	; 0
      bc:	a0 e6       	ldi	r26, 0x60	; 96
      be:	b0 e0       	ldi	r27, 0x00	; 0
      c0:	e0 eb       	ldi	r30, 0xB0	; 176
      c2:	fe e1       	ldi	r31, 0x1E	; 30
      c4:	02 c0       	rjmp	.+4      	; 0xca <__do_copy_data+0x10>
      c6:	05 90       	lpm	r0, Z+
      c8:	0d 92       	st	X+, r0
      ca:	a2 3f       	cpi	r26, 0xF2	; 242
      cc:	b1 07       	cpc	r27, r17
      ce:	d9 f7       	brne	.-10     	; 0xc6 <__do_copy_data+0xc>

000000d0 <__do_clear_bss>:
      d0:	27 e0       	ldi	r18, 0x07	; 7
      d2:	a2 ef       	ldi	r26, 0xF2	; 242
      d4:	b0 e0       	ldi	r27, 0x00	; 0
      d6:	01 c0       	rjmp	.+2      	; 0xda <.do_clear_bss_start>

000000d8 <.do_clear_bss_loop>:
      d8:	1d 92       	st	X+, r1

000000da <.do_clear_bss_start>:
      da:	ad 33       	cpi	r26, 0x3D	; 61
      dc:	b2 07       	cpc	r27, r18
      de:	e1 f7       	brne	.-8      	; 0xd8 <.do_clear_bss_loop>
      e0:	0e 94 ae 0c 	call	0x195c	; 0x195c <main>
      e4:	0c 94 56 0f 	jmp	0x1eac	; 0x1eac <_exit>

000000e8 <__bad_interrupt>:
      e8:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ec <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
      ec:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      ee:	03 96       	adiw	r24, 0x03	; 3
      f0:	92 83       	std	Z+2, r25	; 0x02
      f2:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
      f4:	2f ef       	ldi	r18, 0xFF	; 255
      f6:	3f ef       	ldi	r19, 0xFF	; 255
      f8:	34 83       	std	Z+4, r19	; 0x04
      fa:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      fc:	96 83       	std	Z+6, r25	; 0x06
      fe:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     100:	90 87       	std	Z+8, r25	; 0x08
     102:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     104:	10 82       	st	Z, r1
     106:	08 95       	ret

00000108 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     108:	fc 01       	movw	r30, r24
     10a:	11 86       	std	Z+9, r1	; 0x09
     10c:	10 86       	std	Z+8, r1	; 0x08
     10e:	08 95       	ret

00000110 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     110:	cf 93       	push	r28
     112:	df 93       	push	r29
     114:	9c 01       	movw	r18, r24
     116:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     118:	dc 01       	movw	r26, r24
     11a:	11 96       	adiw	r26, 0x01	; 1
     11c:	cd 91       	ld	r28, X+
     11e:	dc 91       	ld	r29, X
     120:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     122:	d3 83       	std	Z+3, r29	; 0x03
     124:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     126:	8c 81       	ldd	r24, Y+4	; 0x04
     128:	9d 81       	ldd	r25, Y+5	; 0x05
     12a:	95 83       	std	Z+5, r25	; 0x05
     12c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     12e:	8c 81       	ldd	r24, Y+4	; 0x04
     130:	9d 81       	ldd	r25, Y+5	; 0x05
     132:	dc 01       	movw	r26, r24
     134:	13 96       	adiw	r26, 0x03	; 3
     136:	7c 93       	st	X, r23
     138:	6e 93       	st	-X, r22
     13a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     13c:	7d 83       	std	Y+5, r23	; 0x05
     13e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     140:	31 87       	std	Z+9, r19	; 0x09
     142:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     144:	f9 01       	movw	r30, r18
     146:	80 81       	ld	r24, Z
     148:	8f 5f       	subi	r24, 0xFF	; 255
     14a:	80 83       	st	Z, r24
}
     14c:	df 91       	pop	r29
     14e:	cf 91       	pop	r28
     150:	08 95       	ret

00000152 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     152:	cf 93       	push	r28
     154:	df 93       	push	r29
     156:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     158:	48 81       	ld	r20, Y
     15a:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     15c:	4f 3f       	cpi	r20, 0xFF	; 255
     15e:	2f ef       	ldi	r18, 0xFF	; 255
     160:	52 07       	cpc	r21, r18
     162:	21 f4       	brne	.+8      	; 0x16c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     164:	fc 01       	movw	r30, r24
     166:	a7 81       	ldd	r26, Z+7	; 0x07
     168:	b0 85       	ldd	r27, Z+8	; 0x08
     16a:	0d c0       	rjmp	.+26     	; 0x186 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     16c:	dc 01       	movw	r26, r24
     16e:	13 96       	adiw	r26, 0x03	; 3
     170:	01 c0       	rjmp	.+2      	; 0x174 <vListInsert+0x22>
     172:	df 01       	movw	r26, r30
     174:	12 96       	adiw	r26, 0x02	; 2
     176:	ed 91       	ld	r30, X+
     178:	fc 91       	ld	r31, X
     17a:	13 97       	sbiw	r26, 0x03	; 3
     17c:	20 81       	ld	r18, Z
     17e:	31 81       	ldd	r19, Z+1	; 0x01
     180:	42 17       	cp	r20, r18
     182:	53 07       	cpc	r21, r19
     184:	b0 f7       	brcc	.-20     	; 0x172 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     186:	12 96       	adiw	r26, 0x02	; 2
     188:	ed 91       	ld	r30, X+
     18a:	fc 91       	ld	r31, X
     18c:	13 97       	sbiw	r26, 0x03	; 3
     18e:	fb 83       	std	Y+3, r31	; 0x03
     190:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     192:	d5 83       	std	Z+5, r29	; 0x05
     194:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     196:	bd 83       	std	Y+5, r27	; 0x05
     198:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     19a:	13 96       	adiw	r26, 0x03	; 3
     19c:	dc 93       	st	X, r29
     19e:	ce 93       	st	-X, r28
     1a0:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     1a2:	99 87       	std	Y+9, r25	; 0x09
     1a4:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     1a6:	fc 01       	movw	r30, r24
     1a8:	20 81       	ld	r18, Z
     1aa:	2f 5f       	subi	r18, 0xFF	; 255
     1ac:	20 83       	st	Z, r18
}
     1ae:	df 91       	pop	r29
     1b0:	cf 91       	pop	r28
     1b2:	08 95       	ret

000001b4 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     1b4:	cf 93       	push	r28
     1b6:	df 93       	push	r29
     1b8:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     1ba:	a0 85       	ldd	r26, Z+8	; 0x08
     1bc:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     1be:	c2 81       	ldd	r28, Z+2	; 0x02
     1c0:	d3 81       	ldd	r29, Z+3	; 0x03
     1c2:	84 81       	ldd	r24, Z+4	; 0x04
     1c4:	95 81       	ldd	r25, Z+5	; 0x05
     1c6:	9d 83       	std	Y+5, r25	; 0x05
     1c8:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     1ca:	c4 81       	ldd	r28, Z+4	; 0x04
     1cc:	d5 81       	ldd	r29, Z+5	; 0x05
     1ce:	82 81       	ldd	r24, Z+2	; 0x02
     1d0:	93 81       	ldd	r25, Z+3	; 0x03
     1d2:	9b 83       	std	Y+3, r25	; 0x03
     1d4:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     1d6:	11 96       	adiw	r26, 0x01	; 1
     1d8:	8d 91       	ld	r24, X+
     1da:	9c 91       	ld	r25, X
     1dc:	12 97       	sbiw	r26, 0x02	; 2
     1de:	e8 17       	cp	r30, r24
     1e0:	f9 07       	cpc	r31, r25
     1e2:	31 f4       	brne	.+12     	; 0x1f0 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     1e4:	84 81       	ldd	r24, Z+4	; 0x04
     1e6:	95 81       	ldd	r25, Z+5	; 0x05
     1e8:	12 96       	adiw	r26, 0x02	; 2
     1ea:	9c 93       	st	X, r25
     1ec:	8e 93       	st	-X, r24
     1ee:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     1f0:	11 86       	std	Z+9, r1	; 0x09
     1f2:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     1f4:	8c 91       	ld	r24, X
     1f6:	81 50       	subi	r24, 0x01	; 1
     1f8:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     1fa:	df 91       	pop	r29
     1fc:	cf 91       	pop	r28
     1fe:	08 95       	ret

00000200 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     200:	1b bc       	out	0x2b, r1	; 43
     202:	89 ef       	ldi	r24, 0xF9	; 249
     204:	8a bd       	out	0x2a, r24	; 42
     206:	8b e0       	ldi	r24, 0x0B	; 11
     208:	8e bd       	out	0x2e, r24	; 46
     20a:	89 b7       	in	r24, 0x39	; 57
     20c:	80 61       	ori	r24, 0x10	; 16
     20e:	89 bf       	out	0x39, r24	; 57
     210:	08 95       	ret

00000212 <pxPortInitialiseStack>:
     212:	31 e1       	ldi	r19, 0x11	; 17
     214:	fc 01       	movw	r30, r24
     216:	30 83       	st	Z, r19
     218:	31 97       	sbiw	r30, 0x01	; 1
     21a:	22 e2       	ldi	r18, 0x22	; 34
     21c:	20 83       	st	Z, r18
     21e:	31 97       	sbiw	r30, 0x01	; 1
     220:	a3 e3       	ldi	r26, 0x33	; 51
     222:	a0 83       	st	Z, r26
     224:	31 97       	sbiw	r30, 0x01	; 1
     226:	60 83       	st	Z, r22
     228:	31 97       	sbiw	r30, 0x01	; 1
     22a:	70 83       	st	Z, r23
     22c:	31 97       	sbiw	r30, 0x01	; 1
     22e:	10 82       	st	Z, r1
     230:	31 97       	sbiw	r30, 0x01	; 1
     232:	60 e8       	ldi	r22, 0x80	; 128
     234:	60 83       	st	Z, r22
     236:	31 97       	sbiw	r30, 0x01	; 1
     238:	10 82       	st	Z, r1
     23a:	31 97       	sbiw	r30, 0x01	; 1
     23c:	62 e0       	ldi	r22, 0x02	; 2
     23e:	60 83       	st	Z, r22
     240:	31 97       	sbiw	r30, 0x01	; 1
     242:	63 e0       	ldi	r22, 0x03	; 3
     244:	60 83       	st	Z, r22
     246:	31 97       	sbiw	r30, 0x01	; 1
     248:	64 e0       	ldi	r22, 0x04	; 4
     24a:	60 83       	st	Z, r22
     24c:	31 97       	sbiw	r30, 0x01	; 1
     24e:	65 e0       	ldi	r22, 0x05	; 5
     250:	60 83       	st	Z, r22
     252:	31 97       	sbiw	r30, 0x01	; 1
     254:	66 e0       	ldi	r22, 0x06	; 6
     256:	60 83       	st	Z, r22
     258:	31 97       	sbiw	r30, 0x01	; 1
     25a:	67 e0       	ldi	r22, 0x07	; 7
     25c:	60 83       	st	Z, r22
     25e:	31 97       	sbiw	r30, 0x01	; 1
     260:	68 e0       	ldi	r22, 0x08	; 8
     262:	60 83       	st	Z, r22
     264:	31 97       	sbiw	r30, 0x01	; 1
     266:	69 e0       	ldi	r22, 0x09	; 9
     268:	60 83       	st	Z, r22
     26a:	31 97       	sbiw	r30, 0x01	; 1
     26c:	60 e1       	ldi	r22, 0x10	; 16
     26e:	60 83       	st	Z, r22
     270:	31 97       	sbiw	r30, 0x01	; 1
     272:	30 83       	st	Z, r19
     274:	31 97       	sbiw	r30, 0x01	; 1
     276:	32 e1       	ldi	r19, 0x12	; 18
     278:	30 83       	st	Z, r19
     27a:	31 97       	sbiw	r30, 0x01	; 1
     27c:	33 e1       	ldi	r19, 0x13	; 19
     27e:	30 83       	st	Z, r19
     280:	31 97       	sbiw	r30, 0x01	; 1
     282:	34 e1       	ldi	r19, 0x14	; 20
     284:	30 83       	st	Z, r19
     286:	31 97       	sbiw	r30, 0x01	; 1
     288:	35 e1       	ldi	r19, 0x15	; 21
     28a:	30 83       	st	Z, r19
     28c:	31 97       	sbiw	r30, 0x01	; 1
     28e:	36 e1       	ldi	r19, 0x16	; 22
     290:	30 83       	st	Z, r19
     292:	31 97       	sbiw	r30, 0x01	; 1
     294:	37 e1       	ldi	r19, 0x17	; 23
     296:	30 83       	st	Z, r19
     298:	31 97       	sbiw	r30, 0x01	; 1
     29a:	38 e1       	ldi	r19, 0x18	; 24
     29c:	30 83       	st	Z, r19
     29e:	31 97       	sbiw	r30, 0x01	; 1
     2a0:	39 e1       	ldi	r19, 0x19	; 25
     2a2:	30 83       	st	Z, r19
     2a4:	31 97       	sbiw	r30, 0x01	; 1
     2a6:	30 e2       	ldi	r19, 0x20	; 32
     2a8:	30 83       	st	Z, r19
     2aa:	31 97       	sbiw	r30, 0x01	; 1
     2ac:	31 e2       	ldi	r19, 0x21	; 33
     2ae:	30 83       	st	Z, r19
     2b0:	31 97       	sbiw	r30, 0x01	; 1
     2b2:	20 83       	st	Z, r18
     2b4:	31 97       	sbiw	r30, 0x01	; 1
     2b6:	23 e2       	ldi	r18, 0x23	; 35
     2b8:	20 83       	st	Z, r18
     2ba:	31 97       	sbiw	r30, 0x01	; 1
     2bc:	40 83       	st	Z, r20
     2be:	31 97       	sbiw	r30, 0x01	; 1
     2c0:	50 83       	st	Z, r21
     2c2:	31 97       	sbiw	r30, 0x01	; 1
     2c4:	26 e2       	ldi	r18, 0x26	; 38
     2c6:	20 83       	st	Z, r18
     2c8:	31 97       	sbiw	r30, 0x01	; 1
     2ca:	27 e2       	ldi	r18, 0x27	; 39
     2cc:	20 83       	st	Z, r18
     2ce:	31 97       	sbiw	r30, 0x01	; 1
     2d0:	28 e2       	ldi	r18, 0x28	; 40
     2d2:	20 83       	st	Z, r18
     2d4:	31 97       	sbiw	r30, 0x01	; 1
     2d6:	29 e2       	ldi	r18, 0x29	; 41
     2d8:	20 83       	st	Z, r18
     2da:	31 97       	sbiw	r30, 0x01	; 1
     2dc:	20 e3       	ldi	r18, 0x30	; 48
     2de:	20 83       	st	Z, r18
     2e0:	31 97       	sbiw	r30, 0x01	; 1
     2e2:	21 e3       	ldi	r18, 0x31	; 49
     2e4:	20 83       	st	Z, r18
     2e6:	86 97       	sbiw	r24, 0x26	; 38
     2e8:	08 95       	ret

000002ea <xPortStartScheduler>:
     2ea:	0e 94 00 01 	call	0x200	; 0x200 <prvSetupTimerInterrupt>
     2ee:	a0 91 2b 07 	lds	r26, 0x072B	; 0x80072b <pxCurrentTCB>
     2f2:	b0 91 2c 07 	lds	r27, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     2f6:	cd 91       	ld	r28, X+
     2f8:	cd bf       	out	0x3d, r28	; 61
     2fa:	dd 91       	ld	r29, X+
     2fc:	de bf       	out	0x3e, r29	; 62
     2fe:	ff 91       	pop	r31
     300:	ef 91       	pop	r30
     302:	df 91       	pop	r29
     304:	cf 91       	pop	r28
     306:	bf 91       	pop	r27
     308:	af 91       	pop	r26
     30a:	9f 91       	pop	r25
     30c:	8f 91       	pop	r24
     30e:	7f 91       	pop	r23
     310:	6f 91       	pop	r22
     312:	5f 91       	pop	r21
     314:	4f 91       	pop	r20
     316:	3f 91       	pop	r19
     318:	2f 91       	pop	r18
     31a:	1f 91       	pop	r17
     31c:	0f 91       	pop	r16
     31e:	ff 90       	pop	r15
     320:	ef 90       	pop	r14
     322:	df 90       	pop	r13
     324:	cf 90       	pop	r12
     326:	bf 90       	pop	r11
     328:	af 90       	pop	r10
     32a:	9f 90       	pop	r9
     32c:	8f 90       	pop	r8
     32e:	7f 90       	pop	r7
     330:	6f 90       	pop	r6
     332:	5f 90       	pop	r5
     334:	4f 90       	pop	r4
     336:	3f 90       	pop	r3
     338:	2f 90       	pop	r2
     33a:	1f 90       	pop	r1
     33c:	0f 90       	pop	r0
     33e:	0f be       	out	0x3f, r0	; 63
     340:	0f 90       	pop	r0
     342:	08 95       	ret
     344:	81 e0       	ldi	r24, 0x01	; 1
     346:	08 95       	ret

00000348 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     348:	0f 92       	push	r0
     34a:	0f b6       	in	r0, 0x3f	; 63
     34c:	f8 94       	cli
     34e:	0f 92       	push	r0
     350:	1f 92       	push	r1
     352:	11 24       	eor	r1, r1
     354:	2f 92       	push	r2
     356:	3f 92       	push	r3
     358:	4f 92       	push	r4
     35a:	5f 92       	push	r5
     35c:	6f 92       	push	r6
     35e:	7f 92       	push	r7
     360:	8f 92       	push	r8
     362:	9f 92       	push	r9
     364:	af 92       	push	r10
     366:	bf 92       	push	r11
     368:	cf 92       	push	r12
     36a:	df 92       	push	r13
     36c:	ef 92       	push	r14
     36e:	ff 92       	push	r15
     370:	0f 93       	push	r16
     372:	1f 93       	push	r17
     374:	2f 93       	push	r18
     376:	3f 93       	push	r19
     378:	4f 93       	push	r20
     37a:	5f 93       	push	r21
     37c:	6f 93       	push	r22
     37e:	7f 93       	push	r23
     380:	8f 93       	push	r24
     382:	9f 93       	push	r25
     384:	af 93       	push	r26
     386:	bf 93       	push	r27
     388:	cf 93       	push	r28
     38a:	df 93       	push	r29
     38c:	ef 93       	push	r30
     38e:	ff 93       	push	r31
     390:	a0 91 2b 07 	lds	r26, 0x072B	; 0x80072b <pxCurrentTCB>
     394:	b0 91 2c 07 	lds	r27, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     398:	0d b6       	in	r0, 0x3d	; 61
     39a:	0d 92       	st	X+, r0
     39c:	0e b6       	in	r0, 0x3e	; 62
     39e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     3a0:	0e 94 f4 06 	call	0xde8	; 0xde8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     3a4:	a0 91 2b 07 	lds	r26, 0x072B	; 0x80072b <pxCurrentTCB>
     3a8:	b0 91 2c 07 	lds	r27, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     3ac:	cd 91       	ld	r28, X+
     3ae:	cd bf       	out	0x3d, r28	; 61
     3b0:	dd 91       	ld	r29, X+
     3b2:	de bf       	out	0x3e, r29	; 62
     3b4:	ff 91       	pop	r31
     3b6:	ef 91       	pop	r30
     3b8:	df 91       	pop	r29
     3ba:	cf 91       	pop	r28
     3bc:	bf 91       	pop	r27
     3be:	af 91       	pop	r26
     3c0:	9f 91       	pop	r25
     3c2:	8f 91       	pop	r24
     3c4:	7f 91       	pop	r23
     3c6:	6f 91       	pop	r22
     3c8:	5f 91       	pop	r21
     3ca:	4f 91       	pop	r20
     3cc:	3f 91       	pop	r19
     3ce:	2f 91       	pop	r18
     3d0:	1f 91       	pop	r17
     3d2:	0f 91       	pop	r16
     3d4:	ff 90       	pop	r15
     3d6:	ef 90       	pop	r14
     3d8:	df 90       	pop	r13
     3da:	cf 90       	pop	r12
     3dc:	bf 90       	pop	r11
     3de:	af 90       	pop	r10
     3e0:	9f 90       	pop	r9
     3e2:	8f 90       	pop	r8
     3e4:	7f 90       	pop	r7
     3e6:	6f 90       	pop	r6
     3e8:	5f 90       	pop	r5
     3ea:	4f 90       	pop	r4
     3ec:	3f 90       	pop	r3
     3ee:	2f 90       	pop	r2
     3f0:	1f 90       	pop	r1
     3f2:	0f 90       	pop	r0
     3f4:	0f be       	out	0x3f, r0	; 63
     3f6:	0f 90       	pop	r0

	asm volatile ( "ret" );
     3f8:	08 95       	ret

000003fa <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     3fa:	0f 92       	push	r0
     3fc:	0f b6       	in	r0, 0x3f	; 63
     3fe:	f8 94       	cli
     400:	0f 92       	push	r0
     402:	1f 92       	push	r1
     404:	11 24       	eor	r1, r1
     406:	2f 92       	push	r2
     408:	3f 92       	push	r3
     40a:	4f 92       	push	r4
     40c:	5f 92       	push	r5
     40e:	6f 92       	push	r6
     410:	7f 92       	push	r7
     412:	8f 92       	push	r8
     414:	9f 92       	push	r9
     416:	af 92       	push	r10
     418:	bf 92       	push	r11
     41a:	cf 92       	push	r12
     41c:	df 92       	push	r13
     41e:	ef 92       	push	r14
     420:	ff 92       	push	r15
     422:	0f 93       	push	r16
     424:	1f 93       	push	r17
     426:	2f 93       	push	r18
     428:	3f 93       	push	r19
     42a:	4f 93       	push	r20
     42c:	5f 93       	push	r21
     42e:	6f 93       	push	r22
     430:	7f 93       	push	r23
     432:	8f 93       	push	r24
     434:	9f 93       	push	r25
     436:	af 93       	push	r26
     438:	bf 93       	push	r27
     43a:	cf 93       	push	r28
     43c:	df 93       	push	r29
     43e:	ef 93       	push	r30
     440:	ff 93       	push	r31
     442:	a0 91 2b 07 	lds	r26, 0x072B	; 0x80072b <pxCurrentTCB>
     446:	b0 91 2c 07 	lds	r27, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     44a:	0d b6       	in	r0, 0x3d	; 61
     44c:	0d 92       	st	X+, r0
     44e:	0e b6       	in	r0, 0x3e	; 62
     450:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     452:	0e 94 87 05 	call	0xb0e	; 0xb0e <xTaskIncrementTick>
     456:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     458:	0e 94 f4 06 	call	0xde8	; 0xde8 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     45c:	a0 91 2b 07 	lds	r26, 0x072B	; 0x80072b <pxCurrentTCB>
     460:	b0 91 2c 07 	lds	r27, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     464:	cd 91       	ld	r28, X+
     466:	cd bf       	out	0x3d, r28	; 61
     468:	dd 91       	ld	r29, X+
     46a:	de bf       	out	0x3e, r29	; 62
     46c:	ff 91       	pop	r31
     46e:	ef 91       	pop	r30
     470:	df 91       	pop	r29
     472:	cf 91       	pop	r28
     474:	bf 91       	pop	r27
     476:	af 91       	pop	r26
     478:	9f 91       	pop	r25
     47a:	8f 91       	pop	r24
     47c:	7f 91       	pop	r23
     47e:	6f 91       	pop	r22
     480:	5f 91       	pop	r21
     482:	4f 91       	pop	r20
     484:	3f 91       	pop	r19
     486:	2f 91       	pop	r18
     488:	1f 91       	pop	r17
     48a:	0f 91       	pop	r16
     48c:	ff 90       	pop	r15
     48e:	ef 90       	pop	r14
     490:	df 90       	pop	r13
     492:	cf 90       	pop	r12
     494:	bf 90       	pop	r11
     496:	af 90       	pop	r10
     498:	9f 90       	pop	r9
     49a:	8f 90       	pop	r8
     49c:	7f 90       	pop	r7
     49e:	6f 90       	pop	r6
     4a0:	5f 90       	pop	r5
     4a2:	4f 90       	pop	r4
     4a4:	3f 90       	pop	r3
     4a6:	2f 90       	pop	r2
     4a8:	1f 90       	pop	r1
     4aa:	0f 90       	pop	r0
     4ac:	0f be       	out	0x3f, r0	; 63
     4ae:	0f 90       	pop	r0

	asm volatile ( "ret" );
     4b0:	08 95       	ret

000004b2 <__vector_7>:
	 * DeeThe: Changed from SIG_OUTPUT_COMPARE1A to TIMER1_COMPA_vect
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     4b2:	0e 94 fd 01 	call	0x3fa	; 0x3fa <vPortYieldFromTick>
		asm volatile ( "reti" );
     4b6:	18 95       	reti

000004b8 <prvHeapInit>:

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     4b8:	ea ef       	ldi	r30, 0xFA	; 250
     4ba:	f0 e0       	ldi	r31, 0x00	; 0
     4bc:	ae ef       	ldi	r26, 0xFE	; 254
     4be:	b0 e0       	ldi	r27, 0x00	; 0
     4c0:	b1 83       	std	Z+1, r27	; 0x01
     4c2:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
     4c4:	13 82       	std	Z+3, r1	; 0x03
     4c6:	12 82       	std	Z+2, r1	; 0x02

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
     4c8:	e6 ed       	ldi	r30, 0xD6	; 214
     4ca:	f6 e0       	ldi	r31, 0x06	; 6
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
     4cc:	f0 93 f9 00 	sts	0x00F9, r31	; 0x8000f9 <pxEnd+0x1>
     4d0:	e0 93 f8 00 	sts	0x00F8, r30	; 0x8000f8 <pxEnd>
	pxEnd->xBlockSize = 0;
     4d4:	13 82       	std	Z+3, r1	; 0x03
     4d6:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
     4d8:	11 82       	std	Z+1, r1	; 0x01
     4da:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
     4dc:	88 ed       	ldi	r24, 0xD8	; 216
     4de:	95 e0       	ldi	r25, 0x05	; 5
     4e0:	13 96       	adiw	r26, 0x03	; 3
     4e2:	9c 93       	st	X, r25
     4e4:	8e 93       	st	-X, r24
     4e6:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
     4e8:	ed 93       	st	X+, r30
     4ea:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     4ec:	90 93 f5 00 	sts	0x00F5, r25	; 0x8000f5 <xMinimumEverFreeBytesRemaining+0x1>
     4f0:	80 93 f4 00 	sts	0x00F4, r24	; 0x8000f4 <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     4f4:	90 93 f7 00 	sts	0x00F7, r25	; 0x8000f7 <xFreeBytesRemaining+0x1>
     4f8:	80 93 f6 00 	sts	0x00F6, r24	; 0x8000f6 <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
     4fc:	80 e0       	ldi	r24, 0x00	; 0
     4fe:	90 e8       	ldi	r25, 0x80	; 128
     500:	90 93 f3 00 	sts	0x00F3, r25	; 0x8000f3 <__data_end+0x1>
     504:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__data_end>
     508:	08 95       	ret

0000050a <prvInsertBlockIntoFreeList>:
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
     50a:	cf 93       	push	r28
     50c:	df 93       	push	r29
     50e:	ec 01       	movw	r28, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     510:	aa ef       	ldi	r26, 0xFA	; 250
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	01 c0       	rjmp	.+2      	; 0x518 <prvInsertBlockIntoFreeList+0xe>
     516:	df 01       	movw	r26, r30
     518:	ed 91       	ld	r30, X+
     51a:	fc 91       	ld	r31, X
     51c:	11 97       	sbiw	r26, 0x01	; 1
     51e:	ec 17       	cp	r30, r28
     520:	fd 07       	cpc	r31, r29
     522:	c8 f3       	brcs	.-14     	; 0x516 <prvInsertBlockIntoFreeList+0xc>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
     524:	12 96       	adiw	r26, 0x02	; 2
     526:	8d 91       	ld	r24, X+
     528:	9c 91       	ld	r25, X
     52a:	13 97       	sbiw	r26, 0x03	; 3
     52c:	9d 01       	movw	r18, r26
     52e:	28 0f       	add	r18, r24
     530:	39 1f       	adc	r19, r25
     532:	c2 17       	cp	r28, r18
     534:	d3 07       	cpc	r29, r19
     536:	49 f4       	brne	.+18     	; 0x54a <prvInsertBlockIntoFreeList+0x40>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
     538:	2a 81       	ldd	r18, Y+2	; 0x02
     53a:	3b 81       	ldd	r19, Y+3	; 0x03
     53c:	82 0f       	add	r24, r18
     53e:	93 1f       	adc	r25, r19
     540:	13 96       	adiw	r26, 0x03	; 3
     542:	9c 93       	st	X, r25
     544:	8e 93       	st	-X, r24
     546:	12 97       	sbiw	r26, 0x02	; 2
		pxBlockToInsert = pxIterator;
     548:	ed 01       	movw	r28, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     54a:	8a 81       	ldd	r24, Y+2	; 0x02
     54c:	9b 81       	ldd	r25, Y+3	; 0x03
     54e:	9e 01       	movw	r18, r28
     550:	28 0f       	add	r18, r24
     552:	39 1f       	adc	r19, r25
     554:	e2 17       	cp	r30, r18
     556:	f3 07       	cpc	r31, r19
     558:	c1 f4       	brne	.+48     	; 0x58a <prvInsertBlockIntoFreeList+0x80>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
     55a:	20 91 f8 00 	lds	r18, 0x00F8	; 0x8000f8 <pxEnd>
     55e:	30 91 f9 00 	lds	r19, 0x00F9	; 0x8000f9 <pxEnd+0x1>
     562:	e2 17       	cp	r30, r18
     564:	f3 07       	cpc	r31, r19
     566:	71 f0       	breq	.+28     	; 0x584 <prvInsertBlockIntoFreeList+0x7a>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
     568:	22 81       	ldd	r18, Z+2	; 0x02
     56a:	33 81       	ldd	r19, Z+3	; 0x03
     56c:	82 0f       	add	r24, r18
     56e:	93 1f       	adc	r25, r19
     570:	9b 83       	std	Y+3, r25	; 0x03
     572:	8a 83       	std	Y+2, r24	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
     574:	ed 91       	ld	r30, X+
     576:	fc 91       	ld	r31, X
     578:	11 97       	sbiw	r26, 0x01	; 1
     57a:	80 81       	ld	r24, Z
     57c:	91 81       	ldd	r25, Z+1	; 0x01
     57e:	99 83       	std	Y+1, r25	; 0x01
     580:	88 83       	st	Y, r24
     582:	05 c0       	rjmp	.+10     	; 0x58e <prvInsertBlockIntoFreeList+0x84>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
     584:	39 83       	std	Y+1, r19	; 0x01
     586:	28 83       	st	Y, r18
     588:	02 c0       	rjmp	.+4      	; 0x58e <prvInsertBlockIntoFreeList+0x84>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
     58a:	f9 83       	std	Y+1, r31	; 0x01
     58c:	e8 83       	st	Y, r30

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
     58e:	ca 17       	cp	r28, r26
     590:	db 07       	cpc	r29, r27
     592:	11 f0       	breq	.+4      	; 0x598 <prvInsertBlockIntoFreeList+0x8e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
     594:	cd 93       	st	X+, r28
     596:	dc 93       	st	X, r29
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
     598:	df 91       	pop	r29
     59a:	cf 91       	pop	r28
     59c:	08 95       	ret

0000059e <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     59e:	ef 92       	push	r14
     5a0:	ff 92       	push	r15
     5a2:	0f 93       	push	r16
     5a4:	1f 93       	push	r17
     5a6:	cf 93       	push	r28
     5a8:	df 93       	push	r29
     5aa:	8c 01       	movw	r16, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
     5ac:	0e 94 77 05 	call	0xaee	; 0xaee <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
     5b0:	80 91 f8 00 	lds	r24, 0x00F8	; 0x8000f8 <pxEnd>
     5b4:	90 91 f9 00 	lds	r25, 0x00F9	; 0x8000f9 <pxEnd+0x1>
     5b8:	89 2b       	or	r24, r25
     5ba:	11 f4       	brne	.+4      	; 0x5c0 <pvPortMalloc+0x22>
		{
			prvHeapInit();
     5bc:	0e 94 5c 02 	call	0x4b8	; 0x4b8 <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
     5c0:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__data_end>
     5c4:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__data_end+0x1>
     5c8:	80 23       	and	r24, r16
     5ca:	91 23       	and	r25, r17
     5cc:	89 2b       	or	r24, r25
     5ce:	09 f0       	breq	.+2      	; 0x5d2 <pvPortMalloc+0x34>
     5d0:	67 c0       	rjmp	.+206    	; 0x6a0 <pvPortMalloc+0x102>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
     5d2:	01 15       	cp	r16, r1
     5d4:	11 05       	cpc	r17, r1
     5d6:	11 f0       	breq	.+4      	; 0x5dc <pvPortMalloc+0x3e>
			{
				xWantedSize += xHeapStructSize;
     5d8:	0c 5f       	subi	r16, 0xFC	; 252
     5da:	1f 4f       	sbci	r17, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
     5dc:	01 15       	cp	r16, r1
     5de:	11 05       	cpc	r17, r1
     5e0:	09 f4       	brne	.+2      	; 0x5e4 <pvPortMalloc+0x46>
     5e2:	61 c0       	rjmp	.+194    	; 0x6a6 <pvPortMalloc+0x108>
     5e4:	80 91 f6 00 	lds	r24, 0x00F6	; 0x8000f6 <xFreeBytesRemaining>
     5e8:	90 91 f7 00 	lds	r25, 0x00F7	; 0x8000f7 <xFreeBytesRemaining+0x1>
     5ec:	80 17       	cp	r24, r16
     5ee:	91 07       	cpc	r25, r17
     5f0:	08 f4       	brcc	.+2      	; 0x5f4 <pvPortMalloc+0x56>
     5f2:	5c c0       	rjmp	.+184    	; 0x6ac <pvPortMalloc+0x10e>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
     5f4:	c0 91 fa 00 	lds	r28, 0x00FA	; 0x8000fa <xStart>
     5f8:	d0 91 fb 00 	lds	r29, 0x00FB	; 0x8000fb <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
     5fc:	ea ef       	ldi	r30, 0xFA	; 250
     5fe:	f0 e0       	ldi	r31, 0x00	; 0
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     600:	02 c0       	rjmp	.+4      	; 0x606 <pvPortMalloc+0x68>
				{
					pxPreviousBlock = pxBlock;
     602:	fe 01       	movw	r30, r28
					pxBlock = pxBlock->pxNextFreeBlock;
     604:	ec 01       	movw	r28, r24
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     606:	8a 81       	ldd	r24, Y+2	; 0x02
     608:	9b 81       	ldd	r25, Y+3	; 0x03
     60a:	80 17       	cp	r24, r16
     60c:	91 07       	cpc	r25, r17
     60e:	20 f4       	brcc	.+8      	; 0x618 <pvPortMalloc+0x7a>
     610:	88 81       	ld	r24, Y
     612:	99 81       	ldd	r25, Y+1	; 0x01
     614:	00 97       	sbiw	r24, 0x00	; 0
     616:	a9 f7       	brne	.-22     	; 0x602 <pvPortMalloc+0x64>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
     618:	80 91 f8 00 	lds	r24, 0x00F8	; 0x8000f8 <pxEnd>
     61c:	90 91 f9 00 	lds	r25, 0x00F9	; 0x8000f9 <pxEnd+0x1>
     620:	c8 17       	cp	r28, r24
     622:	d9 07       	cpc	r29, r25
     624:	09 f4       	brne	.+2      	; 0x628 <pvPortMalloc+0x8a>
     626:	45 c0       	rjmp	.+138    	; 0x6b2 <pvPortMalloc+0x114>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     628:	e0 80       	ld	r14, Z
     62a:	f1 80       	ldd	r15, Z+1	; 0x01
     62c:	84 e0       	ldi	r24, 0x04	; 4
     62e:	e8 0e       	add	r14, r24
     630:	f1 1c       	adc	r15, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     632:	88 81       	ld	r24, Y
     634:	99 81       	ldd	r25, Y+1	; 0x01
     636:	91 83       	std	Z+1, r25	; 0x01
     638:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     63a:	2a 81       	ldd	r18, Y+2	; 0x02
     63c:	3b 81       	ldd	r19, Y+3	; 0x03
     63e:	20 1b       	sub	r18, r16
     640:	31 0b       	sbc	r19, r17
     642:	29 30       	cpi	r18, 0x09	; 9
     644:	31 05       	cpc	r19, r1
     646:	50 f0       	brcs	.+20     	; 0x65c <pvPortMalloc+0xbe>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     648:	ce 01       	movw	r24, r28
     64a:	80 0f       	add	r24, r16
     64c:	91 1f       	adc	r25, r17
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     64e:	fc 01       	movw	r30, r24
     650:	33 83       	std	Z+3, r19	; 0x03
     652:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
     654:	1b 83       	std	Y+3, r17	; 0x03
     656:	0a 83       	std	Y+2, r16	; 0x02

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
     658:	0e 94 85 02 	call	0x50a	; 0x50a <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
     65c:	2a 81       	ldd	r18, Y+2	; 0x02
     65e:	3b 81       	ldd	r19, Y+3	; 0x03
     660:	80 91 f6 00 	lds	r24, 0x00F6	; 0x8000f6 <xFreeBytesRemaining>
     664:	90 91 f7 00 	lds	r25, 0x00F7	; 0x8000f7 <xFreeBytesRemaining+0x1>
     668:	82 1b       	sub	r24, r18
     66a:	93 0b       	sbc	r25, r19
     66c:	90 93 f7 00 	sts	0x00F7, r25	; 0x8000f7 <xFreeBytesRemaining+0x1>
     670:	80 93 f6 00 	sts	0x00F6, r24	; 0x8000f6 <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
     674:	40 91 f4 00 	lds	r20, 0x00F4	; 0x8000f4 <xMinimumEverFreeBytesRemaining>
     678:	50 91 f5 00 	lds	r21, 0x00F5	; 0x8000f5 <xMinimumEverFreeBytesRemaining+0x1>
     67c:	84 17       	cp	r24, r20
     67e:	95 07       	cpc	r25, r21
     680:	20 f4       	brcc	.+8      	; 0x68a <pvPortMalloc+0xec>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
     682:	90 93 f5 00 	sts	0x00F5, r25	; 0x8000f5 <xMinimumEverFreeBytesRemaining+0x1>
     686:	80 93 f4 00 	sts	0x00F4, r24	; 0x8000f4 <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
     68a:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__data_end>
     68e:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__data_end+0x1>
     692:	28 2b       	or	r18, r24
     694:	39 2b       	or	r19, r25
     696:	3b 83       	std	Y+3, r19	; 0x03
     698:	2a 83       	std	Y+2, r18	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
     69a:	19 82       	std	Y+1, r1	; 0x01
     69c:	18 82       	st	Y, r1
     69e:	0b c0       	rjmp	.+22     	; 0x6b6 <pvPortMalloc+0x118>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
     6a0:	e1 2c       	mov	r14, r1
     6a2:	f1 2c       	mov	r15, r1
     6a4:	08 c0       	rjmp	.+16     	; 0x6b6 <pvPortMalloc+0x118>
     6a6:	e1 2c       	mov	r14, r1
     6a8:	f1 2c       	mov	r15, r1
     6aa:	05 c0       	rjmp	.+10     	; 0x6b6 <pvPortMalloc+0x118>
     6ac:	e1 2c       	mov	r14, r1
     6ae:	f1 2c       	mov	r15, r1
     6b0:	02 c0       	rjmp	.+4      	; 0x6b6 <pvPortMalloc+0x118>
     6b2:	e1 2c       	mov	r14, r1
     6b4:	f1 2c       	mov	r15, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     6b6:	0e 94 41 06 	call	0xc82	; 0xc82 <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
     6ba:	c7 01       	movw	r24, r14
     6bc:	df 91       	pop	r29
     6be:	cf 91       	pop	r28
     6c0:	1f 91       	pop	r17
     6c2:	0f 91       	pop	r16
     6c4:	ff 90       	pop	r15
     6c6:	ef 90       	pop	r14
     6c8:	08 95       	ret

000006ca <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     6ca:	0f 93       	push	r16
     6cc:	1f 93       	push	r17
     6ce:	cf 93       	push	r28
     6d0:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     6d2:	00 97       	sbiw	r24, 0x00	; 0
     6d4:	51 f1       	breq	.+84     	; 0x72a <vPortFree+0x60>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
     6d6:	ec 01       	movw	r28, r24
     6d8:	24 97       	sbiw	r28, 0x04	; 4

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
     6da:	4a 81       	ldd	r20, Y+2	; 0x02
     6dc:	5b 81       	ldd	r21, Y+3	; 0x03
     6de:	20 91 f2 00 	lds	r18, 0x00F2	; 0x8000f2 <__data_end>
     6e2:	30 91 f3 00 	lds	r19, 0x00F3	; 0x8000f3 <__data_end+0x1>
     6e6:	ba 01       	movw	r22, r20
     6e8:	62 23       	and	r22, r18
     6ea:	73 23       	and	r23, r19
     6ec:	67 2b       	or	r22, r23
     6ee:	e9 f0       	breq	.+58     	; 0x72a <vPortFree+0x60>
		{
			if( pxLink->pxNextFreeBlock == NULL )
     6f0:	68 81       	ld	r22, Y
     6f2:	79 81       	ldd	r23, Y+1	; 0x01
     6f4:	67 2b       	or	r22, r23
     6f6:	c9 f4       	brne	.+50     	; 0x72a <vPortFree+0x60>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
     6f8:	20 95       	com	r18
     6fa:	30 95       	com	r19
     6fc:	24 23       	and	r18, r20
     6fe:	35 23       	and	r19, r21
     700:	3b 83       	std	Y+3, r19	; 0x03
     702:	2a 83       	std	Y+2, r18	; 0x02

				vTaskSuspendAll();
     704:	0e 94 77 05 	call	0xaee	; 0xaee <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
     708:	8a 81       	ldd	r24, Y+2	; 0x02
     70a:	9b 81       	ldd	r25, Y+3	; 0x03
     70c:	20 91 f6 00 	lds	r18, 0x00F6	; 0x8000f6 <xFreeBytesRemaining>
     710:	30 91 f7 00 	lds	r19, 0x00F7	; 0x8000f7 <xFreeBytesRemaining+0x1>
     714:	82 0f       	add	r24, r18
     716:	93 1f       	adc	r25, r19
     718:	90 93 f7 00 	sts	0x00F7, r25	; 0x8000f7 <xFreeBytesRemaining+0x1>
     71c:	80 93 f6 00 	sts	0x00F6, r24	; 0x8000f6 <xFreeBytesRemaining>
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     720:	ce 01       	movw	r24, r28
     722:	0e 94 85 02 	call	0x50a	; 0x50a <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
     726:	0e 94 41 06 	call	0xc82	; 0xc82 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     72a:	df 91       	pop	r29
     72c:	cf 91       	pop	r28
     72e:	1f 91       	pop	r17
     730:	0f 91       	pop	r16
     732:	08 95       	ret

00000734 <prvResetNextTaskUnblockTime>:
	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     734:	e0 91 f3 06 	lds	r30, 0x06F3	; 0x8006f3 <pxDelayedTaskList>
     738:	f0 91 f4 06 	lds	r31, 0x06F4	; 0x8006f4 <pxDelayedTaskList+0x1>
     73c:	80 81       	ld	r24, Z
     73e:	81 11       	cpse	r24, r1
     740:	07 c0       	rjmp	.+14     	; 0x750 <prvResetNextTaskUnblockTime+0x1c>
     742:	8f ef       	ldi	r24, 0xFF	; 255
     744:	9f ef       	ldi	r25, 0xFF	; 255
     746:	90 93 de 06 	sts	0x06DE, r25	; 0x8006de <xNextTaskUnblockTime+0x1>
     74a:	80 93 dd 06 	sts	0x06DD, r24	; 0x8006dd <xNextTaskUnblockTime>
     74e:	08 95       	ret
     750:	e0 91 f3 06 	lds	r30, 0x06F3	; 0x8006f3 <pxDelayedTaskList>
     754:	f0 91 f4 06 	lds	r31, 0x06F4	; 0x8006f4 <pxDelayedTaskList+0x1>
     758:	05 80       	ldd	r0, Z+5	; 0x05
     75a:	f6 81       	ldd	r31, Z+6	; 0x06
     75c:	e0 2d       	mov	r30, r0
     75e:	06 80       	ldd	r0, Z+6	; 0x06
     760:	f7 81       	ldd	r31, Z+7	; 0x07
     762:	e0 2d       	mov	r30, r0
     764:	82 81       	ldd	r24, Z+2	; 0x02
     766:	93 81       	ldd	r25, Z+3	; 0x03
     768:	90 93 de 06 	sts	0x06DE, r25	; 0x8006de <xNextTaskUnblockTime+0x1>
     76c:	80 93 dd 06 	sts	0x06DD, r24	; 0x8006dd <xNextTaskUnblockTime>
     770:	08 95       	ret

00000772 <prvInitialiseNewTask>:
     772:	6f 92       	push	r6
     774:	7f 92       	push	r7
     776:	8f 92       	push	r8
     778:	9f 92       	push	r9
     77a:	af 92       	push	r10
     77c:	bf 92       	push	r11
     77e:	cf 92       	push	r12
     780:	df 92       	push	r13
     782:	ef 92       	push	r14
     784:	0f 93       	push	r16
     786:	1f 93       	push	r17
     788:	cf 93       	push	r28
     78a:	df 93       	push	r29
     78c:	cd b7       	in	r28, 0x3d	; 61
     78e:	de b7       	in	r29, 0x3e	; 62
     790:	4c 01       	movw	r8, r24
     792:	f5 01       	movw	r30, r10
     794:	87 89       	ldd	r24, Z+23	; 0x17
     796:	90 8d       	ldd	r25, Z+24	; 0x18
     798:	21 50       	subi	r18, 0x01	; 1
     79a:	31 09       	sbc	r19, r1
     79c:	3c 01       	movw	r6, r24
     79e:	62 0e       	add	r6, r18
     7a0:	73 1e       	adc	r7, r19
     7a2:	20 e0       	ldi	r18, 0x00	; 0
     7a4:	0f c0       	rjmp	.+30     	; 0x7c4 <prvInitialiseNewTask+0x52>
     7a6:	82 2f       	mov	r24, r18
     7a8:	90 e0       	ldi	r25, 0x00	; 0
     7aa:	fb 01       	movw	r30, r22
     7ac:	e8 0f       	add	r30, r24
     7ae:	f9 1f       	adc	r31, r25
     7b0:	30 81       	ld	r19, Z
     7b2:	d5 01       	movw	r26, r10
     7b4:	a8 0f       	add	r26, r24
     7b6:	b9 1f       	adc	r27, r25
     7b8:	59 96       	adiw	r26, 0x19	; 25
     7ba:	3c 93       	st	X, r19
     7bc:	80 81       	ld	r24, Z
     7be:	88 23       	and	r24, r24
     7c0:	19 f0       	breq	.+6      	; 0x7c8 <prvInitialiseNewTask+0x56>
     7c2:	2f 5f       	subi	r18, 0xFF	; 255
     7c4:	28 30       	cpi	r18, 0x08	; 8
     7c6:	78 f3       	brcs	.-34     	; 0x7a6 <prvInitialiseNewTask+0x34>
     7c8:	f5 01       	movw	r30, r10
     7ca:	10 a2       	std	Z+32, r1	; 0x20
     7cc:	f3 e0       	ldi	r31, 0x03	; 3
     7ce:	fe 15       	cp	r31, r14
     7d0:	20 f4       	brcc	.+8      	; 0x7da <prvInitialiseNewTask+0x68>
     7d2:	0f 2e       	mov	r0, r31
     7d4:	f3 e0       	ldi	r31, 0x03	; 3
     7d6:	ef 2e       	mov	r14, r31
     7d8:	f0 2d       	mov	r31, r0
     7da:	f5 01       	movw	r30, r10
     7dc:	e6 8a       	std	Z+22, r14	; 0x16
     7de:	c5 01       	movw	r24, r10
     7e0:	02 96       	adiw	r24, 0x02	; 2
     7e2:	0e 94 84 00 	call	0x108	; 0x108 <vListInitialiseItem>
     7e6:	c5 01       	movw	r24, r10
     7e8:	0c 96       	adiw	r24, 0x0c	; 12
     7ea:	0e 94 84 00 	call	0x108	; 0x108 <vListInitialiseItem>
     7ee:	f5 01       	movw	r30, r10
     7f0:	b1 86       	std	Z+9, r11	; 0x09
     7f2:	a0 86       	std	Z+8, r10	; 0x08
     7f4:	84 e0       	ldi	r24, 0x04	; 4
     7f6:	90 e0       	ldi	r25, 0x00	; 0
     7f8:	8e 19       	sub	r24, r14
     7fa:	91 09       	sbc	r25, r1
     7fc:	95 87       	std	Z+13, r25	; 0x0d
     7fe:	84 87       	std	Z+12, r24	; 0x0c
     800:	b3 8a       	std	Z+19, r11	; 0x13
     802:	a2 8a       	std	Z+18, r10	; 0x12
     804:	11 a2       	std	Z+33, r1	; 0x21
     806:	12 a2       	std	Z+34, r1	; 0x22
     808:	13 a2       	std	Z+35, r1	; 0x23
     80a:	14 a2       	std	Z+36, r1	; 0x24
     80c:	15 a2       	std	Z+37, r1	; 0x25
     80e:	a8 01       	movw	r20, r16
     810:	b4 01       	movw	r22, r8
     812:	c3 01       	movw	r24, r6
     814:	0e 94 09 01 	call	0x212	; 0x212 <pxPortInitialiseStack>
     818:	f5 01       	movw	r30, r10
     81a:	91 83       	std	Z+1, r25	; 0x01
     81c:	80 83       	st	Z, r24
     81e:	c1 14       	cp	r12, r1
     820:	d1 04       	cpc	r13, r1
     822:	19 f0       	breq	.+6      	; 0x82a <__DATA_REGION_LENGTH__+0x2a>
     824:	f6 01       	movw	r30, r12
     826:	b1 82       	std	Z+1, r11	; 0x01
     828:	a0 82       	st	Z, r10
     82a:	df 91       	pop	r29
     82c:	cf 91       	pop	r28
     82e:	1f 91       	pop	r17
     830:	0f 91       	pop	r16
     832:	ef 90       	pop	r14
     834:	df 90       	pop	r13
     836:	cf 90       	pop	r12
     838:	bf 90       	pop	r11
     83a:	af 90       	pop	r10
     83c:	9f 90       	pop	r9
     83e:	8f 90       	pop	r8
     840:	7f 90       	pop	r7
     842:	6f 90       	pop	r6
     844:	08 95       	ret

00000846 <prvIdleTask>:
     846:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <pxReadyTasksLists>
     84a:	82 30       	cpi	r24, 0x02	; 2
     84c:	e0 f3       	brcs	.-8      	; 0x846 <prvIdleTask>
     84e:	0e 94 a4 01 	call	0x348	; 0x348 <vPortYield>
     852:	f9 cf       	rjmp	.-14     	; 0x846 <prvIdleTask>

00000854 <prvInitialiseTaskLists>:
     854:	cf 93       	push	r28
     856:	c0 e0       	ldi	r28, 0x00	; 0
     858:	10 c0       	rjmp	.+32     	; 0x87a <__stack+0x1b>
     85a:	8c 2f       	mov	r24, r28
     85c:	90 e0       	ldi	r25, 0x00	; 0
     85e:	9c 01       	movw	r18, r24
     860:	22 0f       	add	r18, r18
     862:	33 1f       	adc	r19, r19
     864:	22 0f       	add	r18, r18
     866:	33 1f       	adc	r19, r19
     868:	22 0f       	add	r18, r18
     86a:	33 1f       	adc	r19, r19
     86c:	82 0f       	add	r24, r18
     86e:	93 1f       	adc	r25, r19
     870:	89 5f       	subi	r24, 0xF9	; 249
     872:	98 4f       	sbci	r25, 0xF8	; 248
     874:	0e 94 76 00 	call	0xec	; 0xec <vListInitialise>
     878:	cf 5f       	subi	r28, 0xFF	; 255
     87a:	c4 30       	cpi	r28, 0x04	; 4
     87c:	70 f3       	brcs	.-36     	; 0x85a <prvInitialiseTaskLists+0x6>
     87e:	8e ef       	ldi	r24, 0xFE	; 254
     880:	96 e0       	ldi	r25, 0x06	; 6
     882:	0e 94 76 00 	call	0xec	; 0xec <vListInitialise>
     886:	85 ef       	ldi	r24, 0xF5	; 245
     888:	96 e0       	ldi	r25, 0x06	; 6
     88a:	0e 94 76 00 	call	0xec	; 0xec <vListInitialise>
     88e:	88 ee       	ldi	r24, 0xE8	; 232
     890:	96 e0       	ldi	r25, 0x06	; 6
     892:	0e 94 76 00 	call	0xec	; 0xec <vListInitialise>
     896:	8e ef       	ldi	r24, 0xFE	; 254
     898:	96 e0       	ldi	r25, 0x06	; 6
     89a:	90 93 f4 06 	sts	0x06F4, r25	; 0x8006f4 <pxDelayedTaskList+0x1>
     89e:	80 93 f3 06 	sts	0x06F3, r24	; 0x8006f3 <pxDelayedTaskList>
     8a2:	85 ef       	ldi	r24, 0xF5	; 245
     8a4:	96 e0       	ldi	r25, 0x06	; 6
     8a6:	90 93 f2 06 	sts	0x06F2, r25	; 0x8006f2 <pxOverflowDelayedTaskList+0x1>
     8aa:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <pxOverflowDelayedTaskList>
     8ae:	cf 91       	pop	r28
     8b0:	08 95       	ret

000008b2 <prvAddNewTaskToReadyList>:
     8b2:	cf 93       	push	r28
     8b4:	df 93       	push	r29
     8b6:	ec 01       	movw	r28, r24
     8b8:	0f b6       	in	r0, 0x3f	; 63
     8ba:	f8 94       	cli
     8bc:	0f 92       	push	r0
     8be:	80 91 e7 06 	lds	r24, 0x06E7	; 0x8006e7 <uxCurrentNumberOfTasks>
     8c2:	8f 5f       	subi	r24, 0xFF	; 255
     8c4:	80 93 e7 06 	sts	0x06E7, r24	; 0x8006e7 <uxCurrentNumberOfTasks>
     8c8:	80 91 2b 07 	lds	r24, 0x072B	; 0x80072b <pxCurrentTCB>
     8cc:	90 91 2c 07 	lds	r25, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     8d0:	89 2b       	or	r24, r25
     8d2:	59 f4       	brne	.+22     	; 0x8ea <prvAddNewTaskToReadyList+0x38>
     8d4:	d0 93 2c 07 	sts	0x072C, r29	; 0x80072c <pxCurrentTCB+0x1>
     8d8:	c0 93 2b 07 	sts	0x072B, r28	; 0x80072b <pxCurrentTCB>
     8dc:	80 91 e7 06 	lds	r24, 0x06E7	; 0x8006e7 <uxCurrentNumberOfTasks>
     8e0:	81 30       	cpi	r24, 0x01	; 1
     8e2:	99 f4       	brne	.+38     	; 0x90a <prvAddNewTaskToReadyList+0x58>
     8e4:	0e 94 2a 04 	call	0x854	; 0x854 <prvInitialiseTaskLists>
     8e8:	10 c0       	rjmp	.+32     	; 0x90a <prvAddNewTaskToReadyList+0x58>
     8ea:	80 91 e3 06 	lds	r24, 0x06E3	; 0x8006e3 <xSchedulerRunning>
     8ee:	81 11       	cpse	r24, r1
     8f0:	0c c0       	rjmp	.+24     	; 0x90a <prvAddNewTaskToReadyList+0x58>
     8f2:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxCurrentTCB>
     8f6:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     8fa:	96 89       	ldd	r25, Z+22	; 0x16
     8fc:	8e 89       	ldd	r24, Y+22	; 0x16
     8fe:	89 17       	cp	r24, r25
     900:	20 f0       	brcs	.+8      	; 0x90a <prvAddNewTaskToReadyList+0x58>
     902:	d0 93 2c 07 	sts	0x072C, r29	; 0x80072c <pxCurrentTCB+0x1>
     906:	c0 93 2b 07 	sts	0x072B, r28	; 0x80072b <pxCurrentTCB>
     90a:	80 91 df 06 	lds	r24, 0x06DF	; 0x8006df <uxTaskNumber>
     90e:	8f 5f       	subi	r24, 0xFF	; 255
     910:	80 93 df 06 	sts	0x06DF, r24	; 0x8006df <uxTaskNumber>
     914:	8e 89       	ldd	r24, Y+22	; 0x16
     916:	90 91 e4 06 	lds	r25, 0x06E4	; 0x8006e4 <uxTopReadyPriority>
     91a:	98 17       	cp	r25, r24
     91c:	10 f4       	brcc	.+4      	; 0x922 <prvAddNewTaskToReadyList+0x70>
     91e:	80 93 e4 06 	sts	0x06E4, r24	; 0x8006e4 <uxTopReadyPriority>
     922:	90 e0       	ldi	r25, 0x00	; 0
     924:	9c 01       	movw	r18, r24
     926:	22 0f       	add	r18, r18
     928:	33 1f       	adc	r19, r19
     92a:	22 0f       	add	r18, r18
     92c:	33 1f       	adc	r19, r19
     92e:	22 0f       	add	r18, r18
     930:	33 1f       	adc	r19, r19
     932:	82 0f       	add	r24, r18
     934:	93 1f       	adc	r25, r19
     936:	be 01       	movw	r22, r28
     938:	6e 5f       	subi	r22, 0xFE	; 254
     93a:	7f 4f       	sbci	r23, 0xFF	; 255
     93c:	89 5f       	subi	r24, 0xF9	; 249
     93e:	98 4f       	sbci	r25, 0xF8	; 248
     940:	0e 94 88 00 	call	0x110	; 0x110 <vListInsertEnd>
     944:	0f 90       	pop	r0
     946:	0f be       	out	0x3f, r0	; 63
     948:	80 91 e3 06 	lds	r24, 0x06E3	; 0x8006e3 <xSchedulerRunning>
     94c:	88 23       	and	r24, r24
     94e:	51 f0       	breq	.+20     	; 0x964 <prvAddNewTaskToReadyList+0xb2>
     950:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxCurrentTCB>
     954:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     958:	96 89       	ldd	r25, Z+22	; 0x16
     95a:	8e 89       	ldd	r24, Y+22	; 0x16
     95c:	98 17       	cp	r25, r24
     95e:	10 f4       	brcc	.+4      	; 0x964 <prvAddNewTaskToReadyList+0xb2>
     960:	0e 94 a4 01 	call	0x348	; 0x348 <vPortYield>
     964:	df 91       	pop	r29
     966:	cf 91       	pop	r28
     968:	08 95       	ret

0000096a <prvAddCurrentTaskToDelayedList>:
     96a:	0f 93       	push	r16
     96c:	1f 93       	push	r17
     96e:	cf 93       	push	r28
     970:	df 93       	push	r29
     972:	ec 01       	movw	r28, r24
     974:	00 91 e5 06 	lds	r16, 0x06E5	; 0x8006e5 <xTickCount>
     978:	10 91 e6 06 	lds	r17, 0x06E6	; 0x8006e6 <xTickCount+0x1>
     97c:	80 91 2b 07 	lds	r24, 0x072B	; 0x80072b <pxCurrentTCB>
     980:	90 91 2c 07 	lds	r25, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     984:	02 96       	adiw	r24, 0x02	; 2
     986:	0e 94 da 00 	call	0x1b4	; 0x1b4 <uxListRemove>
     98a:	c0 0f       	add	r28, r16
     98c:	d1 1f       	adc	r29, r17
     98e:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxCurrentTCB>
     992:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     996:	d3 83       	std	Z+3, r29	; 0x03
     998:	c2 83       	std	Z+2, r28	; 0x02
     99a:	c0 17       	cp	r28, r16
     99c:	d1 07       	cpc	r29, r17
     99e:	68 f4       	brcc	.+26     	; 0x9ba <prvAddCurrentTaskToDelayedList+0x50>
     9a0:	60 91 2b 07 	lds	r22, 0x072B	; 0x80072b <pxCurrentTCB>
     9a4:	70 91 2c 07 	lds	r23, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     9a8:	80 91 f1 06 	lds	r24, 0x06F1	; 0x8006f1 <pxOverflowDelayedTaskList>
     9ac:	90 91 f2 06 	lds	r25, 0x06F2	; 0x8006f2 <pxOverflowDelayedTaskList+0x1>
     9b0:	6e 5f       	subi	r22, 0xFE	; 254
     9b2:	7f 4f       	sbci	r23, 0xFF	; 255
     9b4:	0e 94 a9 00 	call	0x152	; 0x152 <vListInsert>
     9b8:	17 c0       	rjmp	.+46     	; 0x9e8 <prvAddCurrentTaskToDelayedList+0x7e>
     9ba:	60 91 2b 07 	lds	r22, 0x072B	; 0x80072b <pxCurrentTCB>
     9be:	70 91 2c 07 	lds	r23, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     9c2:	80 91 f3 06 	lds	r24, 0x06F3	; 0x8006f3 <pxDelayedTaskList>
     9c6:	90 91 f4 06 	lds	r25, 0x06F4	; 0x8006f4 <pxDelayedTaskList+0x1>
     9ca:	6e 5f       	subi	r22, 0xFE	; 254
     9cc:	7f 4f       	sbci	r23, 0xFF	; 255
     9ce:	0e 94 a9 00 	call	0x152	; 0x152 <vListInsert>
     9d2:	80 91 dd 06 	lds	r24, 0x06DD	; 0x8006dd <xNextTaskUnblockTime>
     9d6:	90 91 de 06 	lds	r25, 0x06DE	; 0x8006de <xNextTaskUnblockTime+0x1>
     9da:	c8 17       	cp	r28, r24
     9dc:	d9 07       	cpc	r29, r25
     9de:	20 f4       	brcc	.+8      	; 0x9e8 <prvAddCurrentTaskToDelayedList+0x7e>
     9e0:	d0 93 de 06 	sts	0x06DE, r29	; 0x8006de <xNextTaskUnblockTime+0x1>
     9e4:	c0 93 dd 06 	sts	0x06DD, r28	; 0x8006dd <xNextTaskUnblockTime>
     9e8:	df 91       	pop	r29
     9ea:	cf 91       	pop	r28
     9ec:	1f 91       	pop	r17
     9ee:	0f 91       	pop	r16
     9f0:	08 95       	ret

000009f2 <xTaskCreate>:
     9f2:	2f 92       	push	r2
     9f4:	3f 92       	push	r3
     9f6:	4f 92       	push	r4
     9f8:	5f 92       	push	r5
     9fa:	6f 92       	push	r6
     9fc:	7f 92       	push	r7
     9fe:	8f 92       	push	r8
     a00:	9f 92       	push	r9
     a02:	af 92       	push	r10
     a04:	bf 92       	push	r11
     a06:	cf 92       	push	r12
     a08:	df 92       	push	r13
     a0a:	ef 92       	push	r14
     a0c:	ff 92       	push	r15
     a0e:	0f 93       	push	r16
     a10:	1f 93       	push	r17
     a12:	cf 93       	push	r28
     a14:	df 93       	push	r29
     a16:	3c 01       	movw	r6, r24
     a18:	1b 01       	movw	r2, r22
     a1a:	5a 01       	movw	r10, r20
     a1c:	29 01       	movw	r4, r18
     a1e:	ca 01       	movw	r24, r20
     a20:	0e 94 cf 02 	call	0x59e	; 0x59e <pvPortMalloc>
     a24:	6c 01       	movw	r12, r24
     a26:	89 2b       	or	r24, r25
     a28:	71 f0       	breq	.+28     	; 0xa46 <xTaskCreate+0x54>
     a2a:	86 e2       	ldi	r24, 0x26	; 38
     a2c:	90 e0       	ldi	r25, 0x00	; 0
     a2e:	0e 94 cf 02 	call	0x59e	; 0x59e <pvPortMalloc>
     a32:	ec 01       	movw	r28, r24
     a34:	89 2b       	or	r24, r25
     a36:	19 f0       	breq	.+6      	; 0xa3e <xTaskCreate+0x4c>
     a38:	d8 8e       	std	Y+24, r13	; 0x18
     a3a:	cf 8a       	std	Y+23, r12	; 0x17
     a3c:	06 c0       	rjmp	.+12     	; 0xa4a <xTaskCreate+0x58>
     a3e:	c6 01       	movw	r24, r12
     a40:	0e 94 65 03 	call	0x6ca	; 0x6ca <vPortFree>
     a44:	02 c0       	rjmp	.+4      	; 0xa4a <xTaskCreate+0x58>
     a46:	c0 e0       	ldi	r28, 0x00	; 0
     a48:	d0 e0       	ldi	r29, 0x00	; 0
     a4a:	20 97       	sbiw	r28, 0x00	; 0
     a4c:	91 f0       	breq	.+36     	; 0xa72 <xTaskCreate+0x80>
     a4e:	95 01       	movw	r18, r10
     a50:	40 e0       	ldi	r20, 0x00	; 0
     a52:	50 e0       	ldi	r21, 0x00	; 0
     a54:	81 2c       	mov	r8, r1
     a56:	91 2c       	mov	r9, r1
     a58:	5e 01       	movw	r10, r28
     a5a:	67 01       	movw	r12, r14
     a5c:	e0 2e       	mov	r14, r16
     a5e:	82 01       	movw	r16, r4
     a60:	b1 01       	movw	r22, r2
     a62:	c3 01       	movw	r24, r6
     a64:	0e 94 b9 03 	call	0x772	; 0x772 <prvInitialiseNewTask>
     a68:	ce 01       	movw	r24, r28
     a6a:	0e 94 59 04 	call	0x8b2	; 0x8b2 <prvAddNewTaskToReadyList>
     a6e:	81 e0       	ldi	r24, 0x01	; 1
     a70:	01 c0       	rjmp	.+2      	; 0xa74 <xTaskCreate+0x82>
     a72:	8f ef       	ldi	r24, 0xFF	; 255
     a74:	df 91       	pop	r29
     a76:	cf 91       	pop	r28
     a78:	1f 91       	pop	r17
     a7a:	0f 91       	pop	r16
     a7c:	ff 90       	pop	r15
     a7e:	ef 90       	pop	r14
     a80:	df 90       	pop	r13
     a82:	cf 90       	pop	r12
     a84:	bf 90       	pop	r11
     a86:	af 90       	pop	r10
     a88:	9f 90       	pop	r9
     a8a:	8f 90       	pop	r8
     a8c:	7f 90       	pop	r7
     a8e:	6f 90       	pop	r6
     a90:	5f 90       	pop	r5
     a92:	4f 90       	pop	r4
     a94:	3f 90       	pop	r3
     a96:	2f 90       	pop	r2
     a98:	08 95       	ret

00000a9a <vTaskStartScheduler>:
     a9a:	ef 92       	push	r14
     a9c:	ff 92       	push	r15
     a9e:	0f 93       	push	r16
     aa0:	0f 2e       	mov	r0, r31
     aa2:	fb ed       	ldi	r31, 0xDB	; 219
     aa4:	ef 2e       	mov	r14, r31
     aa6:	f6 e0       	ldi	r31, 0x06	; 6
     aa8:	ff 2e       	mov	r15, r31
     aaa:	f0 2d       	mov	r31, r0
     aac:	00 e0       	ldi	r16, 0x00	; 0
     aae:	20 e0       	ldi	r18, 0x00	; 0
     ab0:	30 e0       	ldi	r19, 0x00	; 0
     ab2:	45 e5       	ldi	r20, 0x55	; 85
     ab4:	50 e0       	ldi	r21, 0x00	; 0
     ab6:	6e e6       	ldi	r22, 0x6E	; 110
     ab8:	70 e0       	ldi	r23, 0x00	; 0
     aba:	83 e2       	ldi	r24, 0x23	; 35
     abc:	94 e0       	ldi	r25, 0x04	; 4
     abe:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskCreate>
     ac2:	81 30       	cpi	r24, 0x01	; 1
     ac4:	81 f4       	brne	.+32     	; 0xae6 <vTaskStartScheduler+0x4c>
     ac6:	f8 94       	cli
     ac8:	8f ef       	ldi	r24, 0xFF	; 255
     aca:	9f ef       	ldi	r25, 0xFF	; 255
     acc:	90 93 de 06 	sts	0x06DE, r25	; 0x8006de <xNextTaskUnblockTime+0x1>
     ad0:	80 93 dd 06 	sts	0x06DD, r24	; 0x8006dd <xNextTaskUnblockTime>
     ad4:	81 e0       	ldi	r24, 0x01	; 1
     ad6:	80 93 e3 06 	sts	0x06E3, r24	; 0x8006e3 <xSchedulerRunning>
     ada:	10 92 e6 06 	sts	0x06E6, r1	; 0x8006e6 <xTickCount+0x1>
     ade:	10 92 e5 06 	sts	0x06E5, r1	; 0x8006e5 <xTickCount>
     ae2:	0e 94 75 01 	call	0x2ea	; 0x2ea <xPortStartScheduler>
     ae6:	0f 91       	pop	r16
     ae8:	ff 90       	pop	r15
     aea:	ef 90       	pop	r14
     aec:	08 95       	ret

00000aee <vTaskSuspendAll>:
     aee:	80 91 da 06 	lds	r24, 0x06DA	; 0x8006da <uxSchedulerSuspended>
     af2:	8f 5f       	subi	r24, 0xFF	; 255
     af4:	80 93 da 06 	sts	0x06DA, r24	; 0x8006da <uxSchedulerSuspended>
     af8:	08 95       	ret

00000afa <xTaskGetTickCount>:
     afa:	0f b6       	in	r0, 0x3f	; 63
     afc:	f8 94       	cli
     afe:	0f 92       	push	r0
     b00:	80 91 e5 06 	lds	r24, 0x06E5	; 0x8006e5 <xTickCount>
     b04:	90 91 e6 06 	lds	r25, 0x06E6	; 0x8006e6 <xTickCount+0x1>
     b08:	0f 90       	pop	r0
     b0a:	0f be       	out	0x3f, r0	; 63
     b0c:	08 95       	ret

00000b0e <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     b0e:	df 92       	push	r13
     b10:	ef 92       	push	r14
     b12:	ff 92       	push	r15
     b14:	0f 93       	push	r16
     b16:	1f 93       	push	r17
     b18:	cf 93       	push	r28
     b1a:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     b1c:	80 91 da 06 	lds	r24, 0x06DA	; 0x8006da <uxSchedulerSuspended>
     b20:	81 11       	cpse	r24, r1
     b22:	97 c0       	rjmp	.+302    	; 0xc52 <xTaskIncrementTick+0x144>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
     b24:	e0 90 e5 06 	lds	r14, 0x06E5	; 0x8006e5 <xTickCount>
     b28:	f0 90 e6 06 	lds	r15, 0x06E6	; 0x8006e6 <xTickCount+0x1>
     b2c:	8f ef       	ldi	r24, 0xFF	; 255
     b2e:	e8 1a       	sub	r14, r24
     b30:	f8 0a       	sbc	r15, r24

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     b32:	f0 92 e6 06 	sts	0x06E6, r15	; 0x8006e6 <xTickCount+0x1>
     b36:	e0 92 e5 06 	sts	0x06E5, r14	; 0x8006e5 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U )
     b3a:	e1 14       	cp	r14, r1
     b3c:	f1 04       	cpc	r15, r1
     b3e:	b9 f4       	brne	.+46     	; 0xb6e <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     b40:	80 91 f3 06 	lds	r24, 0x06F3	; 0x8006f3 <pxDelayedTaskList>
     b44:	90 91 f4 06 	lds	r25, 0x06F4	; 0x8006f4 <pxDelayedTaskList+0x1>
     b48:	20 91 f1 06 	lds	r18, 0x06F1	; 0x8006f1 <pxOverflowDelayedTaskList>
     b4c:	30 91 f2 06 	lds	r19, 0x06F2	; 0x8006f2 <pxOverflowDelayedTaskList+0x1>
     b50:	30 93 f4 06 	sts	0x06F4, r19	; 0x8006f4 <pxDelayedTaskList+0x1>
     b54:	20 93 f3 06 	sts	0x06F3, r18	; 0x8006f3 <pxDelayedTaskList>
     b58:	90 93 f2 06 	sts	0x06F2, r25	; 0x8006f2 <pxOverflowDelayedTaskList+0x1>
     b5c:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <pxOverflowDelayedTaskList>
     b60:	80 91 e0 06 	lds	r24, 0x06E0	; 0x8006e0 <xNumOfOverflows>
     b64:	8f 5f       	subi	r24, 0xFF	; 255
     b66:	80 93 e0 06 	sts	0x06E0, r24	; 0x8006e0 <xNumOfOverflows>
     b6a:	0e 94 9a 03 	call	0x734	; 0x734 <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     b6e:	80 91 dd 06 	lds	r24, 0x06DD	; 0x8006dd <xNextTaskUnblockTime>
     b72:	90 91 de 06 	lds	r25, 0x06DE	; 0x8006de <xNextTaskUnblockTime+0x1>
     b76:	e8 16       	cp	r14, r24
     b78:	f9 06       	cpc	r15, r25
     b7a:	28 f4       	brcc	.+10     	; 0xb86 <xTaskIncrementTick+0x78>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     b7c:	d1 2c       	mov	r13, r1
     b7e:	53 c0       	rjmp	.+166    	; 0xc26 <xTaskIncrementTick+0x118>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
     b80:	dd 24       	eor	r13, r13
     b82:	d3 94       	inc	r13
     b84:	01 c0       	rjmp	.+2      	; 0xb88 <xTaskIncrementTick+0x7a>
     b86:	d1 2c       	mov	r13, r1
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     b88:	e0 91 f3 06 	lds	r30, 0x06F3	; 0x8006f3 <pxDelayedTaskList>
     b8c:	f0 91 f4 06 	lds	r31, 0x06F4	; 0x8006f4 <pxDelayedTaskList+0x1>
     b90:	80 81       	ld	r24, Z
     b92:	81 11       	cpse	r24, r1
     b94:	07 c0       	rjmp	.+14     	; 0xba4 <xTaskIncrementTick+0x96>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     b96:	8f ef       	ldi	r24, 0xFF	; 255
     b98:	9f ef       	ldi	r25, 0xFF	; 255
     b9a:	90 93 de 06 	sts	0x06DE, r25	; 0x8006de <xNextTaskUnblockTime+0x1>
     b9e:	80 93 dd 06 	sts	0x06DD, r24	; 0x8006dd <xNextTaskUnblockTime>
					break;
     ba2:	41 c0       	rjmp	.+130    	; 0xc26 <xTaskIncrementTick+0x118>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     ba4:	e0 91 f3 06 	lds	r30, 0x06F3	; 0x8006f3 <pxDelayedTaskList>
     ba8:	f0 91 f4 06 	lds	r31, 0x06F4	; 0x8006f4 <pxDelayedTaskList+0x1>
     bac:	05 80       	ldd	r0, Z+5	; 0x05
     bae:	f6 81       	ldd	r31, Z+6	; 0x06
     bb0:	e0 2d       	mov	r30, r0
     bb2:	c6 81       	ldd	r28, Z+6	; 0x06
     bb4:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     bb6:	8a 81       	ldd	r24, Y+2	; 0x02
     bb8:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
     bba:	e8 16       	cp	r14, r24
     bbc:	f9 06       	cpc	r15, r25
     bbe:	28 f4       	brcc	.+10     	; 0xbca <xTaskIncrementTick+0xbc>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     bc0:	90 93 de 06 	sts	0x06DE, r25	; 0x8006de <xNextTaskUnblockTime+0x1>
     bc4:	80 93 dd 06 	sts	0x06DD, r24	; 0x8006dd <xNextTaskUnblockTime>
						break;
     bc8:	2e c0       	rjmp	.+92     	; 0xc26 <xTaskIncrementTick+0x118>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     bca:	8e 01       	movw	r16, r28
     bcc:	0e 5f       	subi	r16, 0xFE	; 254
     bce:	1f 4f       	sbci	r17, 0xFF	; 255
     bd0:	c8 01       	movw	r24, r16
     bd2:	0e 94 da 00 	call	0x1b4	; 0x1b4 <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     bd6:	8c 89       	ldd	r24, Y+20	; 0x14
     bd8:	9d 89       	ldd	r25, Y+21	; 0x15
     bda:	89 2b       	or	r24, r25
     bdc:	21 f0       	breq	.+8      	; 0xbe6 <xTaskIncrementTick+0xd8>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     bde:	ce 01       	movw	r24, r28
     be0:	0c 96       	adiw	r24, 0x0c	; 12
     be2:	0e 94 da 00 	call	0x1b4	; 0x1b4 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     be6:	8e 89       	ldd	r24, Y+22	; 0x16
     be8:	90 91 e4 06 	lds	r25, 0x06E4	; 0x8006e4 <uxTopReadyPriority>
     bec:	98 17       	cp	r25, r24
     bee:	10 f4       	brcc	.+4      	; 0xbf4 <xTaskIncrementTick+0xe6>
     bf0:	80 93 e4 06 	sts	0x06E4, r24	; 0x8006e4 <uxTopReadyPriority>
     bf4:	90 e0       	ldi	r25, 0x00	; 0
     bf6:	9c 01       	movw	r18, r24
     bf8:	22 0f       	add	r18, r18
     bfa:	33 1f       	adc	r19, r19
     bfc:	22 0f       	add	r18, r18
     bfe:	33 1f       	adc	r19, r19
     c00:	22 0f       	add	r18, r18
     c02:	33 1f       	adc	r19, r19
     c04:	82 0f       	add	r24, r18
     c06:	93 1f       	adc	r25, r19
     c08:	b8 01       	movw	r22, r16
     c0a:	89 5f       	subi	r24, 0xF9	; 249
     c0c:	98 4f       	sbci	r25, 0xF8	; 248
     c0e:	0e 94 88 00 	call	0x110	; 0x110 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     c12:	9e 89       	ldd	r25, Y+22	; 0x16
     c14:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxCurrentTCB>
     c18:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     c1c:	86 89       	ldd	r24, Z+22	; 0x16
     c1e:	98 17       	cp	r25, r24
     c20:	08 f0       	brcs	.+2      	; 0xc24 <xTaskIncrementTick+0x116>
     c22:	ae cf       	rjmp	.-164    	; 0xb80 <xTaskIncrementTick+0x72>
     c24:	b1 cf       	rjmp	.-158    	; 0xb88 <xTaskIncrementTick+0x7a>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     c26:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxCurrentTCB>
     c2a:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     c2e:	86 89       	ldd	r24, Z+22	; 0x16
     c30:	90 e0       	ldi	r25, 0x00	; 0
     c32:	fc 01       	movw	r30, r24
     c34:	ee 0f       	add	r30, r30
     c36:	ff 1f       	adc	r31, r31
     c38:	ee 0f       	add	r30, r30
     c3a:	ff 1f       	adc	r31, r31
     c3c:	ee 0f       	add	r30, r30
     c3e:	ff 1f       	adc	r31, r31
     c40:	8e 0f       	add	r24, r30
     c42:	9f 1f       	adc	r25, r31
     c44:	fc 01       	movw	r30, r24
     c46:	e9 5f       	subi	r30, 0xF9	; 249
     c48:	f8 4f       	sbci	r31, 0xF8	; 248
     c4a:	80 81       	ld	r24, Z
     c4c:	82 30       	cpi	r24, 0x02	; 2
     c4e:	40 f4       	brcc	.+16     	; 0xc60 <xTaskIncrementTick+0x152>
     c50:	09 c0       	rjmp	.+18     	; 0xc64 <xTaskIncrementTick+0x156>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     c52:	80 91 e2 06 	lds	r24, 0x06E2	; 0x8006e2 <uxPendedTicks>
     c56:	8f 5f       	subi	r24, 0xFF	; 255
     c58:	80 93 e2 06 	sts	0x06E2, r24	; 0x8006e2 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     c5c:	d1 2c       	mov	r13, r1
     c5e:	02 c0       	rjmp	.+4      	; 0xc64 <xTaskIncrementTick+0x156>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
     c60:	dd 24       	eor	r13, r13
     c62:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     c64:	80 91 e1 06 	lds	r24, 0x06E1	; 0x8006e1 <xYieldPending>
     c68:	88 23       	and	r24, r24
     c6a:	11 f0       	breq	.+4      	; 0xc70 <xTaskIncrementTick+0x162>
		{
			xSwitchRequired = pdTRUE;
     c6c:	dd 24       	eor	r13, r13
     c6e:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     c70:	8d 2d       	mov	r24, r13
     c72:	df 91       	pop	r29
     c74:	cf 91       	pop	r28
     c76:	1f 91       	pop	r17
     c78:	0f 91       	pop	r16
     c7a:	ff 90       	pop	r15
     c7c:	ef 90       	pop	r14
     c7e:	df 90       	pop	r13
     c80:	08 95       	ret

00000c82 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     c82:	0f 93       	push	r16
     c84:	1f 93       	push	r17
     c86:	cf 93       	push	r28
     c88:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     c8a:	0f b6       	in	r0, 0x3f	; 63
     c8c:	f8 94       	cli
     c8e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     c90:	80 91 da 06 	lds	r24, 0x06DA	; 0x8006da <uxSchedulerSuspended>
     c94:	81 50       	subi	r24, 0x01	; 1
     c96:	80 93 da 06 	sts	0x06DA, r24	; 0x8006da <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c9a:	80 91 da 06 	lds	r24, 0x06DA	; 0x8006da <uxSchedulerSuspended>
     c9e:	81 11       	cpse	r24, r1
     ca0:	58 c0       	rjmp	.+176    	; 0xd52 <xTaskResumeAll+0xd0>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     ca2:	80 91 e7 06 	lds	r24, 0x06E7	; 0x8006e7 <uxCurrentNumberOfTasks>
     ca6:	81 11       	cpse	r24, r1
     ca8:	33 c0       	rjmp	.+102    	; 0xd10 <xTaskResumeAll+0x8e>
     caa:	56 c0       	rjmp	.+172    	; 0xd58 <xTaskResumeAll+0xd6>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     cac:	e0 91 ed 06 	lds	r30, 0x06ED	; 0x8006ed <xPendingReadyList+0x5>
     cb0:	f0 91 ee 06 	lds	r31, 0x06EE	; 0x8006ee <xPendingReadyList+0x6>
     cb4:	c6 81       	ldd	r28, Z+6	; 0x06
     cb6:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     cb8:	ce 01       	movw	r24, r28
     cba:	0c 96       	adiw	r24, 0x0c	; 12
     cbc:	0e 94 da 00 	call	0x1b4	; 0x1b4 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     cc0:	8e 01       	movw	r16, r28
     cc2:	0e 5f       	subi	r16, 0xFE	; 254
     cc4:	1f 4f       	sbci	r17, 0xFF	; 255
     cc6:	c8 01       	movw	r24, r16
     cc8:	0e 94 da 00 	call	0x1b4	; 0x1b4 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     ccc:	8e 89       	ldd	r24, Y+22	; 0x16
     cce:	90 91 e4 06 	lds	r25, 0x06E4	; 0x8006e4 <uxTopReadyPriority>
     cd2:	98 17       	cp	r25, r24
     cd4:	10 f4       	brcc	.+4      	; 0xcda <xTaskResumeAll+0x58>
     cd6:	80 93 e4 06 	sts	0x06E4, r24	; 0x8006e4 <uxTopReadyPriority>
     cda:	90 e0       	ldi	r25, 0x00	; 0
     cdc:	9c 01       	movw	r18, r24
     cde:	22 0f       	add	r18, r18
     ce0:	33 1f       	adc	r19, r19
     ce2:	22 0f       	add	r18, r18
     ce4:	33 1f       	adc	r19, r19
     ce6:	22 0f       	add	r18, r18
     ce8:	33 1f       	adc	r19, r19
     cea:	82 0f       	add	r24, r18
     cec:	93 1f       	adc	r25, r19
     cee:	b8 01       	movw	r22, r16
     cf0:	89 5f       	subi	r24, 0xF9	; 249
     cf2:	98 4f       	sbci	r25, 0xF8	; 248
     cf4:	0e 94 88 00 	call	0x110	; 0x110 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     cf8:	9e 89       	ldd	r25, Y+22	; 0x16
     cfa:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxCurrentTCB>
     cfe:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     d02:	86 89       	ldd	r24, Z+22	; 0x16
     d04:	98 17       	cp	r25, r24
     d06:	30 f0       	brcs	.+12     	; 0xd14 <xTaskResumeAll+0x92>
					{
						xYieldPending = pdTRUE;
     d08:	81 e0       	ldi	r24, 0x01	; 1
     d0a:	80 93 e1 06 	sts	0x06E1, r24	; 0x8006e1 <xYieldPending>
     d0e:	02 c0       	rjmp	.+4      	; 0xd14 <xTaskResumeAll+0x92>
     d10:	c0 e0       	ldi	r28, 0x00	; 0
     d12:	d0 e0       	ldi	r29, 0x00	; 0
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     d14:	80 91 e8 06 	lds	r24, 0x06E8	; 0x8006e8 <xPendingReadyList>
     d18:	81 11       	cpse	r24, r1
     d1a:	c8 cf       	rjmp	.-112    	; 0xcac <xTaskResumeAll+0x2a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     d1c:	cd 2b       	or	r28, r29
     d1e:	11 f0       	breq	.+4      	; 0xd24 <xTaskResumeAll+0xa2>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     d20:	0e 94 9a 03 	call	0x734	; 0x734 <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     d24:	c0 91 e2 06 	lds	r28, 0x06E2	; 0x8006e2 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     d28:	cc 23       	and	r28, r28
     d2a:	59 f0       	breq	.+22     	; 0xd42 <xTaskResumeAll+0xc0>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     d2c:	0e 94 87 05 	call	0xb0e	; 0xb0e <xTaskIncrementTick>
     d30:	88 23       	and	r24, r24
     d32:	19 f0       	breq	.+6      	; 0xd3a <xTaskResumeAll+0xb8>
							{
								xYieldPending = pdTRUE;
     d34:	81 e0       	ldi	r24, 0x01	; 1
     d36:	80 93 e1 06 	sts	0x06E1, r24	; 0x8006e1 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     d3a:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     d3c:	b9 f7       	brne	.-18     	; 0xd2c <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
     d3e:	10 92 e2 06 	sts	0x06E2, r1	; 0x8006e2 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     d42:	80 91 e1 06 	lds	r24, 0x06E1	; 0x8006e1 <xYieldPending>
     d46:	88 23       	and	r24, r24
     d48:	31 f0       	breq	.+12     	; 0xd56 <xTaskResumeAll+0xd4>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     d4a:	0e 94 a4 01 	call	0x348	; 0x348 <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     d4e:	81 e0       	ldi	r24, 0x01	; 1
     d50:	03 c0       	rjmp	.+6      	; 0xd58 <xTaskResumeAll+0xd6>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     d52:	80 e0       	ldi	r24, 0x00	; 0
     d54:	01 c0       	rjmp	.+2      	; 0xd58 <xTaskResumeAll+0xd6>
     d56:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     d58:	0f 90       	pop	r0
     d5a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     d5c:	df 91       	pop	r29
     d5e:	cf 91       	pop	r28
     d60:	1f 91       	pop	r17
     d62:	0f 91       	pop	r16
     d64:	08 95       	ret

00000d66 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     d66:	0f 93       	push	r16
     d68:	1f 93       	push	r17
     d6a:	cf 93       	push	r28
     d6c:	df 93       	push	r29
     d6e:	8c 01       	movw	r16, r24
     d70:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     d72:	0e 94 77 05 	call	0xaee	; 0xaee <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     d76:	40 91 e5 06 	lds	r20, 0x06E5	; 0x8006e5 <xTickCount>
     d7a:	50 91 e6 06 	lds	r21, 0x06E6	; 0x8006e6 <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     d7e:	f8 01       	movw	r30, r16
     d80:	20 81       	ld	r18, Z
     d82:	31 81       	ldd	r19, Z+1	; 0x01
     d84:	c9 01       	movw	r24, r18
     d86:	8c 0f       	add	r24, r28
     d88:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     d8a:	42 17       	cp	r20, r18
     d8c:	53 07       	cpc	r21, r19
     d8e:	40 f4       	brcc	.+16     	; 0xda0 <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     d90:	82 17       	cp	r24, r18
     d92:	93 07       	cpc	r25, r19
     d94:	68 f4       	brcc	.+26     	; 0xdb0 <vTaskDelayUntil+0x4a>
     d96:	48 17       	cp	r20, r24
     d98:	59 07       	cpc	r21, r25
     d9a:	60 f0       	brcs	.+24     	; 0xdb4 <vTaskDelayUntil+0x4e>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     d9c:	20 e0       	ldi	r18, 0x00	; 0
     d9e:	0f c0       	rjmp	.+30     	; 0xdbe <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     da0:	82 17       	cp	r24, r18
     da2:	93 07       	cpc	r25, r19
     da4:	48 f0       	brcs	.+18     	; 0xdb8 <vTaskDelayUntil+0x52>
     da6:	48 17       	cp	r20, r24
     da8:	59 07       	cpc	r21, r25
     daa:	40 f0       	brcs	.+16     	; 0xdbc <vTaskDelayUntil+0x56>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     dac:	20 e0       	ldi	r18, 0x00	; 0
     dae:	07 c0       	rjmp	.+14     	; 0xdbe <vTaskDelayUntil+0x58>
     db0:	20 e0       	ldi	r18, 0x00	; 0
     db2:	05 c0       	rjmp	.+10     	; 0xdbe <vTaskDelayUntil+0x58>
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     db4:	21 e0       	ldi	r18, 0x01	; 1
     db6:	03 c0       	rjmp	.+6      	; 0xdbe <vTaskDelayUntil+0x58>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     db8:	21 e0       	ldi	r18, 0x01	; 1
     dba:	01 c0       	rjmp	.+2      	; 0xdbe <vTaskDelayUntil+0x58>
     dbc:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     dbe:	f8 01       	movw	r30, r16
     dc0:	91 83       	std	Z+1, r25	; 0x01
     dc2:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     dc4:	22 23       	and	r18, r18
     dc6:	29 f0       	breq	.+10     	; 0xdd2 <vTaskDelayUntil+0x6c>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     dc8:	60 e0       	ldi	r22, 0x00	; 0
     dca:	84 1b       	sub	r24, r20
     dcc:	95 0b       	sbc	r25, r21
     dce:	0e 94 b5 04 	call	0x96a	; 0x96a <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     dd2:	0e 94 41 06 	call	0xc82	; 0xc82 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     dd6:	81 11       	cpse	r24, r1
     dd8:	02 c0       	rjmp	.+4      	; 0xdde <vTaskDelayUntil+0x78>
		{
			portYIELD_WITHIN_API();
     dda:	0e 94 a4 01 	call	0x348	; 0x348 <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     dde:	df 91       	pop	r29
     de0:	cf 91       	pop	r28
     de2:	1f 91       	pop	r17
     de4:	0f 91       	pop	r16
     de6:	08 95       	ret

00000de8 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     de8:	80 91 da 06 	lds	r24, 0x06DA	; 0x8006da <uxSchedulerSuspended>
     dec:	88 23       	and	r24, r24
     dee:	21 f0       	breq	.+8      	; 0xdf8 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     df0:	81 e0       	ldi	r24, 0x01	; 1
     df2:	80 93 e1 06 	sts	0x06E1, r24	; 0x8006e1 <xYieldPending>
     df6:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     df8:	10 92 e1 06 	sts	0x06E1, r1	; 0x8006e1 <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     dfc:	20 91 e4 06 	lds	r18, 0x06E4	; 0x8006e4 <uxTopReadyPriority>
     e00:	01 c0       	rjmp	.+2      	; 0xe04 <vTaskSwitchContext+0x1c>
     e02:	21 50       	subi	r18, 0x01	; 1
     e04:	82 2f       	mov	r24, r18
     e06:	90 e0       	ldi	r25, 0x00	; 0
     e08:	fc 01       	movw	r30, r24
     e0a:	ee 0f       	add	r30, r30
     e0c:	ff 1f       	adc	r31, r31
     e0e:	ee 0f       	add	r30, r30
     e10:	ff 1f       	adc	r31, r31
     e12:	ee 0f       	add	r30, r30
     e14:	ff 1f       	adc	r31, r31
     e16:	e8 0f       	add	r30, r24
     e18:	f9 1f       	adc	r31, r25
     e1a:	e9 5f       	subi	r30, 0xF9	; 249
     e1c:	f8 4f       	sbci	r31, 0xF8	; 248
     e1e:	30 81       	ld	r19, Z
     e20:	33 23       	and	r19, r19
     e22:	79 f3       	breq	.-34     	; 0xe02 <vTaskSwitchContext+0x1a>
     e24:	ac 01       	movw	r20, r24
     e26:	44 0f       	add	r20, r20
     e28:	55 1f       	adc	r21, r21
     e2a:	44 0f       	add	r20, r20
     e2c:	55 1f       	adc	r21, r21
     e2e:	44 0f       	add	r20, r20
     e30:	55 1f       	adc	r21, r21
     e32:	48 0f       	add	r20, r24
     e34:	59 1f       	adc	r21, r25
     e36:	df 01       	movw	r26, r30
     e38:	01 80       	ldd	r0, Z+1	; 0x01
     e3a:	f2 81       	ldd	r31, Z+2	; 0x02
     e3c:	e0 2d       	mov	r30, r0
     e3e:	02 80       	ldd	r0, Z+2	; 0x02
     e40:	f3 81       	ldd	r31, Z+3	; 0x03
     e42:	e0 2d       	mov	r30, r0
     e44:	12 96       	adiw	r26, 0x02	; 2
     e46:	fc 93       	st	X, r31
     e48:	ee 93       	st	-X, r30
     e4a:	11 97       	sbiw	r26, 0x01	; 1
     e4c:	46 5f       	subi	r20, 0xF6	; 246
     e4e:	58 4f       	sbci	r21, 0xF8	; 248
     e50:	e4 17       	cp	r30, r20
     e52:	f5 07       	cpc	r31, r21
     e54:	29 f4       	brne	.+10     	; 0xe60 <vTaskSwitchContext+0x78>
     e56:	42 81       	ldd	r20, Z+2	; 0x02
     e58:	53 81       	ldd	r21, Z+3	; 0x03
     e5a:	fd 01       	movw	r30, r26
     e5c:	52 83       	std	Z+2, r21	; 0x02
     e5e:	41 83       	std	Z+1, r20	; 0x01
     e60:	fc 01       	movw	r30, r24
     e62:	ee 0f       	add	r30, r30
     e64:	ff 1f       	adc	r31, r31
     e66:	ee 0f       	add	r30, r30
     e68:	ff 1f       	adc	r31, r31
     e6a:	ee 0f       	add	r30, r30
     e6c:	ff 1f       	adc	r31, r31
     e6e:	8e 0f       	add	r24, r30
     e70:	9f 1f       	adc	r25, r31
     e72:	fc 01       	movw	r30, r24
     e74:	e9 5f       	subi	r30, 0xF9	; 249
     e76:	f8 4f       	sbci	r31, 0xF8	; 248
     e78:	01 80       	ldd	r0, Z+1	; 0x01
     e7a:	f2 81       	ldd	r31, Z+2	; 0x02
     e7c:	e0 2d       	mov	r30, r0
     e7e:	86 81       	ldd	r24, Z+6	; 0x06
     e80:	97 81       	ldd	r25, Z+7	; 0x07
     e82:	90 93 2c 07 	sts	0x072C, r25	; 0x80072c <pxCurrentTCB+0x1>
     e86:	80 93 2b 07 	sts	0x072B, r24	; 0x80072b <pxCurrentTCB>
     e8a:	20 93 e4 06 	sts	0x06E4, r18	; 0x8006e4 <uxTopReadyPriority>
     e8e:	08 95       	ret

00000e90 <KP_Init>:
* @param [in]  KP_CH   -  Keypad channel number.
*
* @return function error state.
*/
extern ERROR_STATE_t KP_Init(uint8_t KP_CH)
{
     e90:	ff 92       	push	r15
     e92:	0f 93       	push	r16
     e94:	1f 93       	push	r17
     e96:	cf 93       	push	r28
     e98:	df 93       	push	r29
   ERROR_STATE_t KP_ErrorState;
   
   if(KP_INVALID_CH <= KP_CH)
     e9a:	81 11       	cpse	r24, r1
     e9c:	4e c0       	rjmp	.+156    	; 0xf3a <KP_Init+0xaa>
     e9e:	08 2f       	mov	r16, r24
     ea0:	10 e0       	ldi	r17, 0x00	; 0
     ea2:	17 c0       	rjmp	.+46     	; 0xed2 <KP_Init+0x42>
   else
   {
      /* Set columns pins to output initially High */
      for(uint8_t u8_Counter = 0; u8_Counter < aSTR_KPConfig[KP_CH].u8_KPCols; u8_Counter++)
      {
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_Counter) , PIN_INPUT);
     ea4:	9e 01       	movw	r18, r28
     ea6:	22 0f       	add	r18, r18
     ea8:	33 1f       	adc	r19, r19
     eaa:	f9 01       	movw	r30, r18
     eac:	ec 0f       	add	r30, r28
     eae:	fd 1f       	adc	r31, r29
     eb0:	ee 0f       	add	r30, r30
     eb2:	ff 1f       	adc	r31, r31
     eb4:	e7 52       	subi	r30, 0x27	; 39
     eb6:	ff 4f       	sbci	r31, 0xFF	; 255
     eb8:	f5 80       	ldd	r15, Z+5	; 0x05
     eba:	f1 0e       	add	r15, r17
     ebc:	c4 81       	ldd	r28, Z+4	; 0x04
     ebe:	40 e0       	ldi	r20, 0x00	; 0
     ec0:	6f 2d       	mov	r22, r15
     ec2:	8c 2f       	mov	r24, r28
     ec4:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <DIO_SetPinDirection>
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_Counter));
     ec8:	6f 2d       	mov	r22, r15
     eca:	8c 2f       	mov	r24, r28
     ecc:	0e 94 90 0a 	call	0x1520	; 0x1520 <DIO_EnablePinPullup>
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_INVALID_CH);
   }
   else
   {
      /* Set columns pins to output initially High */
      for(uint8_t u8_Counter = 0; u8_Counter < aSTR_KPConfig[KP_CH].u8_KPCols; u8_Counter++)
     ed0:	1f 5f       	subi	r17, 0xFF	; 255
     ed2:	c0 2f       	mov	r28, r16
     ed4:	d0 e0       	ldi	r29, 0x00	; 0
     ed6:	fe 01       	movw	r30, r28
     ed8:	ee 0f       	add	r30, r30
     eda:	ff 1f       	adc	r31, r31
     edc:	ec 0f       	add	r30, r28
     ede:	fd 1f       	adc	r31, r29
     ee0:	ee 0f       	add	r30, r30
     ee2:	ff 1f       	adc	r31, r31
     ee4:	e7 52       	subi	r30, 0x27	; 39
     ee6:	ff 4f       	sbci	r31, 0xFF	; 255
     ee8:	83 81       	ldd	r24, Z+3	; 0x03
     eea:	18 17       	cp	r17, r24
     eec:	d8 f2       	brcs	.-74     	; 0xea4 <KP_Init+0x14>
     eee:	10 e0       	ldi	r17, 0x00	; 0
     ef0:	16 c0       	rjmp	.+44     	; 0xf1e <KP_Init+0x8e>
      }
      
      /* Set rows pins to input and set pull up resistors */
      for(uint8_t u8_Counter = 0; u8_Counter < aSTR_KPConfig[KP_CH].u8_KPRows; u8_Counter++)
      {
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_Counter) , PIN_INPUT);
     ef2:	fe 01       	movw	r30, r28
     ef4:	ee 0f       	add	r30, r30
     ef6:	ff 1f       	adc	r31, r31
     ef8:	ec 0f       	add	r30, r28
     efa:	fd 1f       	adc	r31, r29
     efc:	ee 0f       	add	r30, r30
     efe:	ff 1f       	adc	r31, r31
     f00:	e7 52       	subi	r30, 0x27	; 39
     f02:	ff 4f       	sbci	r31, 0xFF	; 255
     f04:	02 81       	ldd	r16, Z+2	; 0x02
     f06:	01 0f       	add	r16, r17
     f08:	f1 80       	ldd	r15, Z+1	; 0x01
     f0a:	40 e0       	ldi	r20, 0x00	; 0
     f0c:	60 2f       	mov	r22, r16
     f0e:	8f 2d       	mov	r24, r15
     f10:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <DIO_SetPinDirection>
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_Counter));
     f14:	60 2f       	mov	r22, r16
     f16:	8f 2d       	mov	r24, r15
     f18:	0e 94 90 0a 	call	0x1520	; 0x1520 <DIO_EnablePinPullup>
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_Counter) , PIN_INPUT);
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_Counter));
      }
      
      /* Set rows pins to input and set pull up resistors */
      for(uint8_t u8_Counter = 0; u8_Counter < aSTR_KPConfig[KP_CH].u8_KPRows; u8_Counter++)
     f1c:	1f 5f       	subi	r17, 0xFF	; 255
     f1e:	fe 01       	movw	r30, r28
     f20:	ee 0f       	add	r30, r30
     f22:	ff 1f       	adc	r31, r31
     f24:	ec 0f       	add	r30, r28
     f26:	fd 1f       	adc	r31, r29
     f28:	ee 0f       	add	r30, r30
     f2a:	ff 1f       	adc	r31, r31
     f2c:	e7 52       	subi	r30, 0x27	; 39
     f2e:	ff 4f       	sbci	r31, 0xFF	; 255
     f30:	80 81       	ld	r24, Z
     f32:	18 17       	cp	r17, r24
     f34:	f0 f2       	brcs	.-68     	; 0xef2 <KP_Init+0x62>
      {
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_Counter) , PIN_INPUT);
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_Counter));
      }
      KP_ErrorState = ERROR_OK;
     f36:	80 e0       	ldi	r24, 0x00	; 0
     f38:	01 c0       	rjmp	.+2      	; 0xf3c <KP_Init+0xac>
{
   ERROR_STATE_t KP_ErrorState;
   
   if(KP_INVALID_CH <= KP_CH)
   {
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_INVALID_CH);
     f3a:	82 ee       	ldi	r24, 0xE2	; 226
      KP_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return KP_ErrorState;
}
     f3c:	df 91       	pop	r29
     f3e:	cf 91       	pop	r28
     f40:	1f 91       	pop	r17
     f42:	0f 91       	pop	r16
     f44:	ff 90       	pop	r15
     f46:	08 95       	ret

00000f48 <KP_GetPressedValue>:
* @param [out] Data     -  Pressed Key Value.
*
* @return function error state.
*/
ERROR_STATE_t KP_GetPressedValue(uint8_t KP_CH, uint32_t * const Data)
{
     f48:	5f 92       	push	r5
     f4a:	6f 92       	push	r6
     f4c:	7f 92       	push	r7
     f4e:	8f 92       	push	r8
     f50:	9f 92       	push	r9
     f52:	af 92       	push	r10
     f54:	bf 92       	push	r11
     f56:	cf 92       	push	r12
     f58:	df 92       	push	r13
     f5a:	ef 92       	push	r14
     f5c:	ff 92       	push	r15
     f5e:	0f 93       	push	r16
     f60:	1f 93       	push	r17
     f62:	cf 93       	push	r28
     f64:	df 93       	push	r29
     f66:	1f 92       	push	r1
     f68:	cd b7       	in	r28, 0x3d	; 61
     f6a:	de b7       	in	r29, 0x3e	; 62
   ERROR_STATE_t KP_ErrorState;
      
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Data)
     f6c:	61 15       	cp	r22, r1
     f6e:	71 05       	cpc	r23, r1
     f70:	09 f4       	brne	.+2      	; 0xf74 <KP_GetPressedValue+0x2c>
     f72:	9e c0       	rjmp	.+316    	; 0x10b0 <KP_GetPressedValue+0x168>
   {
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_NULL_PTR);
   }
   else if(KP_INVALID_CH <= KP_CH)
     f74:	81 11       	cpse	r24, r1
     f76:	9e c0       	rjmp	.+316    	; 0x10b4 <KP_GetPressedValue+0x16c>
     f78:	6b 01       	movw	r12, r22
     f7a:	e8 2e       	mov	r14, r24
     f7c:	61 2c       	mov	r6, r1
     f7e:	81 2c       	mov	r8, r1
     f80:	91 2c       	mov	r9, r1
     f82:	54 01       	movw	r10, r8
     f84:	68 c0       	rjmp	.+208    	; 0x1056 <KP_GetPressedValue+0x10e>
      
      /* loops on every column */
      for(uint8_t u8_ColCounter = 0; u8_ColCounter < aSTR_KPConfig[KP_CH].u8_KPCols; u8_ColCounter++)
      {
         /* set column value to low */
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter) , PIN_OUTPUT);
     f86:	f8 01       	movw	r30, r16
     f88:	ee 0f       	add	r30, r30
     f8a:	ff 1f       	adc	r31, r31
     f8c:	e0 0f       	add	r30, r16
     f8e:	f1 1f       	adc	r31, r17
     f90:	ee 0f       	add	r30, r30
     f92:	ff 1f       	adc	r31, r31
     f94:	e7 52       	subi	r30, 0x27	; 39
     f96:	ff 4f       	sbci	r31, 0xFF	; 255
     f98:	75 80       	ldd	r7, Z+5	; 0x05
     f9a:	76 0c       	add	r7, r6
     f9c:	54 80       	ldd	r5, Z+4	; 0x04
     f9e:	41 e0       	ldi	r20, 0x01	; 1
     fa0:	67 2d       	mov	r22, r7
     fa2:	85 2d       	mov	r24, r5
     fa4:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <DIO_SetPinDirection>
         DIO_WritePin(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter), PIN_LOW);
     fa8:	40 e0       	ldi	r20, 0x00	; 0
     faa:	67 2d       	mov	r22, r7
     fac:	85 2d       	mov	r24, r5
     fae:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <DIO_WritePin>
         
         /* loops on every row */
         for(uint8_t u8_RowCounter = 0; u8_RowCounter < aSTR_KPConfig[KP_CH].u8_KPRows; u8_RowCounter++)
     fb2:	f1 2c       	mov	r15, r1
     fb4:	39 c0       	rjmp	.+114    	; 0x1028 <KP_GetPressedValue+0xe0>
         {
            /* read row value */
            DIO_ReadPin(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_RowCounter), &u8_KeyState);
     fb6:	f8 01       	movw	r30, r16
     fb8:	ee 0f       	add	r30, r30
     fba:	ff 1f       	adc	r31, r31
     fbc:	e0 0f       	add	r30, r16
     fbe:	f1 1f       	adc	r31, r17
     fc0:	ee 0f       	add	r30, r30
     fc2:	ff 1f       	adc	r31, r31
     fc4:	e7 52       	subi	r30, 0x27	; 39
     fc6:	ff 4f       	sbci	r31, 0xFF	; 255
     fc8:	62 81       	ldd	r22, Z+2	; 0x02
     fca:	6f 0d       	add	r22, r15
     fcc:	ae 01       	movw	r20, r28
     fce:	4f 5f       	subi	r20, 0xFF	; 255
     fd0:	5f 4f       	sbci	r21, 0xFF	; 255
     fd2:	81 81       	ldd	r24, Z+1	; 0x01
     fd4:	0e 94 4d 0a 	call	0x149a	; 0x149a <DIO_ReadPin>
            /* check if row is pressed */
            if(u8_KeyState == PRESSED)
     fd8:	89 81       	ldd	r24, Y+1	; 0x01
     fda:	81 11       	cpse	r24, r1
     fdc:	24 c0       	rjmp	.+72     	; 0x1026 <KP_GetPressedValue+0xde>
            {
               if(u32_NewState > 0)
     fde:	81 14       	cp	r8, r1
     fe0:	91 04       	cpc	r9, r1
     fe2:	a1 04       	cpc	r10, r1
     fe4:	b1 04       	cpc	r11, r1
     fe6:	11 f0       	breq	.+4      	; 0xfec <KP_GetPressedValue+0xa4>
               {
                  u32_NewState |= 1;
     fe8:	68 94       	set
     fea:	80 f8       	bld	r8, 0
               }
               switch(KP_CH)
     fec:	e1 10       	cpse	r14, r1
     fee:	1b c0       	rjmp	.+54     	; 0x1026 <KP_GetPressedValue+0xde>
               {
                  #ifdef KP_CH_0
                  case KP_CH_0:
                     u32_NewState |= (1<<KP_Ch0Map[u8_RowCounter][u8_ColCounter]);
     ff0:	8f 2d       	mov	r24, r15
     ff2:	90 e0       	ldi	r25, 0x00	; 0
     ff4:	fc 01       	movw	r30, r24
     ff6:	ee 0f       	add	r30, r30
     ff8:	ff 1f       	adc	r31, r31
     ffa:	e8 0f       	add	r30, r24
     ffc:	f9 1f       	adc	r31, r25
     ffe:	e3 53       	subi	r30, 0x33	; 51
    1000:	ff 4f       	sbci	r31, 0xFF	; 255
    1002:	e6 0d       	add	r30, r6
    1004:	f1 1d       	adc	r31, r1
    1006:	81 e0       	ldi	r24, 0x01	; 1
    1008:	90 e0       	ldi	r25, 0x00	; 0
    100a:	00 80       	ld	r0, Z
    100c:	02 c0       	rjmp	.+4      	; 0x1012 <KP_GetPressedValue+0xca>
    100e:	88 0f       	add	r24, r24
    1010:	99 1f       	adc	r25, r25
    1012:	0a 94       	dec	r0
    1014:	e2 f7       	brpl	.-8      	; 0x100e <KP_GetPressedValue+0xc6>
    1016:	09 2e       	mov	r0, r25
    1018:	00 0c       	add	r0, r0
    101a:	aa 0b       	sbc	r26, r26
    101c:	bb 0b       	sbc	r27, r27
    101e:	88 2a       	or	r8, r24
    1020:	99 2a       	or	r9, r25
    1022:	aa 2a       	or	r10, r26
    1024:	bb 2a       	or	r11, r27
         /* set column value to low */
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter) , PIN_OUTPUT);
         DIO_WritePin(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter), PIN_LOW);
         
         /* loops on every row */
         for(uint8_t u8_RowCounter = 0; u8_RowCounter < aSTR_KPConfig[KP_CH].u8_KPRows; u8_RowCounter++)
    1026:	f3 94       	inc	r15
    1028:	f8 01       	movw	r30, r16
    102a:	ee 0f       	add	r30, r30
    102c:	ff 1f       	adc	r31, r31
    102e:	e0 0f       	add	r30, r16
    1030:	f1 1f       	adc	r31, r17
    1032:	ee 0f       	add	r30, r30
    1034:	ff 1f       	adc	r31, r31
    1036:	e7 52       	subi	r30, 0x27	; 39
    1038:	ff 4f       	sbci	r31, 0xFF	; 255
    103a:	80 81       	ld	r24, Z
    103c:	f8 16       	cp	r15, r24
    103e:	08 f4       	brcc	.+2      	; 0x1042 <KP_GetPressedValue+0xfa>
    1040:	ba cf       	rjmp	.-140    	; 0xfb6 <KP_GetPressedValue+0x6e>
               }
            }
         }
         
         /* return column value to HIGH */
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter) , PIN_INPUT);
    1042:	40 e0       	ldi	r20, 0x00	; 0
    1044:	67 2d       	mov	r22, r7
    1046:	85 2d       	mov	r24, r5
    1048:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <DIO_SetPinDirection>
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter));
    104c:	67 2d       	mov	r22, r7
    104e:	85 2d       	mov	r24, r5
    1050:	0e 94 90 0a 	call	0x1520	; 0x1520 <DIO_EnablePinPullup>
      static uint32_t u32_OldState = 0x00;
      uint32_t u32_NewState = 0x00;
      uint8_t u8_KeyState;
      
      /* loops on every column */
      for(uint8_t u8_ColCounter = 0; u8_ColCounter < aSTR_KPConfig[KP_CH].u8_KPCols; u8_ColCounter++)
    1054:	63 94       	inc	r6
    1056:	0e 2d       	mov	r16, r14
    1058:	10 e0       	ldi	r17, 0x00	; 0
    105a:	f8 01       	movw	r30, r16
    105c:	ee 0f       	add	r30, r30
    105e:	ff 1f       	adc	r31, r31
    1060:	e0 0f       	add	r30, r16
    1062:	f1 1f       	adc	r31, r17
    1064:	ee 0f       	add	r30, r30
    1066:	ff 1f       	adc	r31, r31
    1068:	e7 52       	subi	r30, 0x27	; 39
    106a:	ff 4f       	sbci	r31, 0xFF	; 255
    106c:	83 81       	ldd	r24, Z+3	; 0x03
    106e:	68 16       	cp	r6, r24
    1070:	08 f4       	brcc	.+2      	; 0x1074 <KP_GetPressedValue+0x12c>
    1072:	89 cf       	rjmp	.-238    	; 0xf86 <KP_GetPressedValue+0x3e>
         /* return column value to HIGH */
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter) , PIN_INPUT);
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter));
      }
      
      if(u32_OldState == u32_NewState)
    1074:	80 91 2d 07 	lds	r24, 0x072D	; 0x80072d <u32_OldState.1655>
    1078:	90 91 2e 07 	lds	r25, 0x072E	; 0x80072e <u32_OldState.1655+0x1>
    107c:	a0 91 2f 07 	lds	r26, 0x072F	; 0x80072f <u32_OldState.1655+0x2>
    1080:	b0 91 30 07 	lds	r27, 0x0730	; 0x800730 <u32_OldState.1655+0x3>
    1084:	88 16       	cp	r8, r24
    1086:	99 06       	cpc	r9, r25
    1088:	aa 06       	cpc	r10, r26
    108a:	bb 06       	cpc	r11, r27
    108c:	39 f4       	brne	.+14     	; 0x109c <KP_GetPressedValue+0x154>
      {
         *Data = u32_NewState;
    108e:	f6 01       	movw	r30, r12
    1090:	80 82       	st	Z, r8
    1092:	91 82       	std	Z+1, r9	; 0x01
    1094:	a2 82       	std	Z+2, r10	; 0x02
    1096:	b3 82       	std	Z+3, r11	; 0x03
         KP_ErrorState = ERROR_OK;
    1098:	80 e0       	ldi	r24, 0x00	; 0
    109a:	01 c0       	rjmp	.+2      	; 0x109e <KP_GetPressedValue+0x156>
      }
      else
      {
         KP_ErrorState = ERROR_NOK;
    109c:	81 e0       	ldi	r24, 0x01	; 1
      }
      u32_OldState = u32_NewState;
    109e:	80 92 2d 07 	sts	0x072D, r8	; 0x80072d <u32_OldState.1655>
    10a2:	90 92 2e 07 	sts	0x072E, r9	; 0x80072e <u32_OldState.1655+0x1>
    10a6:	a0 92 2f 07 	sts	0x072F, r10	; 0x80072f <u32_OldState.1655+0x2>
    10aa:	b0 92 30 07 	sts	0x0730, r11	; 0x800730 <u32_OldState.1655+0x3>
    10ae:	03 c0       	rjmp	.+6      	; 0x10b6 <KP_GetPressedValue+0x16e>
   ERROR_STATE_t KP_ErrorState;
      
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Data)
   {
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_NULL_PTR);
    10b0:	81 ee       	ldi	r24, 0xE1	; 225
    10b2:	01 c0       	rjmp	.+2      	; 0x10b6 <KP_GetPressedValue+0x16e>
   }
   else if(KP_INVALID_CH <= KP_CH)
   {
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_INVALID_CH);
    10b4:	82 ee       	ldi	r24, 0xE2	; 226
      
   }
   
   /* return Error state. */
   return KP_ErrorState;
    10b6:	0f 90       	pop	r0
    10b8:	df 91       	pop	r29
    10ba:	cf 91       	pop	r28
    10bc:	1f 91       	pop	r17
    10be:	0f 91       	pop	r16
    10c0:	ff 90       	pop	r15
    10c2:	ef 90       	pop	r14
    10c4:	df 90       	pop	r13
    10c6:	cf 90       	pop	r12
    10c8:	bf 90       	pop	r11
    10ca:	af 90       	pop	r10
    10cc:	9f 90       	pop	r9
    10ce:	8f 90       	pop	r8
    10d0:	7f 90       	pop	r7
    10d2:	6f 90       	pop	r6
    10d4:	5f 90       	pop	r5
    10d6:	08 95       	ret

000010d8 <LED_Init>:
* @param [in]  LED_ch   -  LED channel number.
*
* @return function error state.
*/
extern ERROR_STATE_t LED_Init(uint8_t LED_ch)
{
    10d8:	ef 92       	push	r14
    10da:	ff 92       	push	r15
    10dc:	0f 93       	push	r16
    10de:	1f 93       	push	r17
    10e0:	cf 93       	push	r28
    10e2:	df 93       	push	r29
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    10e4:	81 11       	cpse	r24, r1
    10e6:	4e c0       	rjmp	.+156    	; 0x1184 <LED_Init+0xac>
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function was called before */
   else if(INIT == gu8_IsLEDInit[LED_ch])
    10e8:	c8 2f       	mov	r28, r24
    10ea:	d0 e0       	ldi	r29, 0x00	; 0
    10ec:	fe 01       	movw	r30, r28
    10ee:	ef 5c       	subi	r30, 0xCF	; 207
    10f0:	f8 4f       	sbci	r31, 0xF8	; 248
    10f2:	80 81       	ld	r24, Z
    10f4:	81 30       	cpi	r24, 0x01	; 1
    10f6:	09 f4       	brne	.+2      	; 0x10fa <LED_Init+0x22>
    10f8:	47 c0       	rjmp	.+142    	; 0x1188 <LED_Init+0xb0>
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INIT_BEFORE);
   }
   else
   {
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    10fa:	fe 01       	movw	r30, r28
    10fc:	ee 0f       	add	r30, r30
    10fe:	ff 1f       	adc	r31, r31
    1100:	ee 0f       	add	r30, r30
    1102:	ff 1f       	adc	r31, r31
    1104:	e1 52       	subi	r30, 0x21	; 33
    1106:	ff 4f       	sbci	r31, 0xFF	; 255
    1108:	82 81       	ldd	r24, Z+2	; 0x02
    110a:	81 11       	cpse	r24, r1
    110c:	14 c0       	rjmp	.+40     	; 0x1136 <LED_Init+0x5e>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* configure LED pin */
         DIO_ErrorState = DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
    110e:	fe 01       	movw	r30, r28
    1110:	ee 0f       	add	r30, r30
    1112:	ff 1f       	adc	r31, r31
    1114:	ee 0f       	add	r30, r30
    1116:	ff 1f       	adc	r31, r31
    1118:	e1 52       	subi	r30, 0x21	; 33
    111a:	ff 4f       	sbci	r31, 0xFF	; 255
    111c:	61 81       	ldd	r22, Z+1	; 0x01
    111e:	41 e0       	ldi	r20, 0x01	; 1
    1120:	80 81       	ld	r24, Z
    1122:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <DIO_SetPinDirection>
         /* make sure pin configuration is successful */
         if(ERROR_OK != DIO_ErrorState)
    1126:	81 11       	cpse	r24, r1
    1128:	31 c0       	rjmp	.+98     	; 0x118c <LED_Init+0xb4>
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            gu8_IsLEDInit[LED_ch] = INIT;
    112a:	cf 5c       	subi	r28, 0xCF	; 207
    112c:	d8 4f       	sbci	r29, 0xF8	; 248
    112e:	81 e0       	ldi	r24, 0x01	; 1
    1130:	88 83       	st	Y, r24
            LED_ErrorState = ERROR_OK;
    1132:	80 e0       	ldi	r24, 0x00	; 0
    1134:	30 c0       	rjmp	.+96     	; 0x1196 <LED_Init+0xbe>
         }
      }
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
    1136:	81 30       	cpi	r24, 0x01	; 1
    1138:	59 f5       	brne	.+86     	; 0x1190 <LED_Init+0xb8>
      {
         ERROR_STATE_t ErrorState;
         
         ErrorState = PWM_Init(gSTR_LEDConfig[LED_ch].u8_PWMCh);
    113a:	ce 01       	movw	r24, r28
    113c:	88 0f       	add	r24, r24
    113e:	99 1f       	adc	r25, r25
    1140:	88 0f       	add	r24, r24
    1142:	99 1f       	adc	r25, r25
    1144:	9c 01       	movw	r18, r24
    1146:	21 52       	subi	r18, 0x21	; 33
    1148:	3f 4f       	sbci	r19, 0xFF	; 255
    114a:	79 01       	movw	r14, r18
    114c:	f9 01       	movw	r30, r18
    114e:	03 81       	ldd	r16, Z+3	; 0x03
    1150:	80 2f       	mov	r24, r16
    1152:	0e 94 ce 0a 	call	0x159c	; 0x159c <PWM_Init>
    1156:	18 2f       	mov	r17, r24
         ErrorState |= DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
    1158:	41 e0       	ldi	r20, 0x01	; 1
    115a:	f7 01       	movw	r30, r14
    115c:	61 81       	ldd	r22, Z+1	; 0x01
    115e:	80 81       	ld	r24, Z
    1160:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <DIO_SetPinDirection>
    1164:	18 2b       	or	r17, r24
         /*START THE PWM WAVE*/
         ErrorState |= PWM_Start(gSTR_LEDConfig[LED_ch].u8_PWMCh);
    1166:	80 2f       	mov	r24, r16
    1168:	0e 94 ff 0a 	call	0x15fe	; 0x15fe <PWM_Start>
    116c:	18 2b       	or	r17, r24
         ErrorState |= PWM_Connect(gSTR_LEDConfig[LED_ch].u8_PWMCh);
    116e:	80 2f       	mov	r24, r16
    1170:	0e 94 0b 0b 	call	0x1616	; 0x1616 <PWM_Connect>
    1174:	81 2b       	or	r24, r17
         if(ERROR_OK != ErrorState)
    1176:	71 f4       	brne	.+28     	; 0x1194 <LED_Init+0xbc>
         {
            LED_ErrorState = ERROR_NOK;
         }  
         else
         {
            gu8_IsLEDInit[LED_ch] = INIT;
    1178:	cf 5c       	subi	r28, 0xCF	; 207
    117a:	d8 4f       	sbci	r29, 0xF8	; 248
    117c:	81 e0       	ldi	r24, 0x01	; 1
    117e:	88 83       	st	Y, r24
            LED_ErrorState = ERROR_OK;
    1180:	80 e0       	ldi	r24, 0x00	; 0
    1182:	09 c0       	rjmp	.+18     	; 0x1196 <LED_Init+0xbe>
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    1184:	81 ec       	ldi	r24, 0xC1	; 193
    1186:	07 c0       	rjmp	.+14     	; 0x1196 <LED_Init+0xbe>
   }
   /* check if init function was called before */
   else if(INIT == gu8_IsLEDInit[LED_ch])
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INIT_BEFORE);
    1188:	82 ec       	ldi	r24, 0xC2	; 194
    118a:	05 c0       	rjmp	.+10     	; 0x1196 <LED_Init+0xbe>
         /* configure LED pin */
         DIO_ErrorState = DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
         /* make sure pin configuration is successful */
         if(ERROR_OK != DIO_ErrorState)
         {
            LED_ErrorState = ERROR_NOK;
    118c:	81 e0       	ldi	r24, 0x01	; 1
    118e:	03 c0       	rjmp	.+6      	; 0x1196 <LED_Init+0xbe>
            LED_ErrorState = ERROR_OK;
         }          
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
    1190:	81 e0       	ldi	r24, 0x01	; 1
    1192:	01 c0       	rjmp	.+2      	; 0x1196 <LED_Init+0xbe>
         /*START THE PWM WAVE*/
         ErrorState |= PWM_Start(gSTR_LEDConfig[LED_ch].u8_PWMCh);
         ErrorState |= PWM_Connect(gSTR_LEDConfig[LED_ch].u8_PWMCh);
         if(ERROR_OK != ErrorState)
         {
            LED_ErrorState = ERROR_NOK;
    1194:	81 e0       	ldi	r24, 0x01	; 1
         LED_ErrorState = ERROR_NOK;
      }   
   }
   
   return LED_ErrorState;
}
    1196:	df 91       	pop	r29
    1198:	cf 91       	pop	r28
    119a:	1f 91       	pop	r17
    119c:	0f 91       	pop	r16
    119e:	ff 90       	pop	r15
    11a0:	ef 90       	pop	r14
    11a2:	08 95       	ret

000011a4 <LED_Off>:
extern ERROR_STATE_t LED_Off(uint8_t LED_ch)
{
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    11a4:	81 11       	cpse	r24, r1
    11a6:	32 c0       	rjmp	.+100    	; 0x120c <LED_Off+0x68>
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
    11a8:	90 e0       	ldi	r25, 0x00	; 0
    11aa:	fc 01       	movw	r30, r24
    11ac:	ef 5c       	subi	r30, 0xCF	; 207
    11ae:	f8 4f       	sbci	r31, 0xF8	; 248
    11b0:	20 81       	ld	r18, Z
    11b2:	21 30       	cpi	r18, 0x01	; 1
    11b4:	69 f5       	brne	.+90     	; 0x1210 <LED_Off+0x6c>
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   else
   {
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    11b6:	fc 01       	movw	r30, r24
    11b8:	ee 0f       	add	r30, r30
    11ba:	ff 1f       	adc	r31, r31
    11bc:	ee 0f       	add	r30, r30
    11be:	ff 1f       	adc	r31, r31
    11c0:	e1 52       	subi	r30, 0x21	; 33
    11c2:	ff 4f       	sbci	r31, 0xFF	; 255
    11c4:	22 81       	ldd	r18, Z+2	; 0x02
    11c6:	21 11       	cpse	r18, r1
    11c8:	10 c0       	rjmp	.+32     	; 0x11ea <LED_Off+0x46>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* set LED pin to low */
         DIO_ErrorState = DIO_WritePin(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_LOW);
    11ca:	88 0f       	add	r24, r24
    11cc:	99 1f       	adc	r25, r25
    11ce:	88 0f       	add	r24, r24
    11d0:	99 1f       	adc	r25, r25
    11d2:	fc 01       	movw	r30, r24
    11d4:	e1 52       	subi	r30, 0x21	; 33
    11d6:	ff 4f       	sbci	r31, 0xFF	; 255
    11d8:	61 81       	ldd	r22, Z+1	; 0x01
    11da:	40 e0       	ldi	r20, 0x00	; 0
    11dc:	80 81       	ld	r24, Z
    11de:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <DIO_WritePin>
         
         /* make sure DIO function was successful */
         if(ERROR_OK != DIO_ErrorState)
    11e2:	88 23       	and	r24, r24
    11e4:	b9 f0       	breq	.+46     	; 0x1214 <LED_Off+0x70>
         {
            LED_ErrorState = ERROR_NOK;
    11e6:	81 e0       	ldi	r24, 0x01	; 1
    11e8:	08 95       	ret
         else
         {
            LED_ErrorState = ERROR_OK;
         }
      }
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
    11ea:	21 30       	cpi	r18, 0x01	; 1
    11ec:	a9 f4       	brne	.+42     	; 0x1218 <LED_Off+0x74>
      {
         ERROR_STATE_t PWM_ErrorState;
         
         PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, 0);
    11ee:	88 0f       	add	r24, r24
    11f0:	99 1f       	adc	r25, r25
    11f2:	88 0f       	add	r24, r24
    11f4:	99 1f       	adc	r25, r25
    11f6:	fc 01       	movw	r30, r24
    11f8:	e1 52       	subi	r30, 0x21	; 33
    11fa:	ff 4f       	sbci	r31, 0xFF	; 255
    11fc:	60 e0       	ldi	r22, 0x00	; 0
    11fe:	83 81       	ldd	r24, Z+3	; 0x03
    1200:	0e 94 1c 0b 	call	0x1638	; 0x1638 <PWM_SetDuty>
         
         if(ERROR_OK != PWM_ErrorState)
    1204:	88 23       	and	r24, r24
    1206:	51 f0       	breq	.+20     	; 0x121c <LED_Off+0x78>
         {
            LED_ErrorState = ERROR_NOK;
    1208:	81 e0       	ldi	r24, 0x01	; 1
    120a:	08 95       	ret
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    120c:	81 ec       	ldi	r24, 0xC1	; 193
    120e:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
    1210:	83 ec       	ldi	r24, 0xC3	; 195
    1212:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    1214:	80 e0       	ldi	r24, 0x00	; 0
    1216:	08 95       	ret
            LED_ErrorState = ERROR_OK;
         }
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
    1218:	81 e0       	ldi	r24, 0x01	; 1
    121a:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    121c:	80 e0       	ldi	r24, 0x00	; 0
         LED_ErrorState = ERROR_NOK;
      }
   }
   
   return LED_ErrorState;
}
    121e:	08 95       	ret

00001220 <LED_On>:
extern ERROR_STATE_t LED_On(uint8_t LED_ch)
{
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    1220:	81 11       	cpse	r24, r1
    1222:	32 c0       	rjmp	.+100    	; 0x1288 <LED_On+0x68>
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
    1224:	90 e0       	ldi	r25, 0x00	; 0
    1226:	fc 01       	movw	r30, r24
    1228:	ef 5c       	subi	r30, 0xCF	; 207
    122a:	f8 4f       	sbci	r31, 0xF8	; 248
    122c:	20 81       	ld	r18, Z
    122e:	21 30       	cpi	r18, 0x01	; 1
    1230:	69 f5       	brne	.+90     	; 0x128c <LED_On+0x6c>
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   else
   {
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    1232:	fc 01       	movw	r30, r24
    1234:	ee 0f       	add	r30, r30
    1236:	ff 1f       	adc	r31, r31
    1238:	ee 0f       	add	r30, r30
    123a:	ff 1f       	adc	r31, r31
    123c:	e1 52       	subi	r30, 0x21	; 33
    123e:	ff 4f       	sbci	r31, 0xFF	; 255
    1240:	22 81       	ldd	r18, Z+2	; 0x02
    1242:	21 11       	cpse	r18, r1
    1244:	10 c0       	rjmp	.+32     	; 0x1266 <LED_On+0x46>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* set LED pin to low */
         DIO_ErrorState = DIO_WritePin(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_HIGH);
    1246:	88 0f       	add	r24, r24
    1248:	99 1f       	adc	r25, r25
    124a:	88 0f       	add	r24, r24
    124c:	99 1f       	adc	r25, r25
    124e:	fc 01       	movw	r30, r24
    1250:	e1 52       	subi	r30, 0x21	; 33
    1252:	ff 4f       	sbci	r31, 0xFF	; 255
    1254:	61 81       	ldd	r22, Z+1	; 0x01
    1256:	41 e0       	ldi	r20, 0x01	; 1
    1258:	80 81       	ld	r24, Z
    125a:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <DIO_WritePin>
         
         /* make sure DIO function was successful */
         if(ERROR_OK != DIO_ErrorState)
    125e:	88 23       	and	r24, r24
    1260:	b9 f0       	breq	.+46     	; 0x1290 <LED_On+0x70>
         {
            LED_ErrorState = ERROR_NOK;
    1262:	81 e0       	ldi	r24, 0x01	; 1
    1264:	08 95       	ret
         else
         {
            LED_ErrorState = ERROR_OK;
         }
      }
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
    1266:	21 30       	cpi	r18, 0x01	; 1
    1268:	a9 f4       	brne	.+42     	; 0x1294 <LED_On+0x74>
      {
         ERROR_STATE_t PWM_ErrorState;
         
         PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, 100);
    126a:	88 0f       	add	r24, r24
    126c:	99 1f       	adc	r25, r25
    126e:	88 0f       	add	r24, r24
    1270:	99 1f       	adc	r25, r25
    1272:	fc 01       	movw	r30, r24
    1274:	e1 52       	subi	r30, 0x21	; 33
    1276:	ff 4f       	sbci	r31, 0xFF	; 255
    1278:	64 e6       	ldi	r22, 0x64	; 100
    127a:	83 81       	ldd	r24, Z+3	; 0x03
    127c:	0e 94 1c 0b 	call	0x1638	; 0x1638 <PWM_SetDuty>
         
         if(ERROR_OK != PWM_ErrorState)
    1280:	88 23       	and	r24, r24
    1282:	51 f0       	breq	.+20     	; 0x1298 <LED_On+0x78>
         {
            LED_ErrorState = ERROR_NOK;
    1284:	81 e0       	ldi	r24, 0x01	; 1
    1286:	08 95       	ret
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    1288:	81 ec       	ldi	r24, 0xC1	; 193
    128a:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
    128c:	83 ec       	ldi	r24, 0xC3	; 195
    128e:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    1290:	80 e0       	ldi	r24, 0x00	; 0
    1292:	08 95       	ret
            LED_ErrorState = ERROR_OK;
         }
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
    1294:	81 e0       	ldi	r24, 0x01	; 1
    1296:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    1298:	80 e0       	ldi	r24, 0x00	; 0
         LED_ErrorState = ERROR_NOK;
      }
   }
   
   return LED_ErrorState;
}
    129a:	08 95       	ret

0000129c <LED_Dim>:
extern ERROR_STATE_t LED_Dim(uint8_t LED_ch, uint8_t Duty)
{
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    129c:	81 11       	cpse	r24, r1
    129e:	21 c0       	rjmp	.+66     	; 0x12e2 <LED_Dim+0x46>
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
    12a0:	90 e0       	ldi	r25, 0x00	; 0
    12a2:	fc 01       	movw	r30, r24
    12a4:	ef 5c       	subi	r30, 0xCF	; 207
    12a6:	f8 4f       	sbci	r31, 0xF8	; 248
    12a8:	20 81       	ld	r18, Z
    12aa:	21 30       	cpi	r18, 0x01	; 1
    12ac:	e1 f4       	brne	.+56     	; 0x12e6 <LED_Dim+0x4a>
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   else if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    12ae:	fc 01       	movw	r30, r24
    12b0:	ee 0f       	add	r30, r30
    12b2:	ff 1f       	adc	r31, r31
    12b4:	ee 0f       	add	r30, r30
    12b6:	ff 1f       	adc	r31, r31
    12b8:	e1 52       	subi	r30, 0x21	; 33
    12ba:	ff 4f       	sbci	r31, 0xFF	; 255
    12bc:	22 81       	ldd	r18, Z+2	; 0x02
    12be:	22 23       	and	r18, r18
    12c0:	a1 f0       	breq	.+40     	; 0x12ea <LED_Dim+0x4e>
   {
      LED_ErrorState = ERROR_NOK;
   }
   else if(100 < Duty)
    12c2:	65 36       	cpi	r22, 0x65	; 101
    12c4:	a0 f4       	brcc	.+40     	; 0x12ee <LED_Dim+0x52>
   }     
   else
   {
      ERROR_STATE_t PWM_ErrorState;
         
      PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, Duty);
    12c6:	88 0f       	add	r24, r24
    12c8:	99 1f       	adc	r25, r25
    12ca:	88 0f       	add	r24, r24
    12cc:	99 1f       	adc	r25, r25
    12ce:	fc 01       	movw	r30, r24
    12d0:	e1 52       	subi	r30, 0x21	; 33
    12d2:	ff 4f       	sbci	r31, 0xFF	; 255
    12d4:	83 81       	ldd	r24, Z+3	; 0x03
    12d6:	0e 94 1c 0b 	call	0x1638	; 0x1638 <PWM_SetDuty>
         
      if(ERROR_OK != PWM_ErrorState)
    12da:	88 23       	and	r24, r24
    12dc:	51 f0       	breq	.+20     	; 0x12f2 <LED_Dim+0x56>
      {
         LED_ErrorState = ERROR_NOK;
    12de:	81 e0       	ldi	r24, 0x01	; 1
    12e0:	08 95       	ret
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    12e2:	81 ec       	ldi	r24, 0xC1	; 193
    12e4:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
    12e6:	83 ec       	ldi	r24, 0xC3	; 195
    12e8:	08 95       	ret
   }
   else if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
   {
      LED_ErrorState = ERROR_NOK;
    12ea:	81 e0       	ldi	r24, 0x01	; 1
    12ec:	08 95       	ret
   }
   else if(100 < Duty)
   {
      LED_ErrorState = ERROR_NOK;
    12ee:	81 e0       	ldi	r24, 0x01	; 1
    12f0:	08 95       	ret
      {
         LED_ErrorState = ERROR_NOK;
      }
      else
      {
         LED_ErrorState = ERROR_OK;
    12f2:	80 e0       	ldi	r24, 0x00	; 0
      }
   }
   
   return LED_ErrorState;
}
    12f4:	08 95       	ret

000012f6 <DIO_SetPinDirection>:
				u8_ErrorState=ERROR_NOK;
				break;	
		}	
	}	
	return u8_ErrorState;
}
    12f6:	42 30       	cpi	r20, 0x02	; 2
    12f8:	08 f0       	brcs	.+2      	; 0x12fc <DIO_SetPinDirection+0x6>
    12fa:	60 c0       	rjmp	.+192    	; 0x13bc <DIO_SetPinDirection+0xc6>
    12fc:	68 30       	cpi	r22, 0x08	; 8
    12fe:	08 f0       	brcs	.+2      	; 0x1302 <DIO_SetPinDirection+0xc>
    1300:	5f c0       	rjmp	.+190    	; 0x13c0 <DIO_SetPinDirection+0xca>
    1302:	81 30       	cpi	r24, 0x01	; 1
    1304:	e1 f0       	breq	.+56     	; 0x133e <DIO_SetPinDirection+0x48>
    1306:	30 f0       	brcs	.+12     	; 0x1314 <DIO_SetPinDirection+0x1e>
    1308:	82 30       	cpi	r24, 0x02	; 2
    130a:	71 f1       	breq	.+92     	; 0x1368 <DIO_SetPinDirection+0x72>
    130c:	83 30       	cpi	r24, 0x03	; 3
    130e:	09 f4       	brne	.+2      	; 0x1312 <DIO_SetPinDirection+0x1c>
    1310:	40 c0       	rjmp	.+128    	; 0x1392 <DIO_SetPinDirection+0x9c>
    1312:	58 c0       	rjmp	.+176    	; 0x13c4 <DIO_SetPinDirection+0xce>
    1314:	2a b3       	in	r18, 0x1a	; 26
    1316:	81 e0       	ldi	r24, 0x01	; 1
    1318:	90 e0       	ldi	r25, 0x00	; 0
    131a:	06 2e       	mov	r0, r22
    131c:	02 c0       	rjmp	.+4      	; 0x1322 <DIO_SetPinDirection+0x2c>
    131e:	88 0f       	add	r24, r24
    1320:	99 1f       	adc	r25, r25
    1322:	0a 94       	dec	r0
    1324:	e2 f7       	brpl	.-8      	; 0x131e <DIO_SetPinDirection+0x28>
    1326:	50 e0       	ldi	r21, 0x00	; 0
    1328:	02 c0       	rjmp	.+4      	; 0x132e <DIO_SetPinDirection+0x38>
    132a:	44 0f       	add	r20, r20
    132c:	55 1f       	adc	r21, r21
    132e:	6a 95       	dec	r22
    1330:	e2 f7       	brpl	.-8      	; 0x132a <DIO_SetPinDirection+0x34>
    1332:	80 95       	com	r24
    1334:	82 23       	and	r24, r18
    1336:	48 2b       	or	r20, r24
    1338:	4a bb       	out	0x1a, r20	; 26
    133a:	80 e0       	ldi	r24, 0x00	; 0
    133c:	08 95       	ret
    133e:	27 b3       	in	r18, 0x17	; 23
    1340:	81 e0       	ldi	r24, 0x01	; 1
    1342:	90 e0       	ldi	r25, 0x00	; 0
    1344:	06 2e       	mov	r0, r22
    1346:	02 c0       	rjmp	.+4      	; 0x134c <DIO_SetPinDirection+0x56>
    1348:	88 0f       	add	r24, r24
    134a:	99 1f       	adc	r25, r25
    134c:	0a 94       	dec	r0
    134e:	e2 f7       	brpl	.-8      	; 0x1348 <DIO_SetPinDirection+0x52>
    1350:	50 e0       	ldi	r21, 0x00	; 0
    1352:	02 c0       	rjmp	.+4      	; 0x1358 <DIO_SetPinDirection+0x62>
    1354:	44 0f       	add	r20, r20
    1356:	55 1f       	adc	r21, r21
    1358:	6a 95       	dec	r22
    135a:	e2 f7       	brpl	.-8      	; 0x1354 <DIO_SetPinDirection+0x5e>
    135c:	80 95       	com	r24
    135e:	82 23       	and	r24, r18
    1360:	48 2b       	or	r20, r24
    1362:	47 bb       	out	0x17, r20	; 23
    1364:	80 e0       	ldi	r24, 0x00	; 0
    1366:	08 95       	ret
    1368:	24 b3       	in	r18, 0x14	; 20
    136a:	81 e0       	ldi	r24, 0x01	; 1
    136c:	90 e0       	ldi	r25, 0x00	; 0
    136e:	06 2e       	mov	r0, r22
    1370:	02 c0       	rjmp	.+4      	; 0x1376 <DIO_SetPinDirection+0x80>
    1372:	88 0f       	add	r24, r24
    1374:	99 1f       	adc	r25, r25
    1376:	0a 94       	dec	r0
    1378:	e2 f7       	brpl	.-8      	; 0x1372 <DIO_SetPinDirection+0x7c>
    137a:	50 e0       	ldi	r21, 0x00	; 0
    137c:	02 c0       	rjmp	.+4      	; 0x1382 <DIO_SetPinDirection+0x8c>
    137e:	44 0f       	add	r20, r20
    1380:	55 1f       	adc	r21, r21
    1382:	6a 95       	dec	r22
    1384:	e2 f7       	brpl	.-8      	; 0x137e <DIO_SetPinDirection+0x88>
    1386:	80 95       	com	r24
    1388:	82 23       	and	r24, r18
    138a:	48 2b       	or	r20, r24
    138c:	44 bb       	out	0x14, r20	; 20
    138e:	80 e0       	ldi	r24, 0x00	; 0
    1390:	08 95       	ret
    1392:	21 b3       	in	r18, 0x11	; 17
    1394:	81 e0       	ldi	r24, 0x01	; 1
    1396:	90 e0       	ldi	r25, 0x00	; 0
    1398:	06 2e       	mov	r0, r22
    139a:	02 c0       	rjmp	.+4      	; 0x13a0 <DIO_SetPinDirection+0xaa>
    139c:	88 0f       	add	r24, r24
    139e:	99 1f       	adc	r25, r25
    13a0:	0a 94       	dec	r0
    13a2:	e2 f7       	brpl	.-8      	; 0x139c <DIO_SetPinDirection+0xa6>
    13a4:	50 e0       	ldi	r21, 0x00	; 0
    13a6:	02 c0       	rjmp	.+4      	; 0x13ac <DIO_SetPinDirection+0xb6>
    13a8:	44 0f       	add	r20, r20
    13aa:	55 1f       	adc	r21, r21
    13ac:	6a 95       	dec	r22
    13ae:	e2 f7       	brpl	.-8      	; 0x13a8 <DIO_SetPinDirection+0xb2>
    13b0:	80 95       	com	r24
    13b2:	82 23       	and	r24, r18
    13b4:	48 2b       	or	r20, r24
    13b6:	41 bb       	out	0x11, r20	; 17
    13b8:	80 e0       	ldi	r24, 0x00	; 0
    13ba:	08 95       	ret
    13bc:	81 e0       	ldi	r24, 0x01	; 1
    13be:	08 95       	ret
    13c0:	81 e0       	ldi	r24, 0x01	; 1
    13c2:	08 95       	ret
    13c4:	81 e0       	ldi	r24, 0x01	; 1
    13c6:	08 95       	ret

000013c8 <DIO_WritePin>:
    13c8:	42 30       	cpi	r20, 0x02	; 2
    13ca:	08 f0       	brcs	.+2      	; 0x13ce <DIO_WritePin+0x6>
    13cc:	60 c0       	rjmp	.+192    	; 0x148e <DIO_WritePin+0xc6>
    13ce:	68 30       	cpi	r22, 0x08	; 8
    13d0:	08 f0       	brcs	.+2      	; 0x13d4 <DIO_WritePin+0xc>
    13d2:	5f c0       	rjmp	.+190    	; 0x1492 <DIO_WritePin+0xca>
    13d4:	81 30       	cpi	r24, 0x01	; 1
    13d6:	e1 f0       	breq	.+56     	; 0x1410 <DIO_WritePin+0x48>
    13d8:	30 f0       	brcs	.+12     	; 0x13e6 <DIO_WritePin+0x1e>
    13da:	82 30       	cpi	r24, 0x02	; 2
    13dc:	71 f1       	breq	.+92     	; 0x143a <DIO_WritePin+0x72>
    13de:	83 30       	cpi	r24, 0x03	; 3
    13e0:	09 f4       	brne	.+2      	; 0x13e4 <DIO_WritePin+0x1c>
    13e2:	40 c0       	rjmp	.+128    	; 0x1464 <DIO_WritePin+0x9c>
    13e4:	58 c0       	rjmp	.+176    	; 0x1496 <DIO_WritePin+0xce>
    13e6:	2b b3       	in	r18, 0x1b	; 27
    13e8:	81 e0       	ldi	r24, 0x01	; 1
    13ea:	90 e0       	ldi	r25, 0x00	; 0
    13ec:	06 2e       	mov	r0, r22
    13ee:	02 c0       	rjmp	.+4      	; 0x13f4 <DIO_WritePin+0x2c>
    13f0:	88 0f       	add	r24, r24
    13f2:	99 1f       	adc	r25, r25
    13f4:	0a 94       	dec	r0
    13f6:	e2 f7       	brpl	.-8      	; 0x13f0 <DIO_WritePin+0x28>
    13f8:	50 e0       	ldi	r21, 0x00	; 0
    13fa:	02 c0       	rjmp	.+4      	; 0x1400 <DIO_WritePin+0x38>
    13fc:	44 0f       	add	r20, r20
    13fe:	55 1f       	adc	r21, r21
    1400:	6a 95       	dec	r22
    1402:	e2 f7       	brpl	.-8      	; 0x13fc <DIO_WritePin+0x34>
    1404:	80 95       	com	r24
    1406:	82 23       	and	r24, r18
    1408:	48 2b       	or	r20, r24
    140a:	4b bb       	out	0x1b, r20	; 27
    140c:	80 e0       	ldi	r24, 0x00	; 0
    140e:	08 95       	ret
    1410:	28 b3       	in	r18, 0x18	; 24
    1412:	81 e0       	ldi	r24, 0x01	; 1
    1414:	90 e0       	ldi	r25, 0x00	; 0
    1416:	06 2e       	mov	r0, r22
    1418:	02 c0       	rjmp	.+4      	; 0x141e <DIO_WritePin+0x56>
    141a:	88 0f       	add	r24, r24
    141c:	99 1f       	adc	r25, r25
    141e:	0a 94       	dec	r0
    1420:	e2 f7       	brpl	.-8      	; 0x141a <DIO_WritePin+0x52>
    1422:	50 e0       	ldi	r21, 0x00	; 0
    1424:	02 c0       	rjmp	.+4      	; 0x142a <DIO_WritePin+0x62>
    1426:	44 0f       	add	r20, r20
    1428:	55 1f       	adc	r21, r21
    142a:	6a 95       	dec	r22
    142c:	e2 f7       	brpl	.-8      	; 0x1426 <DIO_WritePin+0x5e>
    142e:	80 95       	com	r24
    1430:	82 23       	and	r24, r18
    1432:	48 2b       	or	r20, r24
    1434:	48 bb       	out	0x18, r20	; 24
    1436:	80 e0       	ldi	r24, 0x00	; 0
    1438:	08 95       	ret
    143a:	25 b3       	in	r18, 0x15	; 21
    143c:	81 e0       	ldi	r24, 0x01	; 1
    143e:	90 e0       	ldi	r25, 0x00	; 0
    1440:	06 2e       	mov	r0, r22
    1442:	02 c0       	rjmp	.+4      	; 0x1448 <DIO_WritePin+0x80>
    1444:	88 0f       	add	r24, r24
    1446:	99 1f       	adc	r25, r25
    1448:	0a 94       	dec	r0
    144a:	e2 f7       	brpl	.-8      	; 0x1444 <DIO_WritePin+0x7c>
    144c:	50 e0       	ldi	r21, 0x00	; 0
    144e:	02 c0       	rjmp	.+4      	; 0x1454 <DIO_WritePin+0x8c>
    1450:	44 0f       	add	r20, r20
    1452:	55 1f       	adc	r21, r21
    1454:	6a 95       	dec	r22
    1456:	e2 f7       	brpl	.-8      	; 0x1450 <DIO_WritePin+0x88>
    1458:	80 95       	com	r24
    145a:	82 23       	and	r24, r18
    145c:	48 2b       	or	r20, r24
    145e:	45 bb       	out	0x15, r20	; 21
    1460:	80 e0       	ldi	r24, 0x00	; 0
    1462:	08 95       	ret
    1464:	22 b3       	in	r18, 0x12	; 18
    1466:	81 e0       	ldi	r24, 0x01	; 1
    1468:	90 e0       	ldi	r25, 0x00	; 0
    146a:	06 2e       	mov	r0, r22
    146c:	02 c0       	rjmp	.+4      	; 0x1472 <DIO_WritePin+0xaa>
    146e:	88 0f       	add	r24, r24
    1470:	99 1f       	adc	r25, r25
    1472:	0a 94       	dec	r0
    1474:	e2 f7       	brpl	.-8      	; 0x146e <DIO_WritePin+0xa6>
    1476:	50 e0       	ldi	r21, 0x00	; 0
    1478:	02 c0       	rjmp	.+4      	; 0x147e <DIO_WritePin+0xb6>
    147a:	44 0f       	add	r20, r20
    147c:	55 1f       	adc	r21, r21
    147e:	6a 95       	dec	r22
    1480:	e2 f7       	brpl	.-8      	; 0x147a <DIO_WritePin+0xb2>
    1482:	80 95       	com	r24
    1484:	82 23       	and	r24, r18
    1486:	48 2b       	or	r20, r24
    1488:	42 bb       	out	0x12, r20	; 18
    148a:	80 e0       	ldi	r24, 0x00	; 0
    148c:	08 95       	ret
    148e:	81 e0       	ldi	r24, 0x01	; 1
    1490:	08 95       	ret
    1492:	81 e0       	ldi	r24, 0x01	; 1
    1494:	08 95       	ret
    1496:	81 e0       	ldi	r24, 0x01	; 1
    1498:	08 95       	ret

0000149a <DIO_ReadPin>:
ERROR_STATE_t DIO_ReadPin(uint8_t PortName,uint8_t PinNo,ptr_uint8_t PinData)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PinNo>PIN7)
    149a:	68 30       	cpi	r22, 0x08	; 8
    149c:	d8 f5       	brcc	.+118    	; 0x1514 <DIO_ReadPin+0x7a>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else if(NULL_PTR==PinData)
    149e:	41 15       	cp	r20, r1
    14a0:	51 05       	cpc	r21, r1
    14a2:	d1 f1       	breq	.+116    	; 0x1518 <DIO_ReadPin+0x7e>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{
		switch(PortName)
    14a4:	81 30       	cpi	r24, 0x01	; 1
    14a6:	91 f0       	breq	.+36     	; 0x14cc <DIO_ReadPin+0x32>
    14a8:	28 f0       	brcs	.+10     	; 0x14b4 <DIO_ReadPin+0x1a>
    14aa:	82 30       	cpi	r24, 0x02	; 2
    14ac:	d9 f0       	breq	.+54     	; 0x14e4 <DIO_ReadPin+0x4a>
    14ae:	83 30       	cpi	r24, 0x03	; 3
    14b0:	29 f1       	breq	.+74     	; 0x14fc <DIO_ReadPin+0x62>
    14b2:	34 c0       	rjmp	.+104    	; 0x151c <DIO_ReadPin+0x82>
		{
			case PORT_A:
				* PinData=BIT_GET(PINA,PinNo);
    14b4:	89 b3       	in	r24, 0x19	; 25
    14b6:	90 e0       	ldi	r25, 0x00	; 0
    14b8:	02 c0       	rjmp	.+4      	; 0x14be <DIO_ReadPin+0x24>
    14ba:	95 95       	asr	r25
    14bc:	87 95       	ror	r24
    14be:	6a 95       	dec	r22
    14c0:	e2 f7       	brpl	.-8      	; 0x14ba <DIO_ReadPin+0x20>
    14c2:	81 70       	andi	r24, 0x01	; 1
    14c4:	fa 01       	movw	r30, r20
    14c6:	80 83       	st	Z, r24
				u8_ErrorState=ERROR_OK;
    14c8:	80 e0       	ldi	r24, 0x00	; 0
				break;
    14ca:	08 95       	ret
			case PORT_B:
				* PinData=BIT_GET(PINB,PinNo);
    14cc:	86 b3       	in	r24, 0x16	; 22
    14ce:	90 e0       	ldi	r25, 0x00	; 0
    14d0:	02 c0       	rjmp	.+4      	; 0x14d6 <DIO_ReadPin+0x3c>
    14d2:	95 95       	asr	r25
    14d4:	87 95       	ror	r24
    14d6:	6a 95       	dec	r22
    14d8:	e2 f7       	brpl	.-8      	; 0x14d2 <DIO_ReadPin+0x38>
    14da:	81 70       	andi	r24, 0x01	; 1
    14dc:	fa 01       	movw	r30, r20
    14de:	80 83       	st	Z, r24
				u8_ErrorState=ERROR_OK;
    14e0:	80 e0       	ldi	r24, 0x00	; 0
				break;
    14e2:	08 95       	ret
			case PORT_C:
				* PinData=BIT_GET(PINC,PinNo);
    14e4:	83 b3       	in	r24, 0x13	; 19
    14e6:	90 e0       	ldi	r25, 0x00	; 0
    14e8:	02 c0       	rjmp	.+4      	; 0x14ee <DIO_ReadPin+0x54>
    14ea:	95 95       	asr	r25
    14ec:	87 95       	ror	r24
    14ee:	6a 95       	dec	r22
    14f0:	e2 f7       	brpl	.-8      	; 0x14ea <DIO_ReadPin+0x50>
    14f2:	81 70       	andi	r24, 0x01	; 1
    14f4:	fa 01       	movw	r30, r20
    14f6:	80 83       	st	Z, r24
				u8_ErrorState=ERROR_OK;
    14f8:	80 e0       	ldi	r24, 0x00	; 0
				break;
    14fa:	08 95       	ret
			case PORT_D:
				* PinData=BIT_GET(PIND,PinNo);
    14fc:	80 b3       	in	r24, 0x10	; 16
    14fe:	90 e0       	ldi	r25, 0x00	; 0
    1500:	02 c0       	rjmp	.+4      	; 0x1506 <DIO_ReadPin+0x6c>
    1502:	95 95       	asr	r25
    1504:	87 95       	ror	r24
    1506:	6a 95       	dec	r22
    1508:	e2 f7       	brpl	.-8      	; 0x1502 <DIO_ReadPin+0x68>
    150a:	81 70       	andi	r24, 0x01	; 1
    150c:	fa 01       	movw	r30, r20
    150e:	80 83       	st	Z, r24
				u8_ErrorState=ERROR_OK;
    1510:	80 e0       	ldi	r24, 0x00	; 0
				break;
    1512:	08 95       	ret
ERROR_STATE_t DIO_ReadPin(uint8_t PortName,uint8_t PinNo,ptr_uint8_t PinData)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PinNo>PIN7)
	{
		u8_ErrorState=ERROR_NOK;
    1514:	81 e0       	ldi	r24, 0x01	; 1
    1516:	08 95       	ret
	}
	else if(NULL_PTR==PinData)
	{
		u8_ErrorState=ERROR_NOK;
    1518:	81 e0       	ldi	r24, 0x01	; 1
    151a:	08 95       	ret
			case PORT_D:
				* PinData=BIT_GET(PIND,PinNo);
				u8_ErrorState=ERROR_OK;
				break;
			default:
				u8_ErrorState=ERROR_NOK;
    151c:	81 e0       	ldi	r24, 0x01	; 1
				break;
		}
	}	
	return u8_ErrorState;
}
    151e:	08 95       	ret

00001520 <DIO_EnablePinPullup>:


ERROR_STATE_t DIO_EnablePinPullup(uint8_t PortName,uint8_t PinNo)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PinNo>PIN7)
    1520:	68 30       	cpi	r22, 0x08	; 8
    1522:	c0 f5       	brcc	.+112    	; 0x1594 <DIO_EnablePinPullup+0x74>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{	
		switch(PortName)
    1524:	81 30       	cpi	r24, 0x01	; 1
    1526:	91 f0       	breq	.+36     	; 0x154c <DIO_EnablePinPullup+0x2c>
    1528:	28 f0       	brcs	.+10     	; 0x1534 <DIO_EnablePinPullup+0x14>
    152a:	82 30       	cpi	r24, 0x02	; 2
    152c:	d9 f0       	breq	.+54     	; 0x1564 <DIO_EnablePinPullup+0x44>
    152e:	83 30       	cpi	r24, 0x03	; 3
    1530:	29 f1       	breq	.+74     	; 0x157c <DIO_EnablePinPullup+0x5c>
    1532:	32 c0       	rjmp	.+100    	; 0x1598 <DIO_EnablePinPullup+0x78>
		{
			case PORT_A:
				BIT_WRITE(PORTA,PinNo,PIN_HIGH);
    1534:	81 e0       	ldi	r24, 0x01	; 1
    1536:	90 e0       	ldi	r25, 0x00	; 0
    1538:	02 c0       	rjmp	.+4      	; 0x153e <DIO_EnablePinPullup+0x1e>
    153a:	88 0f       	add	r24, r24
    153c:	99 1f       	adc	r25, r25
    153e:	6a 95       	dec	r22
    1540:	e2 f7       	brpl	.-8      	; 0x153a <DIO_EnablePinPullup+0x1a>
    1542:	9b b3       	in	r25, 0x1b	; 27
    1544:	89 2b       	or	r24, r25
    1546:	8b bb       	out	0x1b, r24	; 27
				u8_ErrorState=ERROR_OK;
    1548:	80 e0       	ldi	r24, 0x00	; 0
				break;
    154a:	08 95       	ret
			case PORT_B:
				BIT_WRITE(PORTB,PinNo,PIN_HIGH);
    154c:	81 e0       	ldi	r24, 0x01	; 1
    154e:	90 e0       	ldi	r25, 0x00	; 0
    1550:	02 c0       	rjmp	.+4      	; 0x1556 <DIO_EnablePinPullup+0x36>
    1552:	88 0f       	add	r24, r24
    1554:	99 1f       	adc	r25, r25
    1556:	6a 95       	dec	r22
    1558:	e2 f7       	brpl	.-8      	; 0x1552 <DIO_EnablePinPullup+0x32>
    155a:	98 b3       	in	r25, 0x18	; 24
    155c:	89 2b       	or	r24, r25
    155e:	88 bb       	out	0x18, r24	; 24
				u8_ErrorState=ERROR_OK;
    1560:	80 e0       	ldi	r24, 0x00	; 0
				break;                            
    1562:	08 95       	ret
			case PORT_C:                          
				BIT_WRITE(PORTC,PinNo,PIN_HIGH);
    1564:	81 e0       	ldi	r24, 0x01	; 1
    1566:	90 e0       	ldi	r25, 0x00	; 0
    1568:	02 c0       	rjmp	.+4      	; 0x156e <DIO_EnablePinPullup+0x4e>
    156a:	88 0f       	add	r24, r24
    156c:	99 1f       	adc	r25, r25
    156e:	6a 95       	dec	r22
    1570:	e2 f7       	brpl	.-8      	; 0x156a <DIO_EnablePinPullup+0x4a>
    1572:	95 b3       	in	r25, 0x15	; 21
    1574:	89 2b       	or	r24, r25
    1576:	85 bb       	out	0x15, r24	; 21
				u8_ErrorState=ERROR_OK;
    1578:	80 e0       	ldi	r24, 0x00	; 0
				break;                            
    157a:	08 95       	ret
			case PORT_D:                          
				BIT_WRITE(PORTD,PinNo,PIN_HIGH);
    157c:	81 e0       	ldi	r24, 0x01	; 1
    157e:	90 e0       	ldi	r25, 0x00	; 0
    1580:	02 c0       	rjmp	.+4      	; 0x1586 <DIO_EnablePinPullup+0x66>
    1582:	88 0f       	add	r24, r24
    1584:	99 1f       	adc	r25, r25
    1586:	6a 95       	dec	r22
    1588:	e2 f7       	brpl	.-8      	; 0x1582 <DIO_EnablePinPullup+0x62>
    158a:	92 b3       	in	r25, 0x12	; 18
    158c:	89 2b       	or	r24, r25
    158e:	82 bb       	out	0x12, r24	; 18
				u8_ErrorState=ERROR_OK;
    1590:	80 e0       	ldi	r24, 0x00	; 0
				break;
    1592:	08 95       	ret
ERROR_STATE_t DIO_EnablePinPullup(uint8_t PortName,uint8_t PinNo)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PinNo>PIN7)
	{
		u8_ErrorState=ERROR_NOK;
    1594:	81 e0       	ldi	r24, 0x01	; 1
    1596:	08 95       	ret
			case PORT_D:                          
				BIT_WRITE(PORTD,PinNo,PIN_HIGH);
				u8_ErrorState=ERROR_OK;
				break;
			default:
				u8_ErrorState=ERROR_NOK;
    1598:	81 e0       	ldi	r24, 0x01	; 1
				break;
		}	
	}	
	return u8_ErrorState;
    159a:	08 95       	ret

0000159c <PWM_Init>:
		default:
			u8_ErrorState=ERROR_NOK;
			break;			
	}
	return u8_ErrorState;
}
    159c:	83 30       	cpi	r24, 0x03	; 3
    159e:	69 f5       	brne	.+90     	; 0x15fa <PWM_Init+0x5e>
    15a0:	85 b5       	in	r24, 0x25	; 37
    15a2:	e2 e6       	ldi	r30, 0x62	; 98
    15a4:	f0 e0       	ldi	r31, 0x00	; 0
    15a6:	92 85       	ldd	r25, Z+10	; 0x0a
    15a8:	49 2f       	mov	r20, r25
    15aa:	41 70       	andi	r20, 0x01	; 1
    15ac:	50 e0       	ldi	r21, 0x00	; 0
    15ae:	00 24       	eor	r0, r0
    15b0:	56 95       	lsr	r21
    15b2:	47 95       	ror	r20
    15b4:	07 94       	ror	r0
    15b6:	56 95       	lsr	r21
    15b8:	47 95       	ror	r20
    15ba:	07 94       	ror	r0
    15bc:	54 2f       	mov	r21, r20
    15be:	40 2d       	mov	r20, r0
    15c0:	8f 7b       	andi	r24, 0xBF	; 191
    15c2:	48 2b       	or	r20, r24
    15c4:	91 fb       	bst	r25, 1
    15c6:	22 27       	eor	r18, r18
    15c8:	20 f9       	bld	r18, 0
    15ca:	30 e0       	ldi	r19, 0x00	; 0
    15cc:	22 0f       	add	r18, r18
    15ce:	33 1f       	adc	r19, r19
    15d0:	22 0f       	add	r18, r18
    15d2:	33 1f       	adc	r19, r19
    15d4:	22 0f       	add	r18, r18
    15d6:	33 1f       	adc	r19, r19
    15d8:	47 7f       	andi	r20, 0xF7	; 247
    15da:	24 2b       	or	r18, r20
    15dc:	83 85       	ldd	r24, Z+11	; 0x0b
    15de:	30 e1       	ldi	r19, 0x10	; 16
    15e0:	83 9f       	mul	r24, r19
    15e2:	c0 01       	movw	r24, r0
    15e4:	11 24       	eor	r1, r1
    15e6:	2f 7c       	andi	r18, 0xCF	; 207
    15e8:	28 2b       	or	r18, r24
    15ea:	25 bd       	out	0x25, r18	; 37
    15ec:	41 e0       	ldi	r20, 0x01	; 1
    15ee:	67 e0       	ldi	r22, 0x07	; 7
    15f0:	83 e0       	ldi	r24, 0x03	; 3
    15f2:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <DIO_SetPinDirection>
    15f6:	80 e0       	ldi	r24, 0x00	; 0
    15f8:	08 95       	ret
    15fa:	81 e0       	ldi	r24, 0x01	; 1
    15fc:	08 95       	ret

000015fe <PWM_Start>:
    15fe:	83 30       	cpi	r24, 0x03	; 3
    1600:	41 f4       	brne	.+16     	; 0x1612 <PWM_Start+0x14>
    1602:	85 b5       	in	r24, 0x25	; 37
    1604:	90 91 6b 00 	lds	r25, 0x006B	; 0x80006b <gastr_PWMConfig+0x9>
    1608:	88 7f       	andi	r24, 0xF8	; 248
    160a:	89 2b       	or	r24, r25
    160c:	85 bd       	out	0x25, r24	; 37
    160e:	80 e0       	ldi	r24, 0x00	; 0
    1610:	08 95       	ret
    1612:	81 e0       	ldi	r24, 0x01	; 1
    1614:	08 95       	ret

00001616 <PWM_Connect>:
    1616:	83 30       	cpi	r24, 0x03	; 3
    1618:	69 f4       	brne	.+26     	; 0x1634 <PWM_Connect+0x1e>
    161a:	25 b5       	in	r18, 0x25	; 37
    161c:	90 91 6d 00 	lds	r25, 0x006D	; 0x80006d <gastr_PWMConfig+0xb>
    1620:	30 e1       	ldi	r19, 0x10	; 16
    1622:	93 9f       	mul	r25, r19
    1624:	c0 01       	movw	r24, r0
    1626:	11 24       	eor	r1, r1
    1628:	92 2f       	mov	r25, r18
    162a:	9f 7c       	andi	r25, 0xCF	; 207
    162c:	89 2b       	or	r24, r25
    162e:	85 bd       	out	0x25, r24	; 37
    1630:	80 e0       	ldi	r24, 0x00	; 0
    1632:	08 95       	ret
    1634:	81 e0       	ldi	r24, 0x01	; 1
    1636:	08 95       	ret

00001638 <PWM_SetDuty>:

ERROR_STATE_t PWM_SetDuty(uint8_t PwmChannelNumber,uint8_t PwmDuty )
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PwmDuty==0||PwmDuty>100)
    1638:	9f ef       	ldi	r25, 0xFF	; 255
    163a:	96 0f       	add	r25, r22
    163c:	94 36       	cpi	r25, 0x64	; 100
    163e:	10 f5       	brcc	.+68     	; 0x1684 <PWM_SetDuty+0x4c>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{
		switch(PwmChannelNumber)
    1640:	83 30       	cpi	r24, 0x03	; 3
    1642:	11 f5       	brne	.+68     	; 0x1688 <PWM_SetDuty+0x50>
					break;	
			#endif	
			
			#if OC2
				case PWM_CHANNEL_OC2:
					switch(gastr_PWMConfig[PWM_CHANNEL_OC2].PWMWaveformMode)
    1644:	80 91 6d 00 	lds	r24, 0x006D	; 0x80006d <gastr_PWMConfig+0xb>
    1648:	82 30       	cpi	r24, 0x02	; 2
    164a:	01 f5       	brne	.+64     	; 0x168c <PWM_SetDuty+0x54>
					{
						case NON_INVERTING:
							OCR2 = (uint8_t)(((PwmDuty/100.0)*256.0)-1);
    164c:	70 e0       	ldi	r23, 0x00	; 0
    164e:	80 e0       	ldi	r24, 0x00	; 0
    1650:	90 e0       	ldi	r25, 0x00	; 0
    1652:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <__floatsisf>
    1656:	20 e0       	ldi	r18, 0x00	; 0
    1658:	30 e0       	ldi	r19, 0x00	; 0
    165a:	48 ec       	ldi	r20, 0xC8	; 200
    165c:	52 e4       	ldi	r21, 0x42	; 66
    165e:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <__divsf3>
    1662:	20 e0       	ldi	r18, 0x00	; 0
    1664:	30 e0       	ldi	r19, 0x00	; 0
    1666:	40 e8       	ldi	r20, 0x80	; 128
    1668:	53 e4       	ldi	r21, 0x43	; 67
    166a:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <__mulsf3>
    166e:	20 e0       	ldi	r18, 0x00	; 0
    1670:	30 e0       	ldi	r19, 0x00	; 0
    1672:	40 e8       	ldi	r20, 0x80	; 128
    1674:	5f e3       	ldi	r21, 0x3F	; 63
    1676:	0e 94 c8 0c 	call	0x1990	; 0x1990 <__subsf3>
    167a:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <__fixunssfsi>
    167e:	63 bd       	out	0x23, r22	; 35
							u8_ErrorState=ERROR_OK;
    1680:	80 e0       	ldi	r24, 0x00	; 0
							break;
    1682:	08 95       	ret
ERROR_STATE_t PWM_SetDuty(uint8_t PwmChannelNumber,uint8_t PwmDuty )
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PwmDuty==0||PwmDuty>100)
	{
		u8_ErrorState=ERROR_NOK;
    1684:	81 e0       	ldi	r24, 0x01	; 1
    1686:	08 95       	ret
							break;
					}
					break;
			#endif	
			default:
				u8_ErrorState=ERROR_NOK;
    1688:	81 e0       	ldi	r24, 0x01	; 1
    168a:	08 95       	ret
						case NON_INVERTING:
							OCR2 = (uint8_t)(((PwmDuty/100.0)*256.0)-1);
							u8_ErrorState=ERROR_OK;
							break;
						default:
							u8_ErrorState=ERROR_NOK;
    168c:	81 e0       	ldi	r24, 0x01	; 1
				u8_ErrorState=ERROR_NOK;
				break;			
		}		
	}
	return u8_ErrorState;
    168e:	08 95       	ret

00001690 <HMI_MainFunction>:
* @brief: This function is the HMI main function.
*
* @return function error state.
*/
extern void HMI_MainFunction(void)
{
    1690:	0f 93       	push	r16
    1692:	1f 93       	push	r17
    1694:	cf 93       	push	r28
    1696:	df 93       	push	r29
    1698:	00 d0       	rcall	.+0      	; 0x169a <HMI_MainFunction+0xa>
    169a:	00 d0       	rcall	.+0      	; 0x169c <HMI_MainFunction+0xc>
    169c:	cd b7       	in	r28, 0x3d	; 61
    169e:	de b7       	in	r29, 0x3e	; 62
   ERROR_STATE_t KP_ErrorState;
   static uint8_t u8_Init = 0;
   uint32_t u32_Key;
   static uint32_t u32_OldKey = 0;
   
   if (u8_Init == 0)
    16a0:	80 91 36 07 	lds	r24, 0x0736	; 0x800736 <u8_Init.1752>
    16a4:	81 11       	cpse	r24, r1
    16a6:	09 c0       	rjmp	.+18     	; 0x16ba <HMI_MainFunction+0x2a>
   {
      KP_Init(KP_UsedChannel);
    16a8:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <KP_UsedChannel>
    16ac:	0e 94 48 07 	call	0xe90	; 0xe90 <KP_Init>
      DDRB = 0xF0;
    16b0:	80 ef       	ldi	r24, 0xF0	; 240
    16b2:	87 bb       	out	0x17, r24	; 23
      u8_Init = 1;
    16b4:	81 e0       	ldi	r24, 0x01	; 1
    16b6:	80 93 36 07 	sts	0x0736, r24	; 0x800736 <u8_Init.1752>
   }
   
   KP_ErrorState = KP_GetPressedValue(KP_UsedChannel, &u32_Key);
    16ba:	be 01       	movw	r22, r28
    16bc:	6f 5f       	subi	r22, 0xFF	; 255
    16be:	7f 4f       	sbci	r23, 0xFF	; 255
    16c0:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <KP_UsedChannel>
    16c4:	0e 94 a4 07 	call	0xf48	; 0xf48 <KP_GetPressedValue>
   if(KP_ErrorState == ERROR_OK && u32_OldKey != u32_Key)
    16c8:	81 11       	cpse	r24, r1
    16ca:	55 c0       	rjmp	.+170    	; 0x1776 <HMI_MainFunction+0xe6>
    16cc:	00 91 32 07 	lds	r16, 0x0732	; 0x800732 <u32_OldKey.1754>
    16d0:	10 91 33 07 	lds	r17, 0x0733	; 0x800733 <u32_OldKey.1754+0x1>
    16d4:	20 91 34 07 	lds	r18, 0x0734	; 0x800734 <u32_OldKey.1754+0x2>
    16d8:	30 91 35 07 	lds	r19, 0x0735	; 0x800735 <u32_OldKey.1754+0x3>
    16dc:	69 81       	ldd	r22, Y+1	; 0x01
    16de:	7a 81       	ldd	r23, Y+2	; 0x02
    16e0:	8b 81       	ldd	r24, Y+3	; 0x03
    16e2:	9c 81       	ldd	r25, Y+4	; 0x04
    16e4:	06 17       	cp	r16, r22
    16e6:	17 07       	cpc	r17, r23
    16e8:	28 07       	cpc	r18, r24
    16ea:	39 07       	cpc	r19, r25
    16ec:	09 f4       	brne	.+2      	; 0x16f0 <HMI_MainFunction+0x60>
    16ee:	43 c0       	rjmp	.+134    	; 0x1776 <HMI_MainFunction+0xe6>
   {
      u32_OldKey = u32_Key;
    16f0:	60 93 32 07 	sts	0x0732, r22	; 0x800732 <u32_OldKey.1754>
    16f4:	70 93 33 07 	sts	0x0733, r23	; 0x800733 <u32_OldKey.1754+0x1>
    16f8:	80 93 34 07 	sts	0x0734, r24	; 0x800734 <u32_OldKey.1754+0x2>
    16fc:	90 93 35 07 	sts	0x0735, r25	; 0x800735 <u32_OldKey.1754+0x3>
      if(MULTI_PRESS_BIT & u32_Key)
    1700:	60 ff       	sbrs	r22, 0
    1702:	19 c0       	rjmp	.+50     	; 0x1736 <HMI_MainFunction+0xa6>
      {
         if(DEVICE_ERASE_VALUE == u32_Key)
    1704:	63 34       	cpi	r22, 0x43	; 67
    1706:	20 e1       	ldi	r18, 0x10	; 16
    1708:	72 07       	cpc	r23, r18
    170a:	81 05       	cpc	r24, r1
    170c:	91 05       	cpc	r25, r1
    170e:	29 f4       	brne	.+10     	; 0x171a <HMI_MainFunction+0x8a>
         {
            HMI_SetDeviceEraseFlag();
    1710:	0e 94 c4 0b 	call	0x1788	; 0x1788 <HMI_SetDeviceEraseFlag>
            PORTB = (13<<4);
    1714:	80 ed       	ldi	r24, 0xD0	; 208
    1716:	88 bb       	out	0x18, r24	; 24
    1718:	2e c0       	rjmp	.+92     	; 0x1776 <HMI_MainFunction+0xe6>
         }
         else if(PASSWORD_CHANGE_VALUE == u32_Key)
    171a:	63 34       	cpi	r22, 0x43	; 67
    171c:	74 40       	sbci	r23, 0x04	; 4
    171e:	81 05       	cpc	r24, r1
    1720:	91 05       	cpc	r25, r1
    1722:	29 f4       	brne	.+10     	; 0x172e <HMI_MainFunction+0x9e>
         {
            HMI_SetPasswordChangeFlag();
    1724:	0e 94 c9 0b 	call	0x1792	; 0x1792 <HMI_SetPasswordChangeFlag>
            PORTB = (14<<4);
    1728:	80 ee       	ldi	r24, 0xE0	; 224
    172a:	88 bb       	out	0x18, r24	; 24
    172c:	24 c0       	rjmp	.+72     	; 0x1776 <HMI_MainFunction+0xe6>
         }
         else
         {
            PORTB &= ~(0xF0);
    172e:	88 b3       	in	r24, 0x18	; 24
    1730:	8f 70       	andi	r24, 0x0F	; 15
    1732:	88 bb       	out	0x18, r24	; 24
    1734:	20 c0       	rjmp	.+64     	; 0x1776 <HMI_MainFunction+0xe6>
         }
      }
      else if(u32_Key != 0)
    1736:	61 15       	cp	r22, r1
    1738:	71 05       	cpc	r23, r1
    173a:	81 05       	cpc	r24, r1
    173c:	91 05       	cpc	r25, r1
    173e:	c1 f0       	breq	.+48     	; 0x1770 <HMI_MainFunction+0xe0>
      {
         u32_Key = (log(u32_Key)/log(2));
    1740:	0e 94 d6 0d 	call	0x1bac	; 0x1bac <__floatunsisf>
    1744:	0e 94 6c 0e 	call	0x1cd8	; 0x1cd8 <log>
    1748:	28 e1       	ldi	r18, 0x18	; 24
    174a:	32 e7       	ldi	r19, 0x72	; 114
    174c:	41 e3       	ldi	r20, 0x31	; 49
    174e:	5f e3       	ldi	r21, 0x3F	; 63
    1750:	0e 94 35 0d 	call	0x1a6a	; 0x1a6a <__divsf3>
    1754:	0e 94 a7 0d 	call	0x1b4e	; 0x1b4e <__fixunssfsi>
    1758:	69 83       	std	Y+1, r22	; 0x01
    175a:	7a 83       	std	Y+2, r23	; 0x02
    175c:	8b 83       	std	Y+3, r24	; 0x03
    175e:	9c 83       	std	Y+4, r25	; 0x04
         HMI_SetKeyPressed(u32_Key);
    1760:	86 2f       	mov	r24, r22
    1762:	0e 94 ce 0b 	call	0x179c	; 0x179c <HMI_SetKeyPressed>
         PORTB = (u32_Key<<4);
    1766:	89 81       	ldd	r24, Y+1	; 0x01
    1768:	82 95       	swap	r24
    176a:	80 7f       	andi	r24, 0xF0	; 240
    176c:	88 bb       	out	0x18, r24	; 24
    176e:	03 c0       	rjmp	.+6      	; 0x1776 <HMI_MainFunction+0xe6>
      }
      else
      {
         PORTB &= ~(0xF0);
    1770:	88 b3       	in	r24, 0x18	; 24
    1772:	8f 70       	andi	r24, 0x0F	; 15
    1774:	88 bb       	out	0x18, r24	; 24
      }
   }
    1776:	0f 90       	pop	r0
    1778:	0f 90       	pop	r0
    177a:	0f 90       	pop	r0
    177c:	0f 90       	pop	r0
    177e:	df 91       	pop	r29
    1780:	cf 91       	pop	r28
    1782:	1f 91       	pop	r17
    1784:	0f 91       	pop	r16
    1786:	08 95       	ret

00001788 <HMI_SetDeviceEraseFlag>:
*
* @return function error state.
*/
extern ERROR_STATE_t HMI_SetDeviceEraseFlag(void)
{
   gu8_DeviceEraseFlag = DEVICE_ERASE_FLAG;
    1788:	81 e0       	ldi	r24, 0x01	; 1
    178a:	80 93 39 07 	sts	0x0739, r24	; 0x800739 <gu8_DeviceEraseFlag>
   return ERROR_OK;
}
    178e:	80 e0       	ldi	r24, 0x00	; 0
    1790:	08 95       	ret

00001792 <HMI_SetPasswordChangeFlag>:
*
* @return function error state.
*/
extern ERROR_STATE_t HMI_SetPasswordChangeFlag(void)
{
   gu8_PasswordChangeFlag = PASSWORD_CHANGE_FLAG;
    1792:	81 e0       	ldi	r24, 0x01	; 1
    1794:	80 93 38 07 	sts	0x0738, r24	; 0x800738 <gu8_PasswordChangeFlag>
   return ERROR_OK;
}
    1798:	80 e0       	ldi	r24, 0x00	; 0
    179a:	08 95       	ret

0000179c <HMI_SetKeyPressed>:
*/
extern ERROR_STATE_t HMI_SetKeyPressed(uint8_t Value)
{
   ERROR_STATE_t HMI_ErrorState;
   
   if(INVALID_KEY_PRESSED_VALUE <= Value)
    179c:	8d 30       	cpi	r24, 0x0D	; 13
    179e:	20 f4       	brcc	.+8      	; 0x17a8 <HMI_SetKeyPressed+0xc>
   {
      HMI_ErrorState = (E_HMI_ID | E_HMI_INVALID_VAL);
   }
   else
   {
      gu8_KeyPressedValue = Value;
    17a0:	80 93 37 07 	sts	0x0737, r24	; 0x800737 <gu8_KeyPressedValue>
      HMI_ErrorState = ERROR_OK;
    17a4:	80 e0       	ldi	r24, 0x00	; 0
    17a6:	08 95       	ret
{
   ERROR_STATE_t HMI_ErrorState;
   
   if(INVALID_KEY_PRESSED_VALUE <= Value)
   {
      HMI_ErrorState = (E_HMI_ID | E_HMI_INVALID_VAL);
    17a8:	82 ed       	ldi	r24, 0xD2	; 210
      gu8_KeyPressedValue = Value;
      HMI_ErrorState = ERROR_OK;
   }
   
   return HMI_ErrorState;
    17aa:	08 95       	ret

000017ac <Indicator_MainFunction>:
* @brief: This function is the indicator main function.
*
* @return function error state.
*/
extern void Indicator_MainFunction(void)
{
    17ac:	cf 93       	push	r28
    17ae:	df 93       	push	r29
    17b0:	00 d0       	rcall	.+0      	; 0x17b2 <Indicator_MainFunction+0x6>
    17b2:	1f 92       	push	r1
    17b4:	cd b7       	in	r28, 0x3d	; 61
    17b6:	de b7       	in	r29, 0x3e	; 62
   portTickType xLastWakeTime;
   xLastWakeTime=xTaskGetTickCount();
    17b8:	0e 94 7d 05 	call	0xafa	; 0xafa <xTaskGetTickCount>
    17bc:	9a 83       	std	Y+2, r25	; 0x02
    17be:	89 83       	std	Y+1, r24	; 0x01
   uint8_t u8_Pattern;
   static uint8_t u8_OldPattern = INDICATOR_INVALID_PATTERN;
   static Enu_IndicatorStateMachine State = Indicator_LowTime;
   static uint8_t u8_Duty = 0;
   
   if (u8_Init == 0)
    17c0:	80 91 3c 07 	lds	r24, 0x073C	; 0x80073c <u8_Init.1970>
    17c4:	81 11       	cpse	r24, r1
    17c6:	09 c0       	rjmp	.+18     	; 0x17da <Indicator_MainFunction+0x2e>
   {
      Indicator_SetPattern(INDICATOR_MALFUNCTION_PATTERN);
    17c8:	0e 94 91 0c 	call	0x1922	; 0x1922 <Indicator_SetPattern>
      LED_Init(LED_UsedChannel);
    17cc:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <LED_UsedChannel>
    17d0:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <LED_Init>
      u8_Init = 1;
    17d4:	81 e0       	ldi	r24, 0x01	; 1
    17d6:	80 93 3c 07 	sts	0x073C, r24	; 0x80073c <u8_Init.1970>
   }
   
   Indicator_GetPattern(&u8_Pattern);
    17da:	ce 01       	movw	r24, r28
    17dc:	03 96       	adiw	r24, 0x03	; 3
    17de:	0e 94 87 0c 	call	0x190e	; 0x190e <Indicator_GetPattern>
   
   if( u8_Pattern != u8_OldPattern)
    17e2:	eb 81       	ldd	r30, Y+3	; 0x03
    17e4:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    17e8:	e8 17       	cp	r30, r24
    17ea:	31 f0       	breq	.+12     	; 0x17f8 <Indicator_MainFunction+0x4c>
   {
      u8_OldPattern = u8_Pattern;
    17ec:	e0 93 60 00 	sts	0x0060, r30	; 0x800060 <__DATA_REGION_ORIGIN__>
      State = Indicator_LowTime;
    17f0:	10 92 3b 07 	sts	0x073B, r1	; 0x80073b <State.1973>
      u8_Duty = 0;
    17f4:	10 92 3a 07 	sts	0x073A, r1	; 0x80073a <u8_Duty.1974>
   }
   
   if(INDICATOR_INVALID_PATTERN != u8_Pattern)
    17f8:	e4 30       	cpi	r30, 0x04	; 4
    17fa:	09 f4       	brne	.+2      	; 0x17fe <Indicator_MainFunction+0x52>
    17fc:	82 c0       	rjmp	.+260    	; 0x1902 <Indicator_MainFunction+0x156>
   {
      switch(State)
    17fe:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <State.1973>
    1802:	81 30       	cpi	r24, 0x01	; 1
    1804:	f9 f0       	breq	.+62     	; 0x1844 <Indicator_MainFunction+0x98>
    1806:	38 f0       	brcs	.+14     	; 0x1816 <Indicator_MainFunction+0x6a>
    1808:	82 30       	cpi	r24, 0x02	; 2
    180a:	09 f4       	brne	.+2      	; 0x180e <Indicator_MainFunction+0x62>
    180c:	40 c0       	rjmp	.+128    	; 0x188e <Indicator_MainFunction+0xe2>
    180e:	83 30       	cpi	r24, 0x03	; 3
    1810:	09 f4       	brne	.+2      	; 0x1814 <Indicator_MainFunction+0x68>
    1812:	54 c0       	rjmp	.+168    	; 0x18bc <Indicator_MainFunction+0x110>
    1814:	76 c0       	rjmp	.+236    	; 0x1902 <Indicator_MainFunction+0x156>
      {
         case Indicator_LowTime:
            LED_Off(LED_UsedChannel);
    1816:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <LED_UsedChannel>
    181a:	0e 94 d2 08 	call	0x11a4	; 0x11a4 <LED_Off>
            State = Indicator_RiseTime;
    181e:	81 e0       	ldi	r24, 0x01	; 1
    1820:	80 93 3b 07 	sts	0x073B, r24	; 0x80073b <State.1973>
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u32_LowTime);
    1824:	eb 81       	ldd	r30, Y+3	; 0x03
    1826:	86 e1       	ldi	r24, 0x16	; 22
    1828:	e8 9f       	mul	r30, r24
    182a:	f0 01       	movw	r30, r0
    182c:	11 24       	eor	r1, r1
    182e:	ec 58       	subi	r30, 0x8C	; 140
    1830:	ff 4f       	sbci	r31, 0xFF	; 255
    1832:	60 89       	ldd	r22, Z+16	; 0x10
    1834:	71 89       	ldd	r23, Z+17	; 0x11
    1836:	82 89       	ldd	r24, Z+18	; 0x12
    1838:	93 89       	ldd	r25, Z+19	; 0x13
    183a:	ce 01       	movw	r24, r28
    183c:	01 96       	adiw	r24, 0x01	; 1
    183e:	0e 94 b3 06 	call	0xd66	; 0xd66 <vTaskDelayUntil>
            break;
    1842:	5f c0       	rjmp	.+190    	; 0x1902 <Indicator_MainFunction+0x156>
         case Indicator_RiseTime:
            u8_Duty += aSTR_IndicatorConfig[u8_Pattern].u8_RateOfChange;
    1844:	86 e1       	ldi	r24, 0x16	; 22
    1846:	e8 9f       	mul	r30, r24
    1848:	f0 01       	movw	r30, r0
    184a:	11 24       	eor	r1, r1
    184c:	ec 58       	subi	r30, 0x8C	; 140
    184e:	ff 4f       	sbci	r31, 0xFF	; 255
    1850:	65 89       	ldd	r22, Z+21	; 0x15
    1852:	80 91 3a 07 	lds	r24, 0x073A	; 0x80073a <u8_Duty.1974>
    1856:	68 0f       	add	r22, r24
    1858:	60 93 3a 07 	sts	0x073A, r22	; 0x80073a <u8_Duty.1974>
            LED_Dim(LED_UsedChannel, u8_Duty);
    185c:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <LED_UsedChannel>
    1860:	0e 94 4e 09 	call	0x129c	; 0x129c <LED_Dim>
            if(u8_Duty == 100)
    1864:	80 91 3a 07 	lds	r24, 0x073A	; 0x80073a <u8_Duty.1974>
    1868:	84 36       	cpi	r24, 0x64	; 100
    186a:	19 f4       	brne	.+6      	; 0x1872 <Indicator_MainFunction+0xc6>
            {
               State = Indicator_HighTime;
    186c:	82 e0       	ldi	r24, 0x02	; 2
    186e:	80 93 3b 07 	sts	0x073B, r24	; 0x80073b <State.1973>
            }
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u8_StepTime);
    1872:	eb 81       	ldd	r30, Y+3	; 0x03
    1874:	86 e1       	ldi	r24, 0x16	; 22
    1876:	e8 9f       	mul	r30, r24
    1878:	f0 01       	movw	r30, r0
    187a:	11 24       	eor	r1, r1
    187c:	ec 58       	subi	r30, 0x8C	; 140
    187e:	ff 4f       	sbci	r31, 0xFF	; 255
    1880:	64 89       	ldd	r22, Z+20	; 0x14
    1882:	70 e0       	ldi	r23, 0x00	; 0
    1884:	ce 01       	movw	r24, r28
    1886:	01 96       	adiw	r24, 0x01	; 1
    1888:	0e 94 b3 06 	call	0xd66	; 0xd66 <vTaskDelayUntil>
            break;
    188c:	3a c0       	rjmp	.+116    	; 0x1902 <Indicator_MainFunction+0x156>
         case Indicator_HighTime:
            LED_On(LED_UsedChannel);
    188e:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <LED_UsedChannel>
    1892:	0e 94 10 09 	call	0x1220	; 0x1220 <LED_On>
            State = Indicator_FallTime;
    1896:	83 e0       	ldi	r24, 0x03	; 3
    1898:	80 93 3b 07 	sts	0x073B, r24	; 0x80073b <State.1973>
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u32_HighTime);
    189c:	eb 81       	ldd	r30, Y+3	; 0x03
    189e:	86 e1       	ldi	r24, 0x16	; 22
    18a0:	e8 9f       	mul	r30, r24
    18a2:	f0 01       	movw	r30, r0
    18a4:	11 24       	eor	r1, r1
    18a6:	ec 58       	subi	r30, 0x8C	; 140
    18a8:	ff 4f       	sbci	r31, 0xFF	; 255
    18aa:	64 81       	ldd	r22, Z+4	; 0x04
    18ac:	75 81       	ldd	r23, Z+5	; 0x05
    18ae:	86 81       	ldd	r24, Z+6	; 0x06
    18b0:	97 81       	ldd	r25, Z+7	; 0x07
    18b2:	ce 01       	movw	r24, r28
    18b4:	01 96       	adiw	r24, 0x01	; 1
    18b6:	0e 94 b3 06 	call	0xd66	; 0xd66 <vTaskDelayUntil>
            break;
    18ba:	23 c0       	rjmp	.+70     	; 0x1902 <Indicator_MainFunction+0x156>
         case Indicator_FallTime:
            u8_Duty -= aSTR_IndicatorConfig[u8_Pattern].u8_RateOfChange;
    18bc:	86 e1       	ldi	r24, 0x16	; 22
    18be:	e8 9f       	mul	r30, r24
    18c0:	f0 01       	movw	r30, r0
    18c2:	11 24       	eor	r1, r1
    18c4:	ec 58       	subi	r30, 0x8C	; 140
    18c6:	ff 4f       	sbci	r31, 0xFF	; 255
    18c8:	85 89       	ldd	r24, Z+21	; 0x15
    18ca:	60 91 3a 07 	lds	r22, 0x073A	; 0x80073a <u8_Duty.1974>
    18ce:	68 1b       	sub	r22, r24
    18d0:	60 93 3a 07 	sts	0x073A, r22	; 0x80073a <u8_Duty.1974>
            LED_Dim(LED_UsedChannel, u8_Duty);
    18d4:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <LED_UsedChannel>
    18d8:	0e 94 4e 09 	call	0x129c	; 0x129c <LED_Dim>
            if(u8_Duty == 0)
    18dc:	80 91 3a 07 	lds	r24, 0x073A	; 0x80073a <u8_Duty.1974>
    18e0:	81 11       	cpse	r24, r1
    18e2:	02 c0       	rjmp	.+4      	; 0x18e8 <Indicator_MainFunction+0x13c>
            {
               State = Indicator_LowTime;
    18e4:	10 92 3b 07 	sts	0x073B, r1	; 0x80073b <State.1973>
            }
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u8_StepTime);
    18e8:	eb 81       	ldd	r30, Y+3	; 0x03
    18ea:	86 e1       	ldi	r24, 0x16	; 22
    18ec:	e8 9f       	mul	r30, r24
    18ee:	f0 01       	movw	r30, r0
    18f0:	11 24       	eor	r1, r1
    18f2:	ec 58       	subi	r30, 0x8C	; 140
    18f4:	ff 4f       	sbci	r31, 0xFF	; 255
    18f6:	64 89       	ldd	r22, Z+20	; 0x14
    18f8:	70 e0       	ldi	r23, 0x00	; 0
    18fa:	ce 01       	movw	r24, r28
    18fc:	01 96       	adiw	r24, 0x01	; 1
    18fe:	0e 94 b3 06 	call	0xd66	; 0xd66 <vTaskDelayUntil>
            break;
      }
   }
    1902:	0f 90       	pop	r0
    1904:	0f 90       	pop	r0
    1906:	0f 90       	pop	r0
    1908:	df 91       	pop	r29
    190a:	cf 91       	pop	r28
    190c:	08 95       	ret

0000190e <Indicator_GetPattern>:
*/
extern ERROR_STATE_t Indicator_GetPattern(uint8_t * Value)
{
   ERROR_STATE_t Indicator_ErrorState;
   
   if(NULL_PTR == Value)
    190e:	00 97       	sbiw	r24, 0x00	; 0
    1910:	31 f0       	breq	.+12     	; 0x191e <Indicator_GetPattern+0x10>
   {
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_NULL_PTR);
   }
   else
   {
      *Value = gu8_IndicatorPattern;
    1912:	20 91 61 00 	lds	r18, 0x0061	; 0x800061 <gu8_IndicatorPattern>
    1916:	fc 01       	movw	r30, r24
    1918:	20 83       	st	Z, r18
      Indicator_ErrorState = ERROR_OK;
    191a:	80 e0       	ldi	r24, 0x00	; 0
    191c:	08 95       	ret
{
   ERROR_STATE_t Indicator_ErrorState;
   
   if(NULL_PTR == Value)
   {
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_NULL_PTR);
    191e:	82 eb       	ldi	r24, 0xB2	; 178
      *Value = gu8_IndicatorPattern;
      Indicator_ErrorState = ERROR_OK;
   }
   
   return Indicator_ErrorState;
}
    1920:	08 95       	ret

00001922 <Indicator_SetPattern>:
*/
extern ERROR_STATE_t Indicator_SetPattern(int8_t Value)
{
   ERROR_STATE_t Indicator_ErrorState;
   
   if(INDICATOR_INVALID_PATTERN <= Value)
    1922:	84 30       	cpi	r24, 0x04	; 4
    1924:	24 f4       	brge	.+8      	; 0x192e <Indicator_SetPattern+0xc>
   {
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_INVALID_VAL);
   }
   else
   {
      gu8_IndicatorPattern = Value;
    1926:	80 93 61 00 	sts	0x0061, r24	; 0x800061 <gu8_IndicatorPattern>
      Indicator_ErrorState = ERROR_OK;
    192a:	80 e0       	ldi	r24, 0x00	; 0
    192c:	08 95       	ret
{
   ERROR_STATE_t Indicator_ErrorState;
   
   if(INDICATOR_INVALID_PATTERN <= Value)
   {
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_INVALID_VAL);
    192e:	81 eb       	ldi	r24, 0xB1	; 177
      gu8_IndicatorPattern = Value;
      Indicator_ErrorState = ERROR_OK;
   }
   
   return Indicator_ErrorState;
    1930:	08 95       	ret

00001932 <HMI_Task>:
#include "Indicator.h"
#include "FreeRTOS.h"
#include "task.h"

void HMI_Task( void *pvParameters )
{
    1932:	cf 93       	push	r28
    1934:	df 93       	push	r29
    1936:	00 d0       	rcall	.+0      	; 0x1938 <HMI_Task+0x6>
    1938:	cd b7       	in	r28, 0x3d	; 61
    193a:	de b7       	in	r29, 0x3e	; 62
   portTickType xLastWakeTime;
   xLastWakeTime=xTaskGetTickCount();
    193c:	0e 94 7d 05 	call	0xafa	; 0xafa <xTaskGetTickCount>
    1940:	9a 83       	std	Y+2, r25	; 0x02
    1942:	89 83       	std	Y+1, r24	; 0x01
   
   for( ;; )
   {
      HMI_MainFunction();
    1944:	0e 94 48 0b 	call	0x1690	; 0x1690 <HMI_MainFunction>
      vTaskDelayUntil(&xLastWakeTime, 50);
    1948:	62 e3       	ldi	r22, 0x32	; 50
    194a:	70 e0       	ldi	r23, 0x00	; 0
    194c:	ce 01       	movw	r24, r28
    194e:	01 96       	adiw	r24, 0x01	; 1
    1950:	0e 94 b3 06 	call	0xd66	; 0xd66 <vTaskDelayUntil>
    1954:	f7 cf       	rjmp	.-18     	; 0x1944 <HMI_Task+0x12>

00001956 <Feedback_Task>:

void Feedback_Task( void *pvParameters )
{  
   for( ;; )
   {
      Indicator_MainFunction();
    1956:	0e 94 d6 0b 	call	0x17ac	; 0x17ac <Indicator_MainFunction>
    195a:	fd cf       	rjmp	.-6      	; 0x1956 <Feedback_Task>

0000195c <main>:
   }
}

int main(void)
{   
   xTaskCreate( HMI_Task, ( signed char * ) "HMI", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );
    195c:	e1 2c       	mov	r14, r1
    195e:	f1 2c       	mov	r15, r1
    1960:	01 e0       	ldi	r16, 0x01	; 1
    1962:	20 e0       	ldi	r18, 0x00	; 0
    1964:	30 e0       	ldi	r19, 0x00	; 0
    1966:	45 e5       	ldi	r20, 0x55	; 85
    1968:	50 e0       	ldi	r21, 0x00	; 0
    196a:	63 ee       	ldi	r22, 0xE3	; 227
    196c:	70 e0       	ldi	r23, 0x00	; 0
    196e:	89 e9       	ldi	r24, 0x99	; 153
    1970:	9c e0       	ldi	r25, 0x0C	; 12
    1972:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskCreate>
   xTaskCreate( Feedback_Task, ( signed char * ) "Indicator", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );
    1976:	20 e0       	ldi	r18, 0x00	; 0
    1978:	30 e0       	ldi	r19, 0x00	; 0
    197a:	45 e5       	ldi	r20, 0x55	; 85
    197c:	50 e0       	ldi	r21, 0x00	; 0
    197e:	67 ee       	ldi	r22, 0xE7	; 231
    1980:	70 e0       	ldi	r23, 0x00	; 0
    1982:	8b ea       	ldi	r24, 0xAB	; 171
    1984:	9c e0       	ldi	r25, 0x0C	; 12
    1986:	0e 94 f9 04 	call	0x9f2	; 0x9f2 <xTaskCreate>
   
   vTaskStartScheduler();
    198a:	0e 94 4d 05 	call	0xa9a	; 0xa9a <vTaskStartScheduler>
    198e:	ff cf       	rjmp	.-2      	; 0x198e <main+0x32>

00001990 <__subsf3>:
    1990:	50 58       	subi	r21, 0x80	; 128

00001992 <__addsf3>:
    1992:	bb 27       	eor	r27, r27
    1994:	aa 27       	eor	r26, r26
    1996:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <__addsf3x>
    199a:	0c 94 2a 0e 	jmp	0x1c54	; 0x1c54 <__fp_round>
    199e:	0e 94 1c 0e 	call	0x1c38	; 0x1c38 <__fp_pscA>
    19a2:	38 f0       	brcs	.+14     	; 0x19b2 <__addsf3+0x20>
    19a4:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <__fp_pscB>
    19a8:	20 f0       	brcs	.+8      	; 0x19b2 <__addsf3+0x20>
    19aa:	39 f4       	brne	.+14     	; 0x19ba <__addsf3+0x28>
    19ac:	9f 3f       	cpi	r25, 0xFF	; 255
    19ae:	19 f4       	brne	.+6      	; 0x19b6 <__addsf3+0x24>
    19b0:	26 f4       	brtc	.+8      	; 0x19ba <__addsf3+0x28>
    19b2:	0c 94 19 0e 	jmp	0x1c32	; 0x1c32 <__fp_nan>
    19b6:	0e f4       	brtc	.+2      	; 0x19ba <__addsf3+0x28>
    19b8:	e0 95       	com	r30
    19ba:	e7 fb       	bst	r30, 7
    19bc:	0c 94 13 0e 	jmp	0x1c26	; 0x1c26 <__fp_inf>

000019c0 <__addsf3x>:
    19c0:	e9 2f       	mov	r30, r25
    19c2:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <__fp_split3>
    19c6:	58 f3       	brcs	.-42     	; 0x199e <__addsf3+0xc>
    19c8:	ba 17       	cp	r27, r26
    19ca:	62 07       	cpc	r22, r18
    19cc:	73 07       	cpc	r23, r19
    19ce:	84 07       	cpc	r24, r20
    19d0:	95 07       	cpc	r25, r21
    19d2:	20 f0       	brcs	.+8      	; 0x19dc <__addsf3x+0x1c>
    19d4:	79 f4       	brne	.+30     	; 0x19f4 <__addsf3x+0x34>
    19d6:	a6 f5       	brtc	.+104    	; 0x1a40 <__addsf3x+0x80>
    19d8:	0c 94 5d 0e 	jmp	0x1cba	; 0x1cba <__fp_zero>
    19dc:	0e f4       	brtc	.+2      	; 0x19e0 <__addsf3x+0x20>
    19de:	e0 95       	com	r30
    19e0:	0b 2e       	mov	r0, r27
    19e2:	ba 2f       	mov	r27, r26
    19e4:	a0 2d       	mov	r26, r0
    19e6:	0b 01       	movw	r0, r22
    19e8:	b9 01       	movw	r22, r18
    19ea:	90 01       	movw	r18, r0
    19ec:	0c 01       	movw	r0, r24
    19ee:	ca 01       	movw	r24, r20
    19f0:	a0 01       	movw	r20, r0
    19f2:	11 24       	eor	r1, r1
    19f4:	ff 27       	eor	r31, r31
    19f6:	59 1b       	sub	r21, r25
    19f8:	99 f0       	breq	.+38     	; 0x1a20 <__addsf3x+0x60>
    19fa:	59 3f       	cpi	r21, 0xF9	; 249
    19fc:	50 f4       	brcc	.+20     	; 0x1a12 <__addsf3x+0x52>
    19fe:	50 3e       	cpi	r21, 0xE0	; 224
    1a00:	68 f1       	brcs	.+90     	; 0x1a5c <__addsf3x+0x9c>
    1a02:	1a 16       	cp	r1, r26
    1a04:	f0 40       	sbci	r31, 0x00	; 0
    1a06:	a2 2f       	mov	r26, r18
    1a08:	23 2f       	mov	r18, r19
    1a0a:	34 2f       	mov	r19, r20
    1a0c:	44 27       	eor	r20, r20
    1a0e:	58 5f       	subi	r21, 0xF8	; 248
    1a10:	f3 cf       	rjmp	.-26     	; 0x19f8 <__addsf3x+0x38>
    1a12:	46 95       	lsr	r20
    1a14:	37 95       	ror	r19
    1a16:	27 95       	ror	r18
    1a18:	a7 95       	ror	r26
    1a1a:	f0 40       	sbci	r31, 0x00	; 0
    1a1c:	53 95       	inc	r21
    1a1e:	c9 f7       	brne	.-14     	; 0x1a12 <__addsf3x+0x52>
    1a20:	7e f4       	brtc	.+30     	; 0x1a40 <__addsf3x+0x80>
    1a22:	1f 16       	cp	r1, r31
    1a24:	ba 0b       	sbc	r27, r26
    1a26:	62 0b       	sbc	r22, r18
    1a28:	73 0b       	sbc	r23, r19
    1a2a:	84 0b       	sbc	r24, r20
    1a2c:	ba f0       	brmi	.+46     	; 0x1a5c <__addsf3x+0x9c>
    1a2e:	91 50       	subi	r25, 0x01	; 1
    1a30:	a1 f0       	breq	.+40     	; 0x1a5a <__addsf3x+0x9a>
    1a32:	ff 0f       	add	r31, r31
    1a34:	bb 1f       	adc	r27, r27
    1a36:	66 1f       	adc	r22, r22
    1a38:	77 1f       	adc	r23, r23
    1a3a:	88 1f       	adc	r24, r24
    1a3c:	c2 f7       	brpl	.-16     	; 0x1a2e <__addsf3x+0x6e>
    1a3e:	0e c0       	rjmp	.+28     	; 0x1a5c <__addsf3x+0x9c>
    1a40:	ba 0f       	add	r27, r26
    1a42:	62 1f       	adc	r22, r18
    1a44:	73 1f       	adc	r23, r19
    1a46:	84 1f       	adc	r24, r20
    1a48:	48 f4       	brcc	.+18     	; 0x1a5c <__addsf3x+0x9c>
    1a4a:	87 95       	ror	r24
    1a4c:	77 95       	ror	r23
    1a4e:	67 95       	ror	r22
    1a50:	b7 95       	ror	r27
    1a52:	f7 95       	ror	r31
    1a54:	9e 3f       	cpi	r25, 0xFE	; 254
    1a56:	08 f0       	brcs	.+2      	; 0x1a5a <__addsf3x+0x9a>
    1a58:	b0 cf       	rjmp	.-160    	; 0x19ba <__addsf3+0x28>
    1a5a:	93 95       	inc	r25
    1a5c:	88 0f       	add	r24, r24
    1a5e:	08 f0       	brcs	.+2      	; 0x1a62 <__addsf3x+0xa2>
    1a60:	99 27       	eor	r25, r25
    1a62:	ee 0f       	add	r30, r30
    1a64:	97 95       	ror	r25
    1a66:	87 95       	ror	r24
    1a68:	08 95       	ret

00001a6a <__divsf3>:
    1a6a:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <__divsf3x>
    1a6e:	0c 94 2a 0e 	jmp	0x1c54	; 0x1c54 <__fp_round>
    1a72:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <__fp_pscB>
    1a76:	58 f0       	brcs	.+22     	; 0x1a8e <__divsf3+0x24>
    1a78:	0e 94 1c 0e 	call	0x1c38	; 0x1c38 <__fp_pscA>
    1a7c:	40 f0       	brcs	.+16     	; 0x1a8e <__divsf3+0x24>
    1a7e:	29 f4       	brne	.+10     	; 0x1a8a <__divsf3+0x20>
    1a80:	5f 3f       	cpi	r21, 0xFF	; 255
    1a82:	29 f0       	breq	.+10     	; 0x1a8e <__divsf3+0x24>
    1a84:	0c 94 13 0e 	jmp	0x1c26	; 0x1c26 <__fp_inf>
    1a88:	51 11       	cpse	r21, r1
    1a8a:	0c 94 5e 0e 	jmp	0x1cbc	; 0x1cbc <__fp_szero>
    1a8e:	0c 94 19 0e 	jmp	0x1c32	; 0x1c32 <__fp_nan>

00001a92 <__divsf3x>:
    1a92:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <__fp_split3>
    1a96:	68 f3       	brcs	.-38     	; 0x1a72 <__divsf3+0x8>

00001a98 <__divsf3_pse>:
    1a98:	99 23       	and	r25, r25
    1a9a:	b1 f3       	breq	.-20     	; 0x1a88 <__divsf3+0x1e>
    1a9c:	55 23       	and	r21, r21
    1a9e:	91 f3       	breq	.-28     	; 0x1a84 <__divsf3+0x1a>
    1aa0:	95 1b       	sub	r25, r21
    1aa2:	55 0b       	sbc	r21, r21
    1aa4:	bb 27       	eor	r27, r27
    1aa6:	aa 27       	eor	r26, r26
    1aa8:	62 17       	cp	r22, r18
    1aaa:	73 07       	cpc	r23, r19
    1aac:	84 07       	cpc	r24, r20
    1aae:	38 f0       	brcs	.+14     	; 0x1abe <__divsf3_pse+0x26>
    1ab0:	9f 5f       	subi	r25, 0xFF	; 255
    1ab2:	5f 4f       	sbci	r21, 0xFF	; 255
    1ab4:	22 0f       	add	r18, r18
    1ab6:	33 1f       	adc	r19, r19
    1ab8:	44 1f       	adc	r20, r20
    1aba:	aa 1f       	adc	r26, r26
    1abc:	a9 f3       	breq	.-22     	; 0x1aa8 <__divsf3_pse+0x10>
    1abe:	35 d0       	rcall	.+106    	; 0x1b2a <__divsf3_pse+0x92>
    1ac0:	0e 2e       	mov	r0, r30
    1ac2:	3a f0       	brmi	.+14     	; 0x1ad2 <__divsf3_pse+0x3a>
    1ac4:	e0 e8       	ldi	r30, 0x80	; 128
    1ac6:	32 d0       	rcall	.+100    	; 0x1b2c <__divsf3_pse+0x94>
    1ac8:	91 50       	subi	r25, 0x01	; 1
    1aca:	50 40       	sbci	r21, 0x00	; 0
    1acc:	e6 95       	lsr	r30
    1ace:	00 1c       	adc	r0, r0
    1ad0:	ca f7       	brpl	.-14     	; 0x1ac4 <__divsf3_pse+0x2c>
    1ad2:	2b d0       	rcall	.+86     	; 0x1b2a <__divsf3_pse+0x92>
    1ad4:	fe 2f       	mov	r31, r30
    1ad6:	29 d0       	rcall	.+82     	; 0x1b2a <__divsf3_pse+0x92>
    1ad8:	66 0f       	add	r22, r22
    1ada:	77 1f       	adc	r23, r23
    1adc:	88 1f       	adc	r24, r24
    1ade:	bb 1f       	adc	r27, r27
    1ae0:	26 17       	cp	r18, r22
    1ae2:	37 07       	cpc	r19, r23
    1ae4:	48 07       	cpc	r20, r24
    1ae6:	ab 07       	cpc	r26, r27
    1ae8:	b0 e8       	ldi	r27, 0x80	; 128
    1aea:	09 f0       	breq	.+2      	; 0x1aee <__divsf3_pse+0x56>
    1aec:	bb 0b       	sbc	r27, r27
    1aee:	80 2d       	mov	r24, r0
    1af0:	bf 01       	movw	r22, r30
    1af2:	ff 27       	eor	r31, r31
    1af4:	93 58       	subi	r25, 0x83	; 131
    1af6:	5f 4f       	sbci	r21, 0xFF	; 255
    1af8:	3a f0       	brmi	.+14     	; 0x1b08 <__divsf3_pse+0x70>
    1afa:	9e 3f       	cpi	r25, 0xFE	; 254
    1afc:	51 05       	cpc	r21, r1
    1afe:	78 f0       	brcs	.+30     	; 0x1b1e <__divsf3_pse+0x86>
    1b00:	0c 94 13 0e 	jmp	0x1c26	; 0x1c26 <__fp_inf>
    1b04:	0c 94 5e 0e 	jmp	0x1cbc	; 0x1cbc <__fp_szero>
    1b08:	5f 3f       	cpi	r21, 0xFF	; 255
    1b0a:	e4 f3       	brlt	.-8      	; 0x1b04 <__divsf3_pse+0x6c>
    1b0c:	98 3e       	cpi	r25, 0xE8	; 232
    1b0e:	d4 f3       	brlt	.-12     	; 0x1b04 <__divsf3_pse+0x6c>
    1b10:	86 95       	lsr	r24
    1b12:	77 95       	ror	r23
    1b14:	67 95       	ror	r22
    1b16:	b7 95       	ror	r27
    1b18:	f7 95       	ror	r31
    1b1a:	9f 5f       	subi	r25, 0xFF	; 255
    1b1c:	c9 f7       	brne	.-14     	; 0x1b10 <__divsf3_pse+0x78>
    1b1e:	88 0f       	add	r24, r24
    1b20:	91 1d       	adc	r25, r1
    1b22:	96 95       	lsr	r25
    1b24:	87 95       	ror	r24
    1b26:	97 f9       	bld	r25, 7
    1b28:	08 95       	ret
    1b2a:	e1 e0       	ldi	r30, 0x01	; 1
    1b2c:	66 0f       	add	r22, r22
    1b2e:	77 1f       	adc	r23, r23
    1b30:	88 1f       	adc	r24, r24
    1b32:	bb 1f       	adc	r27, r27
    1b34:	62 17       	cp	r22, r18
    1b36:	73 07       	cpc	r23, r19
    1b38:	84 07       	cpc	r24, r20
    1b3a:	ba 07       	cpc	r27, r26
    1b3c:	20 f0       	brcs	.+8      	; 0x1b46 <__divsf3_pse+0xae>
    1b3e:	62 1b       	sub	r22, r18
    1b40:	73 0b       	sbc	r23, r19
    1b42:	84 0b       	sbc	r24, r20
    1b44:	ba 0b       	sbc	r27, r26
    1b46:	ee 1f       	adc	r30, r30
    1b48:	88 f7       	brcc	.-30     	; 0x1b2c <__divsf3_pse+0x94>
    1b4a:	e0 95       	com	r30
    1b4c:	08 95       	ret

00001b4e <__fixunssfsi>:
    1b4e:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <__fp_splitA>
    1b52:	88 f0       	brcs	.+34     	; 0x1b76 <__fixunssfsi+0x28>
    1b54:	9f 57       	subi	r25, 0x7F	; 127
    1b56:	98 f0       	brcs	.+38     	; 0x1b7e <__fixunssfsi+0x30>
    1b58:	b9 2f       	mov	r27, r25
    1b5a:	99 27       	eor	r25, r25
    1b5c:	b7 51       	subi	r27, 0x17	; 23
    1b5e:	b0 f0       	brcs	.+44     	; 0x1b8c <__fixunssfsi+0x3e>
    1b60:	e1 f0       	breq	.+56     	; 0x1b9a <__fixunssfsi+0x4c>
    1b62:	66 0f       	add	r22, r22
    1b64:	77 1f       	adc	r23, r23
    1b66:	88 1f       	adc	r24, r24
    1b68:	99 1f       	adc	r25, r25
    1b6a:	1a f0       	brmi	.+6      	; 0x1b72 <__fixunssfsi+0x24>
    1b6c:	ba 95       	dec	r27
    1b6e:	c9 f7       	brne	.-14     	; 0x1b62 <__fixunssfsi+0x14>
    1b70:	14 c0       	rjmp	.+40     	; 0x1b9a <__fixunssfsi+0x4c>
    1b72:	b1 30       	cpi	r27, 0x01	; 1
    1b74:	91 f0       	breq	.+36     	; 0x1b9a <__fixunssfsi+0x4c>
    1b76:	0e 94 5d 0e 	call	0x1cba	; 0x1cba <__fp_zero>
    1b7a:	b1 e0       	ldi	r27, 0x01	; 1
    1b7c:	08 95       	ret
    1b7e:	0c 94 5d 0e 	jmp	0x1cba	; 0x1cba <__fp_zero>
    1b82:	67 2f       	mov	r22, r23
    1b84:	78 2f       	mov	r23, r24
    1b86:	88 27       	eor	r24, r24
    1b88:	b8 5f       	subi	r27, 0xF8	; 248
    1b8a:	39 f0       	breq	.+14     	; 0x1b9a <__fixunssfsi+0x4c>
    1b8c:	b9 3f       	cpi	r27, 0xF9	; 249
    1b8e:	cc f3       	brlt	.-14     	; 0x1b82 <__fixunssfsi+0x34>
    1b90:	86 95       	lsr	r24
    1b92:	77 95       	ror	r23
    1b94:	67 95       	ror	r22
    1b96:	b3 95       	inc	r27
    1b98:	d9 f7       	brne	.-10     	; 0x1b90 <__fixunssfsi+0x42>
    1b9a:	3e f4       	brtc	.+14     	; 0x1baa <__fixunssfsi+0x5c>
    1b9c:	90 95       	com	r25
    1b9e:	80 95       	com	r24
    1ba0:	70 95       	com	r23
    1ba2:	61 95       	neg	r22
    1ba4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ba6:	8f 4f       	sbci	r24, 0xFF	; 255
    1ba8:	9f 4f       	sbci	r25, 0xFF	; 255
    1baa:	08 95       	ret

00001bac <__floatunsisf>:
    1bac:	e8 94       	clt
    1bae:	09 c0       	rjmp	.+18     	; 0x1bc2 <__floatsisf+0x12>

00001bb0 <__floatsisf>:
    1bb0:	97 fb       	bst	r25, 7
    1bb2:	3e f4       	brtc	.+14     	; 0x1bc2 <__floatsisf+0x12>
    1bb4:	90 95       	com	r25
    1bb6:	80 95       	com	r24
    1bb8:	70 95       	com	r23
    1bba:	61 95       	neg	r22
    1bbc:	7f 4f       	sbci	r23, 0xFF	; 255
    1bbe:	8f 4f       	sbci	r24, 0xFF	; 255
    1bc0:	9f 4f       	sbci	r25, 0xFF	; 255
    1bc2:	99 23       	and	r25, r25
    1bc4:	a9 f0       	breq	.+42     	; 0x1bf0 <__floatsisf+0x40>
    1bc6:	f9 2f       	mov	r31, r25
    1bc8:	96 e9       	ldi	r25, 0x96	; 150
    1bca:	bb 27       	eor	r27, r27
    1bcc:	93 95       	inc	r25
    1bce:	f6 95       	lsr	r31
    1bd0:	87 95       	ror	r24
    1bd2:	77 95       	ror	r23
    1bd4:	67 95       	ror	r22
    1bd6:	b7 95       	ror	r27
    1bd8:	f1 11       	cpse	r31, r1
    1bda:	f8 cf       	rjmp	.-16     	; 0x1bcc <__floatsisf+0x1c>
    1bdc:	fa f4       	brpl	.+62     	; 0x1c1c <__floatsisf+0x6c>
    1bde:	bb 0f       	add	r27, r27
    1be0:	11 f4       	brne	.+4      	; 0x1be6 <__floatsisf+0x36>
    1be2:	60 ff       	sbrs	r22, 0
    1be4:	1b c0       	rjmp	.+54     	; 0x1c1c <__floatsisf+0x6c>
    1be6:	6f 5f       	subi	r22, 0xFF	; 255
    1be8:	7f 4f       	sbci	r23, 0xFF	; 255
    1bea:	8f 4f       	sbci	r24, 0xFF	; 255
    1bec:	9f 4f       	sbci	r25, 0xFF	; 255
    1bee:	16 c0       	rjmp	.+44     	; 0x1c1c <__floatsisf+0x6c>
    1bf0:	88 23       	and	r24, r24
    1bf2:	11 f0       	breq	.+4      	; 0x1bf8 <__floatsisf+0x48>
    1bf4:	96 e9       	ldi	r25, 0x96	; 150
    1bf6:	11 c0       	rjmp	.+34     	; 0x1c1a <__floatsisf+0x6a>
    1bf8:	77 23       	and	r23, r23
    1bfa:	21 f0       	breq	.+8      	; 0x1c04 <__floatsisf+0x54>
    1bfc:	9e e8       	ldi	r25, 0x8E	; 142
    1bfe:	87 2f       	mov	r24, r23
    1c00:	76 2f       	mov	r23, r22
    1c02:	05 c0       	rjmp	.+10     	; 0x1c0e <__floatsisf+0x5e>
    1c04:	66 23       	and	r22, r22
    1c06:	71 f0       	breq	.+28     	; 0x1c24 <__floatsisf+0x74>
    1c08:	96 e8       	ldi	r25, 0x86	; 134
    1c0a:	86 2f       	mov	r24, r22
    1c0c:	70 e0       	ldi	r23, 0x00	; 0
    1c0e:	60 e0       	ldi	r22, 0x00	; 0
    1c10:	2a f0       	brmi	.+10     	; 0x1c1c <__floatsisf+0x6c>
    1c12:	9a 95       	dec	r25
    1c14:	66 0f       	add	r22, r22
    1c16:	77 1f       	adc	r23, r23
    1c18:	88 1f       	adc	r24, r24
    1c1a:	da f7       	brpl	.-10     	; 0x1c12 <__floatsisf+0x62>
    1c1c:	88 0f       	add	r24, r24
    1c1e:	96 95       	lsr	r25
    1c20:	87 95       	ror	r24
    1c22:	97 f9       	bld	r25, 7
    1c24:	08 95       	ret

00001c26 <__fp_inf>:
    1c26:	97 f9       	bld	r25, 7
    1c28:	9f 67       	ori	r25, 0x7F	; 127
    1c2a:	80 e8       	ldi	r24, 0x80	; 128
    1c2c:	70 e0       	ldi	r23, 0x00	; 0
    1c2e:	60 e0       	ldi	r22, 0x00	; 0
    1c30:	08 95       	ret

00001c32 <__fp_nan>:
    1c32:	9f ef       	ldi	r25, 0xFF	; 255
    1c34:	80 ec       	ldi	r24, 0xC0	; 192
    1c36:	08 95       	ret

00001c38 <__fp_pscA>:
    1c38:	00 24       	eor	r0, r0
    1c3a:	0a 94       	dec	r0
    1c3c:	16 16       	cp	r1, r22
    1c3e:	17 06       	cpc	r1, r23
    1c40:	18 06       	cpc	r1, r24
    1c42:	09 06       	cpc	r0, r25
    1c44:	08 95       	ret

00001c46 <__fp_pscB>:
    1c46:	00 24       	eor	r0, r0
    1c48:	0a 94       	dec	r0
    1c4a:	12 16       	cp	r1, r18
    1c4c:	13 06       	cpc	r1, r19
    1c4e:	14 06       	cpc	r1, r20
    1c50:	05 06       	cpc	r0, r21
    1c52:	08 95       	ret

00001c54 <__fp_round>:
    1c54:	09 2e       	mov	r0, r25
    1c56:	03 94       	inc	r0
    1c58:	00 0c       	add	r0, r0
    1c5a:	11 f4       	brne	.+4      	; 0x1c60 <__fp_round+0xc>
    1c5c:	88 23       	and	r24, r24
    1c5e:	52 f0       	brmi	.+20     	; 0x1c74 <__fp_round+0x20>
    1c60:	bb 0f       	add	r27, r27
    1c62:	40 f4       	brcc	.+16     	; 0x1c74 <__fp_round+0x20>
    1c64:	bf 2b       	or	r27, r31
    1c66:	11 f4       	brne	.+4      	; 0x1c6c <__fp_round+0x18>
    1c68:	60 ff       	sbrs	r22, 0
    1c6a:	04 c0       	rjmp	.+8      	; 0x1c74 <__fp_round+0x20>
    1c6c:	6f 5f       	subi	r22, 0xFF	; 255
    1c6e:	7f 4f       	sbci	r23, 0xFF	; 255
    1c70:	8f 4f       	sbci	r24, 0xFF	; 255
    1c72:	9f 4f       	sbci	r25, 0xFF	; 255
    1c74:	08 95       	ret

00001c76 <__fp_split3>:
    1c76:	57 fd       	sbrc	r21, 7
    1c78:	90 58       	subi	r25, 0x80	; 128
    1c7a:	44 0f       	add	r20, r20
    1c7c:	55 1f       	adc	r21, r21
    1c7e:	59 f0       	breq	.+22     	; 0x1c96 <__fp_splitA+0x10>
    1c80:	5f 3f       	cpi	r21, 0xFF	; 255
    1c82:	71 f0       	breq	.+28     	; 0x1ca0 <__fp_splitA+0x1a>
    1c84:	47 95       	ror	r20

00001c86 <__fp_splitA>:
    1c86:	88 0f       	add	r24, r24
    1c88:	97 fb       	bst	r25, 7
    1c8a:	99 1f       	adc	r25, r25
    1c8c:	61 f0       	breq	.+24     	; 0x1ca6 <__fp_splitA+0x20>
    1c8e:	9f 3f       	cpi	r25, 0xFF	; 255
    1c90:	79 f0       	breq	.+30     	; 0x1cb0 <__fp_splitA+0x2a>
    1c92:	87 95       	ror	r24
    1c94:	08 95       	ret
    1c96:	12 16       	cp	r1, r18
    1c98:	13 06       	cpc	r1, r19
    1c9a:	14 06       	cpc	r1, r20
    1c9c:	55 1f       	adc	r21, r21
    1c9e:	f2 cf       	rjmp	.-28     	; 0x1c84 <__fp_split3+0xe>
    1ca0:	46 95       	lsr	r20
    1ca2:	f1 df       	rcall	.-30     	; 0x1c86 <__fp_splitA>
    1ca4:	08 c0       	rjmp	.+16     	; 0x1cb6 <__fp_splitA+0x30>
    1ca6:	16 16       	cp	r1, r22
    1ca8:	17 06       	cpc	r1, r23
    1caa:	18 06       	cpc	r1, r24
    1cac:	99 1f       	adc	r25, r25
    1cae:	f1 cf       	rjmp	.-30     	; 0x1c92 <__fp_splitA+0xc>
    1cb0:	86 95       	lsr	r24
    1cb2:	71 05       	cpc	r23, r1
    1cb4:	61 05       	cpc	r22, r1
    1cb6:	08 94       	sec
    1cb8:	08 95       	ret

00001cba <__fp_zero>:
    1cba:	e8 94       	clt

00001cbc <__fp_szero>:
    1cbc:	bb 27       	eor	r27, r27
    1cbe:	66 27       	eor	r22, r22
    1cc0:	77 27       	eor	r23, r23
    1cc2:	cb 01       	movw	r24, r22
    1cc4:	97 f9       	bld	r25, 7
    1cc6:	08 95       	ret
    1cc8:	16 f0       	brts	.+4      	; 0x1cce <__fp_szero+0x12>
    1cca:	0c 94 21 0f 	jmp	0x1e42	; 0x1e42 <__fp_mpack>
    1cce:	0c 94 19 0e 	jmp	0x1c32	; 0x1c32 <__fp_nan>
    1cd2:	68 94       	set
    1cd4:	0c 94 13 0e 	jmp	0x1c26	; 0x1c26 <__fp_inf>

00001cd8 <log>:
    1cd8:	0e 94 43 0e 	call	0x1c86	; 0x1c86 <__fp_splitA>
    1cdc:	a8 f3       	brcs	.-22     	; 0x1cc8 <__fp_szero+0xc>
    1cde:	99 23       	and	r25, r25
    1ce0:	c1 f3       	breq	.-16     	; 0x1cd2 <__fp_szero+0x16>
    1ce2:	ae f3       	brts	.-22     	; 0x1cce <__fp_szero+0x12>
    1ce4:	df 93       	push	r29
    1ce6:	cf 93       	push	r28
    1ce8:	1f 93       	push	r17
    1cea:	0f 93       	push	r16
    1cec:	ff 92       	push	r15
    1cee:	c9 2f       	mov	r28, r25
    1cf0:	dd 27       	eor	r29, r29
    1cf2:	88 23       	and	r24, r24
    1cf4:	2a f0       	brmi	.+10     	; 0x1d00 <log+0x28>
    1cf6:	21 97       	sbiw	r28, 0x01	; 1
    1cf8:	66 0f       	add	r22, r22
    1cfa:	77 1f       	adc	r23, r23
    1cfc:	88 1f       	adc	r24, r24
    1cfe:	da f7       	brpl	.-10     	; 0x1cf6 <log+0x1e>
    1d00:	20 e0       	ldi	r18, 0x00	; 0
    1d02:	30 e0       	ldi	r19, 0x00	; 0
    1d04:	40 e8       	ldi	r20, 0x80	; 128
    1d06:	5f eb       	ldi	r21, 0xBF	; 191
    1d08:	9f e3       	ldi	r25, 0x3F	; 63
    1d0a:	88 39       	cpi	r24, 0x98	; 152
    1d0c:	20 f0       	brcs	.+8      	; 0x1d16 <log+0x3e>
    1d0e:	80 3e       	cpi	r24, 0xE0	; 224
    1d10:	38 f0       	brcs	.+14     	; 0x1d20 <log+0x48>
    1d12:	21 96       	adiw	r28, 0x01	; 1
    1d14:	8f 77       	andi	r24, 0x7F	; 127
    1d16:	0e 94 c9 0c 	call	0x1992	; 0x1992 <__addsf3>
    1d1a:	e4 e5       	ldi	r30, 0x54	; 84
    1d1c:	f0 e0       	ldi	r31, 0x00	; 0
    1d1e:	04 c0       	rjmp	.+8      	; 0x1d28 <log+0x50>
    1d20:	0e 94 c9 0c 	call	0x1992	; 0x1992 <__addsf3>
    1d24:	e1 e8       	ldi	r30, 0x81	; 129
    1d26:	f0 e0       	ldi	r31, 0x00	; 0
    1d28:	0e 94 2f 0f 	call	0x1e5e	; 0x1e5e <__fp_powser>
    1d2c:	8b 01       	movw	r16, r22
    1d2e:	be 01       	movw	r22, r28
    1d30:	ec 01       	movw	r28, r24
    1d32:	fb 2e       	mov	r15, r27
    1d34:	6f 57       	subi	r22, 0x7F	; 127
    1d36:	71 09       	sbc	r23, r1
    1d38:	75 95       	asr	r23
    1d3a:	77 1f       	adc	r23, r23
    1d3c:	88 0b       	sbc	r24, r24
    1d3e:	99 0b       	sbc	r25, r25
    1d40:	0e 94 d8 0d 	call	0x1bb0	; 0x1bb0 <__floatsisf>
    1d44:	28 e1       	ldi	r18, 0x18	; 24
    1d46:	32 e7       	ldi	r19, 0x72	; 114
    1d48:	41 e3       	ldi	r20, 0x31	; 49
    1d4a:	5f e3       	ldi	r21, 0x3F	; 63
    1d4c:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <__mulsf3x>
    1d50:	af 2d       	mov	r26, r15
    1d52:	98 01       	movw	r18, r16
    1d54:	ae 01       	movw	r20, r28
    1d56:	ff 90       	pop	r15
    1d58:	0f 91       	pop	r16
    1d5a:	1f 91       	pop	r17
    1d5c:	cf 91       	pop	r28
    1d5e:	df 91       	pop	r29
    1d60:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <__addsf3x>
    1d64:	0c 94 2a 0e 	jmp	0x1c54	; 0x1c54 <__fp_round>

00001d68 <__mulsf3>:
    1d68:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <__mulsf3x>
    1d6c:	0c 94 2a 0e 	jmp	0x1c54	; 0x1c54 <__fp_round>
    1d70:	0e 94 1c 0e 	call	0x1c38	; 0x1c38 <__fp_pscA>
    1d74:	38 f0       	brcs	.+14     	; 0x1d84 <__mulsf3+0x1c>
    1d76:	0e 94 23 0e 	call	0x1c46	; 0x1c46 <__fp_pscB>
    1d7a:	20 f0       	brcs	.+8      	; 0x1d84 <__mulsf3+0x1c>
    1d7c:	95 23       	and	r25, r21
    1d7e:	11 f0       	breq	.+4      	; 0x1d84 <__mulsf3+0x1c>
    1d80:	0c 94 13 0e 	jmp	0x1c26	; 0x1c26 <__fp_inf>
    1d84:	0c 94 19 0e 	jmp	0x1c32	; 0x1c32 <__fp_nan>
    1d88:	11 24       	eor	r1, r1
    1d8a:	0c 94 5e 0e 	jmp	0x1cbc	; 0x1cbc <__fp_szero>

00001d8e <__mulsf3x>:
    1d8e:	0e 94 3b 0e 	call	0x1c76	; 0x1c76 <__fp_split3>
    1d92:	70 f3       	brcs	.-36     	; 0x1d70 <__mulsf3+0x8>

00001d94 <__mulsf3_pse>:
    1d94:	95 9f       	mul	r25, r21
    1d96:	c1 f3       	breq	.-16     	; 0x1d88 <__mulsf3+0x20>
    1d98:	95 0f       	add	r25, r21
    1d9a:	50 e0       	ldi	r21, 0x00	; 0
    1d9c:	55 1f       	adc	r21, r21
    1d9e:	62 9f       	mul	r22, r18
    1da0:	f0 01       	movw	r30, r0
    1da2:	72 9f       	mul	r23, r18
    1da4:	bb 27       	eor	r27, r27
    1da6:	f0 0d       	add	r31, r0
    1da8:	b1 1d       	adc	r27, r1
    1daa:	63 9f       	mul	r22, r19
    1dac:	aa 27       	eor	r26, r26
    1dae:	f0 0d       	add	r31, r0
    1db0:	b1 1d       	adc	r27, r1
    1db2:	aa 1f       	adc	r26, r26
    1db4:	64 9f       	mul	r22, r20
    1db6:	66 27       	eor	r22, r22
    1db8:	b0 0d       	add	r27, r0
    1dba:	a1 1d       	adc	r26, r1
    1dbc:	66 1f       	adc	r22, r22
    1dbe:	82 9f       	mul	r24, r18
    1dc0:	22 27       	eor	r18, r18
    1dc2:	b0 0d       	add	r27, r0
    1dc4:	a1 1d       	adc	r26, r1
    1dc6:	62 1f       	adc	r22, r18
    1dc8:	73 9f       	mul	r23, r19
    1dca:	b0 0d       	add	r27, r0
    1dcc:	a1 1d       	adc	r26, r1
    1dce:	62 1f       	adc	r22, r18
    1dd0:	83 9f       	mul	r24, r19
    1dd2:	a0 0d       	add	r26, r0
    1dd4:	61 1d       	adc	r22, r1
    1dd6:	22 1f       	adc	r18, r18
    1dd8:	74 9f       	mul	r23, r20
    1dda:	33 27       	eor	r19, r19
    1ddc:	a0 0d       	add	r26, r0
    1dde:	61 1d       	adc	r22, r1
    1de0:	23 1f       	adc	r18, r19
    1de2:	84 9f       	mul	r24, r20
    1de4:	60 0d       	add	r22, r0
    1de6:	21 1d       	adc	r18, r1
    1de8:	82 2f       	mov	r24, r18
    1dea:	76 2f       	mov	r23, r22
    1dec:	6a 2f       	mov	r22, r26
    1dee:	11 24       	eor	r1, r1
    1df0:	9f 57       	subi	r25, 0x7F	; 127
    1df2:	50 40       	sbci	r21, 0x00	; 0
    1df4:	9a f0       	brmi	.+38     	; 0x1e1c <__mulsf3_pse+0x88>
    1df6:	f1 f0       	breq	.+60     	; 0x1e34 <__mulsf3_pse+0xa0>
    1df8:	88 23       	and	r24, r24
    1dfa:	4a f0       	brmi	.+18     	; 0x1e0e <__mulsf3_pse+0x7a>
    1dfc:	ee 0f       	add	r30, r30
    1dfe:	ff 1f       	adc	r31, r31
    1e00:	bb 1f       	adc	r27, r27
    1e02:	66 1f       	adc	r22, r22
    1e04:	77 1f       	adc	r23, r23
    1e06:	88 1f       	adc	r24, r24
    1e08:	91 50       	subi	r25, 0x01	; 1
    1e0a:	50 40       	sbci	r21, 0x00	; 0
    1e0c:	a9 f7       	brne	.-22     	; 0x1df8 <__mulsf3_pse+0x64>
    1e0e:	9e 3f       	cpi	r25, 0xFE	; 254
    1e10:	51 05       	cpc	r21, r1
    1e12:	80 f0       	brcs	.+32     	; 0x1e34 <__mulsf3_pse+0xa0>
    1e14:	0c 94 13 0e 	jmp	0x1c26	; 0x1c26 <__fp_inf>
    1e18:	0c 94 5e 0e 	jmp	0x1cbc	; 0x1cbc <__fp_szero>
    1e1c:	5f 3f       	cpi	r21, 0xFF	; 255
    1e1e:	e4 f3       	brlt	.-8      	; 0x1e18 <__mulsf3_pse+0x84>
    1e20:	98 3e       	cpi	r25, 0xE8	; 232
    1e22:	d4 f3       	brlt	.-12     	; 0x1e18 <__mulsf3_pse+0x84>
    1e24:	86 95       	lsr	r24
    1e26:	77 95       	ror	r23
    1e28:	67 95       	ror	r22
    1e2a:	b7 95       	ror	r27
    1e2c:	f7 95       	ror	r31
    1e2e:	e7 95       	ror	r30
    1e30:	9f 5f       	subi	r25, 0xFF	; 255
    1e32:	c1 f7       	brne	.-16     	; 0x1e24 <__mulsf3_pse+0x90>
    1e34:	fe 2b       	or	r31, r30
    1e36:	88 0f       	add	r24, r24
    1e38:	91 1d       	adc	r25, r1
    1e3a:	96 95       	lsr	r25
    1e3c:	87 95       	ror	r24
    1e3e:	97 f9       	bld	r25, 7
    1e40:	08 95       	ret

00001e42 <__fp_mpack>:
    1e42:	9f 3f       	cpi	r25, 0xFF	; 255
    1e44:	31 f0       	breq	.+12     	; 0x1e52 <__fp_mpack_finite+0xc>

00001e46 <__fp_mpack_finite>:
    1e46:	91 50       	subi	r25, 0x01	; 1
    1e48:	20 f4       	brcc	.+8      	; 0x1e52 <__fp_mpack_finite+0xc>
    1e4a:	87 95       	ror	r24
    1e4c:	77 95       	ror	r23
    1e4e:	67 95       	ror	r22
    1e50:	b7 95       	ror	r27
    1e52:	88 0f       	add	r24, r24
    1e54:	91 1d       	adc	r25, r1
    1e56:	96 95       	lsr	r25
    1e58:	87 95       	ror	r24
    1e5a:	97 f9       	bld	r25, 7
    1e5c:	08 95       	ret

00001e5e <__fp_powser>:
    1e5e:	df 93       	push	r29
    1e60:	cf 93       	push	r28
    1e62:	1f 93       	push	r17
    1e64:	0f 93       	push	r16
    1e66:	ff 92       	push	r15
    1e68:	ef 92       	push	r14
    1e6a:	df 92       	push	r13
    1e6c:	7b 01       	movw	r14, r22
    1e6e:	8c 01       	movw	r16, r24
    1e70:	68 94       	set
    1e72:	06 c0       	rjmp	.+12     	; 0x1e80 <__fp_powser+0x22>
    1e74:	da 2e       	mov	r13, r26
    1e76:	ef 01       	movw	r28, r30
    1e78:	0e 94 c7 0e 	call	0x1d8e	; 0x1d8e <__mulsf3x>
    1e7c:	fe 01       	movw	r30, r28
    1e7e:	e8 94       	clt
    1e80:	a5 91       	lpm	r26, Z+
    1e82:	25 91       	lpm	r18, Z+
    1e84:	35 91       	lpm	r19, Z+
    1e86:	45 91       	lpm	r20, Z+
    1e88:	55 91       	lpm	r21, Z+
    1e8a:	a6 f3       	brts	.-24     	; 0x1e74 <__fp_powser+0x16>
    1e8c:	ef 01       	movw	r28, r30
    1e8e:	0e 94 e0 0c 	call	0x19c0	; 0x19c0 <__addsf3x>
    1e92:	fe 01       	movw	r30, r28
    1e94:	97 01       	movw	r18, r14
    1e96:	a8 01       	movw	r20, r16
    1e98:	da 94       	dec	r13
    1e9a:	69 f7       	brne	.-38     	; 0x1e76 <__fp_powser+0x18>
    1e9c:	df 90       	pop	r13
    1e9e:	ef 90       	pop	r14
    1ea0:	ff 90       	pop	r15
    1ea2:	0f 91       	pop	r16
    1ea4:	1f 91       	pop	r17
    1ea6:	cf 91       	pop	r28
    1ea8:	df 91       	pop	r29
    1eaa:	08 95       	ret

00001eac <_exit>:
    1eac:	f8 94       	cli

00001eae <__stop_program>:
    1eae:	ff cf       	rjmp	.-2      	; 0x1eae <__stop_program>
