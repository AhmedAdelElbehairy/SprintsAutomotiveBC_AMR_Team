
Receiver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001aa2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000092  00800060  00001aa2  00001b36  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000644  008000f2  008000f2  00001bc8  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001bc8  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001bf8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000430  00000000  00000000  00001c34  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00004037  00000000  00000000  00002064  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000166b  00000000  00000000  0000609b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002b3f  00000000  00000000  00007706  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000914  00000000  00000000  0000a248  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001895  00000000  00000000  0000ab5c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002f85  00000000  00000000  0000c3f1  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000400  00000000  00000000  0000f376  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 2c 02 	jmp	0x458	; 0x458 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e2 ea       	ldi	r30, 0xA2	; 162
      68:	fa e1       	ldi	r31, 0x1A	; 26
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a2 3f       	cpi	r26, 0xF2	; 242
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	27 e0       	ldi	r18, 0x07	; 7
      78:	a2 ef       	ldi	r26, 0xF2	; 242
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a6 33       	cpi	r26, 0x36	; 54
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 2c 0b 	call	0x1658	; 0x1658 <main>
      8a:	0c 94 4f 0d 	jmp	0x1a9e	; 0x1a9e <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
      92:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      94:	03 96       	adiw	r24, 0x03	; 3
      96:	92 83       	std	Z+2, r25	; 0x02
      98:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
      9a:	2f ef       	ldi	r18, 0xFF	; 255
      9c:	3f ef       	ldi	r19, 0xFF	; 255
      9e:	34 83       	std	Z+4, r19	; 0x04
      a0:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      a2:	96 83       	std	Z+6, r25	; 0x06
      a4:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      a6:	90 87       	std	Z+8, r25	; 0x08
      a8:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
      aa:	10 82       	st	Z, r1
      ac:	08 95       	ret

000000ae <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
      ae:	fc 01       	movw	r30, r24
      b0:	11 86       	std	Z+9, r1	; 0x09
      b2:	10 86       	std	Z+8, r1	; 0x08
      b4:	08 95       	ret

000000b6 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
      b6:	cf 93       	push	r28
      b8:	df 93       	push	r29
      ba:	9c 01       	movw	r18, r24
      bc:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
      be:	dc 01       	movw	r26, r24
      c0:	11 96       	adiw	r26, 0x01	; 1
      c2:	cd 91       	ld	r28, X+
      c4:	dc 91       	ld	r29, X
      c6:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
      c8:	d3 83       	std	Z+3, r29	; 0x03
      ca:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
      cc:	8c 81       	ldd	r24, Y+4	; 0x04
      ce:	9d 81       	ldd	r25, Y+5	; 0x05
      d0:	95 83       	std	Z+5, r25	; 0x05
      d2:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
      d4:	8c 81       	ldd	r24, Y+4	; 0x04
      d6:	9d 81       	ldd	r25, Y+5	; 0x05
      d8:	dc 01       	movw	r26, r24
      da:	13 96       	adiw	r26, 0x03	; 3
      dc:	7c 93       	st	X, r23
      de:	6e 93       	st	-X, r22
      e0:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
      e2:	7d 83       	std	Y+5, r23	; 0x05
      e4:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
      e6:	31 87       	std	Z+9, r19	; 0x09
      e8:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
      ea:	f9 01       	movw	r30, r18
      ec:	80 81       	ld	r24, Z
      ee:	8f 5f       	subi	r24, 0xFF	; 255
      f0:	80 83       	st	Z, r24
}
      f2:	df 91       	pop	r29
      f4:	cf 91       	pop	r28
      f6:	08 95       	ret

000000f8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
      f8:	cf 93       	push	r28
      fa:	df 93       	push	r29
      fc:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
      fe:	48 81       	ld	r20, Y
     100:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     102:	4f 3f       	cpi	r20, 0xFF	; 255
     104:	2f ef       	ldi	r18, 0xFF	; 255
     106:	52 07       	cpc	r21, r18
     108:	21 f4       	brne	.+8      	; 0x112 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     10a:	fc 01       	movw	r30, r24
     10c:	a7 81       	ldd	r26, Z+7	; 0x07
     10e:	b0 85       	ldd	r27, Z+8	; 0x08
     110:	0d c0       	rjmp	.+26     	; 0x12c <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     112:	dc 01       	movw	r26, r24
     114:	13 96       	adiw	r26, 0x03	; 3
     116:	01 c0       	rjmp	.+2      	; 0x11a <vListInsert+0x22>
     118:	df 01       	movw	r26, r30
     11a:	12 96       	adiw	r26, 0x02	; 2
     11c:	ed 91       	ld	r30, X+
     11e:	fc 91       	ld	r31, X
     120:	13 97       	sbiw	r26, 0x03	; 3
     122:	20 81       	ld	r18, Z
     124:	31 81       	ldd	r19, Z+1	; 0x01
     126:	42 17       	cp	r20, r18
     128:	53 07       	cpc	r21, r19
     12a:	b0 f7       	brcc	.-20     	; 0x118 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     12c:	12 96       	adiw	r26, 0x02	; 2
     12e:	ed 91       	ld	r30, X+
     130:	fc 91       	ld	r31, X
     132:	13 97       	sbiw	r26, 0x03	; 3
     134:	fb 83       	std	Y+3, r31	; 0x03
     136:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     138:	d5 83       	std	Z+5, r29	; 0x05
     13a:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     13c:	bd 83       	std	Y+5, r27	; 0x05
     13e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     140:	13 96       	adiw	r26, 0x03	; 3
     142:	dc 93       	st	X, r29
     144:	ce 93       	st	-X, r28
     146:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     148:	99 87       	std	Y+9, r25	; 0x09
     14a:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     14c:	fc 01       	movw	r30, r24
     14e:	20 81       	ld	r18, Z
     150:	2f 5f       	subi	r18, 0xFF	; 255
     152:	20 83       	st	Z, r18
}
     154:	df 91       	pop	r29
     156:	cf 91       	pop	r28
     158:	08 95       	ret

0000015a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     15a:	cf 93       	push	r28
     15c:	df 93       	push	r29
     15e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     160:	a0 85       	ldd	r26, Z+8	; 0x08
     162:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     164:	c2 81       	ldd	r28, Z+2	; 0x02
     166:	d3 81       	ldd	r29, Z+3	; 0x03
     168:	84 81       	ldd	r24, Z+4	; 0x04
     16a:	95 81       	ldd	r25, Z+5	; 0x05
     16c:	9d 83       	std	Y+5, r25	; 0x05
     16e:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     170:	c4 81       	ldd	r28, Z+4	; 0x04
     172:	d5 81       	ldd	r29, Z+5	; 0x05
     174:	82 81       	ldd	r24, Z+2	; 0x02
     176:	93 81       	ldd	r25, Z+3	; 0x03
     178:	9b 83       	std	Y+3, r25	; 0x03
     17a:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     17c:	11 96       	adiw	r26, 0x01	; 1
     17e:	8d 91       	ld	r24, X+
     180:	9c 91       	ld	r25, X
     182:	12 97       	sbiw	r26, 0x02	; 2
     184:	e8 17       	cp	r30, r24
     186:	f9 07       	cpc	r31, r25
     188:	31 f4       	brne	.+12     	; 0x196 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     18a:	84 81       	ldd	r24, Z+4	; 0x04
     18c:	95 81       	ldd	r25, Z+5	; 0x05
     18e:	12 96       	adiw	r26, 0x02	; 2
     190:	9c 93       	st	X, r25
     192:	8e 93       	st	-X, r24
     194:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     196:	11 86       	std	Z+9, r1	; 0x09
     198:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     19a:	8c 91       	ld	r24, X
     19c:	81 50       	subi	r24, 0x01	; 1
     19e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     1a0:	df 91       	pop	r29
     1a2:	cf 91       	pop	r28
     1a4:	08 95       	ret

000001a6 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     1a6:	1b bc       	out	0x2b, r1	; 43
     1a8:	89 ef       	ldi	r24, 0xF9	; 249
     1aa:	8a bd       	out	0x2a, r24	; 42
     1ac:	8b e0       	ldi	r24, 0x0B	; 11
     1ae:	8e bd       	out	0x2e, r24	; 46
     1b0:	89 b7       	in	r24, 0x39	; 57
     1b2:	80 61       	ori	r24, 0x10	; 16
     1b4:	89 bf       	out	0x39, r24	; 57
     1b6:	08 95       	ret

000001b8 <pxPortInitialiseStack>:
     1b8:	31 e1       	ldi	r19, 0x11	; 17
     1ba:	fc 01       	movw	r30, r24
     1bc:	30 83       	st	Z, r19
     1be:	31 97       	sbiw	r30, 0x01	; 1
     1c0:	22 e2       	ldi	r18, 0x22	; 34
     1c2:	20 83       	st	Z, r18
     1c4:	31 97       	sbiw	r30, 0x01	; 1
     1c6:	a3 e3       	ldi	r26, 0x33	; 51
     1c8:	a0 83       	st	Z, r26
     1ca:	31 97       	sbiw	r30, 0x01	; 1
     1cc:	60 83       	st	Z, r22
     1ce:	31 97       	sbiw	r30, 0x01	; 1
     1d0:	70 83       	st	Z, r23
     1d2:	31 97       	sbiw	r30, 0x01	; 1
     1d4:	10 82       	st	Z, r1
     1d6:	31 97       	sbiw	r30, 0x01	; 1
     1d8:	60 e8       	ldi	r22, 0x80	; 128
     1da:	60 83       	st	Z, r22
     1dc:	31 97       	sbiw	r30, 0x01	; 1
     1de:	10 82       	st	Z, r1
     1e0:	31 97       	sbiw	r30, 0x01	; 1
     1e2:	62 e0       	ldi	r22, 0x02	; 2
     1e4:	60 83       	st	Z, r22
     1e6:	31 97       	sbiw	r30, 0x01	; 1
     1e8:	63 e0       	ldi	r22, 0x03	; 3
     1ea:	60 83       	st	Z, r22
     1ec:	31 97       	sbiw	r30, 0x01	; 1
     1ee:	64 e0       	ldi	r22, 0x04	; 4
     1f0:	60 83       	st	Z, r22
     1f2:	31 97       	sbiw	r30, 0x01	; 1
     1f4:	65 e0       	ldi	r22, 0x05	; 5
     1f6:	60 83       	st	Z, r22
     1f8:	31 97       	sbiw	r30, 0x01	; 1
     1fa:	66 e0       	ldi	r22, 0x06	; 6
     1fc:	60 83       	st	Z, r22
     1fe:	31 97       	sbiw	r30, 0x01	; 1
     200:	67 e0       	ldi	r22, 0x07	; 7
     202:	60 83       	st	Z, r22
     204:	31 97       	sbiw	r30, 0x01	; 1
     206:	68 e0       	ldi	r22, 0x08	; 8
     208:	60 83       	st	Z, r22
     20a:	31 97       	sbiw	r30, 0x01	; 1
     20c:	69 e0       	ldi	r22, 0x09	; 9
     20e:	60 83       	st	Z, r22
     210:	31 97       	sbiw	r30, 0x01	; 1
     212:	60 e1       	ldi	r22, 0x10	; 16
     214:	60 83       	st	Z, r22
     216:	31 97       	sbiw	r30, 0x01	; 1
     218:	30 83       	st	Z, r19
     21a:	31 97       	sbiw	r30, 0x01	; 1
     21c:	32 e1       	ldi	r19, 0x12	; 18
     21e:	30 83       	st	Z, r19
     220:	31 97       	sbiw	r30, 0x01	; 1
     222:	33 e1       	ldi	r19, 0x13	; 19
     224:	30 83       	st	Z, r19
     226:	31 97       	sbiw	r30, 0x01	; 1
     228:	34 e1       	ldi	r19, 0x14	; 20
     22a:	30 83       	st	Z, r19
     22c:	31 97       	sbiw	r30, 0x01	; 1
     22e:	35 e1       	ldi	r19, 0x15	; 21
     230:	30 83       	st	Z, r19
     232:	31 97       	sbiw	r30, 0x01	; 1
     234:	36 e1       	ldi	r19, 0x16	; 22
     236:	30 83       	st	Z, r19
     238:	31 97       	sbiw	r30, 0x01	; 1
     23a:	37 e1       	ldi	r19, 0x17	; 23
     23c:	30 83       	st	Z, r19
     23e:	31 97       	sbiw	r30, 0x01	; 1
     240:	38 e1       	ldi	r19, 0x18	; 24
     242:	30 83       	st	Z, r19
     244:	31 97       	sbiw	r30, 0x01	; 1
     246:	39 e1       	ldi	r19, 0x19	; 25
     248:	30 83       	st	Z, r19
     24a:	31 97       	sbiw	r30, 0x01	; 1
     24c:	30 e2       	ldi	r19, 0x20	; 32
     24e:	30 83       	st	Z, r19
     250:	31 97       	sbiw	r30, 0x01	; 1
     252:	31 e2       	ldi	r19, 0x21	; 33
     254:	30 83       	st	Z, r19
     256:	31 97       	sbiw	r30, 0x01	; 1
     258:	20 83       	st	Z, r18
     25a:	31 97       	sbiw	r30, 0x01	; 1
     25c:	23 e2       	ldi	r18, 0x23	; 35
     25e:	20 83       	st	Z, r18
     260:	31 97       	sbiw	r30, 0x01	; 1
     262:	40 83       	st	Z, r20
     264:	31 97       	sbiw	r30, 0x01	; 1
     266:	50 83       	st	Z, r21
     268:	31 97       	sbiw	r30, 0x01	; 1
     26a:	26 e2       	ldi	r18, 0x26	; 38
     26c:	20 83       	st	Z, r18
     26e:	31 97       	sbiw	r30, 0x01	; 1
     270:	27 e2       	ldi	r18, 0x27	; 39
     272:	20 83       	st	Z, r18
     274:	31 97       	sbiw	r30, 0x01	; 1
     276:	28 e2       	ldi	r18, 0x28	; 40
     278:	20 83       	st	Z, r18
     27a:	31 97       	sbiw	r30, 0x01	; 1
     27c:	29 e2       	ldi	r18, 0x29	; 41
     27e:	20 83       	st	Z, r18
     280:	31 97       	sbiw	r30, 0x01	; 1
     282:	20 e3       	ldi	r18, 0x30	; 48
     284:	20 83       	st	Z, r18
     286:	31 97       	sbiw	r30, 0x01	; 1
     288:	21 e3       	ldi	r18, 0x31	; 49
     28a:	20 83       	st	Z, r18
     28c:	86 97       	sbiw	r24, 0x26	; 38
     28e:	08 95       	ret

00000290 <xPortStartScheduler>:
     290:	0e 94 d3 00 	call	0x1a6	; 0x1a6 <prvSetupTimerInterrupt>
     294:	a0 91 2b 07 	lds	r26, 0x072B	; 0x80072b <pxCurrentTCB>
     298:	b0 91 2c 07 	lds	r27, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     29c:	cd 91       	ld	r28, X+
     29e:	cd bf       	out	0x3d, r28	; 61
     2a0:	dd 91       	ld	r29, X+
     2a2:	de bf       	out	0x3e, r29	; 62
     2a4:	ff 91       	pop	r31
     2a6:	ef 91       	pop	r30
     2a8:	df 91       	pop	r29
     2aa:	cf 91       	pop	r28
     2ac:	bf 91       	pop	r27
     2ae:	af 91       	pop	r26
     2b0:	9f 91       	pop	r25
     2b2:	8f 91       	pop	r24
     2b4:	7f 91       	pop	r23
     2b6:	6f 91       	pop	r22
     2b8:	5f 91       	pop	r21
     2ba:	4f 91       	pop	r20
     2bc:	3f 91       	pop	r19
     2be:	2f 91       	pop	r18
     2c0:	1f 91       	pop	r17
     2c2:	0f 91       	pop	r16
     2c4:	ff 90       	pop	r15
     2c6:	ef 90       	pop	r14
     2c8:	df 90       	pop	r13
     2ca:	cf 90       	pop	r12
     2cc:	bf 90       	pop	r11
     2ce:	af 90       	pop	r10
     2d0:	9f 90       	pop	r9
     2d2:	8f 90       	pop	r8
     2d4:	7f 90       	pop	r7
     2d6:	6f 90       	pop	r6
     2d8:	5f 90       	pop	r5
     2da:	4f 90       	pop	r4
     2dc:	3f 90       	pop	r3
     2de:	2f 90       	pop	r2
     2e0:	1f 90       	pop	r1
     2e2:	0f 90       	pop	r0
     2e4:	0f be       	out	0x3f, r0	; 63
     2e6:	0f 90       	pop	r0
     2e8:	08 95       	ret
     2ea:	81 e0       	ldi	r24, 0x01	; 1
     2ec:	08 95       	ret

000002ee <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     2ee:	0f 92       	push	r0
     2f0:	0f b6       	in	r0, 0x3f	; 63
     2f2:	f8 94       	cli
     2f4:	0f 92       	push	r0
     2f6:	1f 92       	push	r1
     2f8:	11 24       	eor	r1, r1
     2fa:	2f 92       	push	r2
     2fc:	3f 92       	push	r3
     2fe:	4f 92       	push	r4
     300:	5f 92       	push	r5
     302:	6f 92       	push	r6
     304:	7f 92       	push	r7
     306:	8f 92       	push	r8
     308:	9f 92       	push	r9
     30a:	af 92       	push	r10
     30c:	bf 92       	push	r11
     30e:	cf 92       	push	r12
     310:	df 92       	push	r13
     312:	ef 92       	push	r14
     314:	ff 92       	push	r15
     316:	0f 93       	push	r16
     318:	1f 93       	push	r17
     31a:	2f 93       	push	r18
     31c:	3f 93       	push	r19
     31e:	4f 93       	push	r20
     320:	5f 93       	push	r21
     322:	6f 93       	push	r22
     324:	7f 93       	push	r23
     326:	8f 93       	push	r24
     328:	9f 93       	push	r25
     32a:	af 93       	push	r26
     32c:	bf 93       	push	r27
     32e:	cf 93       	push	r28
     330:	df 93       	push	r29
     332:	ef 93       	push	r30
     334:	ff 93       	push	r31
     336:	a0 91 2b 07 	lds	r26, 0x072B	; 0x80072b <pxCurrentTCB>
     33a:	b0 91 2c 07 	lds	r27, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     33e:	0d b6       	in	r0, 0x3d	; 61
     340:	0d 92       	st	X+, r0
     342:	0e b6       	in	r0, 0x3e	; 62
     344:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     346:	0e 94 c7 06 	call	0xd8e	; 0xd8e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     34a:	a0 91 2b 07 	lds	r26, 0x072B	; 0x80072b <pxCurrentTCB>
     34e:	b0 91 2c 07 	lds	r27, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     352:	cd 91       	ld	r28, X+
     354:	cd bf       	out	0x3d, r28	; 61
     356:	dd 91       	ld	r29, X+
     358:	de bf       	out	0x3e, r29	; 62
     35a:	ff 91       	pop	r31
     35c:	ef 91       	pop	r30
     35e:	df 91       	pop	r29
     360:	cf 91       	pop	r28
     362:	bf 91       	pop	r27
     364:	af 91       	pop	r26
     366:	9f 91       	pop	r25
     368:	8f 91       	pop	r24
     36a:	7f 91       	pop	r23
     36c:	6f 91       	pop	r22
     36e:	5f 91       	pop	r21
     370:	4f 91       	pop	r20
     372:	3f 91       	pop	r19
     374:	2f 91       	pop	r18
     376:	1f 91       	pop	r17
     378:	0f 91       	pop	r16
     37a:	ff 90       	pop	r15
     37c:	ef 90       	pop	r14
     37e:	df 90       	pop	r13
     380:	cf 90       	pop	r12
     382:	bf 90       	pop	r11
     384:	af 90       	pop	r10
     386:	9f 90       	pop	r9
     388:	8f 90       	pop	r8
     38a:	7f 90       	pop	r7
     38c:	6f 90       	pop	r6
     38e:	5f 90       	pop	r5
     390:	4f 90       	pop	r4
     392:	3f 90       	pop	r3
     394:	2f 90       	pop	r2
     396:	1f 90       	pop	r1
     398:	0f 90       	pop	r0
     39a:	0f be       	out	0x3f, r0	; 63
     39c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     39e:	08 95       	ret

000003a0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     3a0:	0f 92       	push	r0
     3a2:	0f b6       	in	r0, 0x3f	; 63
     3a4:	f8 94       	cli
     3a6:	0f 92       	push	r0
     3a8:	1f 92       	push	r1
     3aa:	11 24       	eor	r1, r1
     3ac:	2f 92       	push	r2
     3ae:	3f 92       	push	r3
     3b0:	4f 92       	push	r4
     3b2:	5f 92       	push	r5
     3b4:	6f 92       	push	r6
     3b6:	7f 92       	push	r7
     3b8:	8f 92       	push	r8
     3ba:	9f 92       	push	r9
     3bc:	af 92       	push	r10
     3be:	bf 92       	push	r11
     3c0:	cf 92       	push	r12
     3c2:	df 92       	push	r13
     3c4:	ef 92       	push	r14
     3c6:	ff 92       	push	r15
     3c8:	0f 93       	push	r16
     3ca:	1f 93       	push	r17
     3cc:	2f 93       	push	r18
     3ce:	3f 93       	push	r19
     3d0:	4f 93       	push	r20
     3d2:	5f 93       	push	r21
     3d4:	6f 93       	push	r22
     3d6:	7f 93       	push	r23
     3d8:	8f 93       	push	r24
     3da:	9f 93       	push	r25
     3dc:	af 93       	push	r26
     3de:	bf 93       	push	r27
     3e0:	cf 93       	push	r28
     3e2:	df 93       	push	r29
     3e4:	ef 93       	push	r30
     3e6:	ff 93       	push	r31
     3e8:	a0 91 2b 07 	lds	r26, 0x072B	; 0x80072b <pxCurrentTCB>
     3ec:	b0 91 2c 07 	lds	r27, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     3f0:	0d b6       	in	r0, 0x3d	; 61
     3f2:	0d 92       	st	X+, r0
     3f4:	0e b6       	in	r0, 0x3e	; 62
     3f6:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     3f8:	0e 94 5a 05 	call	0xab4	; 0xab4 <xTaskIncrementTick>
     3fc:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     3fe:	0e 94 c7 06 	call	0xd8e	; 0xd8e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     402:	a0 91 2b 07 	lds	r26, 0x072B	; 0x80072b <pxCurrentTCB>
     406:	b0 91 2c 07 	lds	r27, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     40a:	cd 91       	ld	r28, X+
     40c:	cd bf       	out	0x3d, r28	; 61
     40e:	dd 91       	ld	r29, X+
     410:	de bf       	out	0x3e, r29	; 62
     412:	ff 91       	pop	r31
     414:	ef 91       	pop	r30
     416:	df 91       	pop	r29
     418:	cf 91       	pop	r28
     41a:	bf 91       	pop	r27
     41c:	af 91       	pop	r26
     41e:	9f 91       	pop	r25
     420:	8f 91       	pop	r24
     422:	7f 91       	pop	r23
     424:	6f 91       	pop	r22
     426:	5f 91       	pop	r21
     428:	4f 91       	pop	r20
     42a:	3f 91       	pop	r19
     42c:	2f 91       	pop	r18
     42e:	1f 91       	pop	r17
     430:	0f 91       	pop	r16
     432:	ff 90       	pop	r15
     434:	ef 90       	pop	r14
     436:	df 90       	pop	r13
     438:	cf 90       	pop	r12
     43a:	bf 90       	pop	r11
     43c:	af 90       	pop	r10
     43e:	9f 90       	pop	r9
     440:	8f 90       	pop	r8
     442:	7f 90       	pop	r7
     444:	6f 90       	pop	r6
     446:	5f 90       	pop	r5
     448:	4f 90       	pop	r4
     44a:	3f 90       	pop	r3
     44c:	2f 90       	pop	r2
     44e:	1f 90       	pop	r1
     450:	0f 90       	pop	r0
     452:	0f be       	out	0x3f, r0	; 63
     454:	0f 90       	pop	r0

	asm volatile ( "ret" );
     456:	08 95       	ret

00000458 <__vector_7>:
	 * DeeThe: Changed from SIG_OUTPUT_COMPARE1A to TIMER1_COMPA_vect
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     458:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <vPortYieldFromTick>
		asm volatile ( "reti" );
     45c:	18 95       	reti

0000045e <prvHeapInit>:

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     45e:	ea ef       	ldi	r30, 0xFA	; 250
     460:	f0 e0       	ldi	r31, 0x00	; 0
     462:	ae ef       	ldi	r26, 0xFE	; 254
     464:	b0 e0       	ldi	r27, 0x00	; 0
     466:	b1 83       	std	Z+1, r27	; 0x01
     468:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
     46a:	13 82       	std	Z+3, r1	; 0x03
     46c:	12 82       	std	Z+2, r1	; 0x02

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
     46e:	e6 ed       	ldi	r30, 0xD6	; 214
     470:	f6 e0       	ldi	r31, 0x06	; 6
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
     472:	f0 93 f9 00 	sts	0x00F9, r31	; 0x8000f9 <pxEnd+0x1>
     476:	e0 93 f8 00 	sts	0x00F8, r30	; 0x8000f8 <pxEnd>
	pxEnd->xBlockSize = 0;
     47a:	13 82       	std	Z+3, r1	; 0x03
     47c:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
     47e:	11 82       	std	Z+1, r1	; 0x01
     480:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
     482:	88 ed       	ldi	r24, 0xD8	; 216
     484:	95 e0       	ldi	r25, 0x05	; 5
     486:	13 96       	adiw	r26, 0x03	; 3
     488:	9c 93       	st	X, r25
     48a:	8e 93       	st	-X, r24
     48c:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
     48e:	ed 93       	st	X+, r30
     490:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     492:	90 93 f5 00 	sts	0x00F5, r25	; 0x8000f5 <xMinimumEverFreeBytesRemaining+0x1>
     496:	80 93 f4 00 	sts	0x00F4, r24	; 0x8000f4 <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     49a:	90 93 f7 00 	sts	0x00F7, r25	; 0x8000f7 <xFreeBytesRemaining+0x1>
     49e:	80 93 f6 00 	sts	0x00F6, r24	; 0x8000f6 <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
     4a2:	80 e0       	ldi	r24, 0x00	; 0
     4a4:	90 e8       	ldi	r25, 0x80	; 128
     4a6:	90 93 f3 00 	sts	0x00F3, r25	; 0x8000f3 <__data_end+0x1>
     4aa:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__data_end>
     4ae:	08 95       	ret

000004b0 <prvInsertBlockIntoFreeList>:
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
     4b0:	cf 93       	push	r28
     4b2:	df 93       	push	r29
     4b4:	ec 01       	movw	r28, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     4b6:	aa ef       	ldi	r26, 0xFA	; 250
     4b8:	b0 e0       	ldi	r27, 0x00	; 0
     4ba:	01 c0       	rjmp	.+2      	; 0x4be <prvInsertBlockIntoFreeList+0xe>
     4bc:	df 01       	movw	r26, r30
     4be:	ed 91       	ld	r30, X+
     4c0:	fc 91       	ld	r31, X
     4c2:	11 97       	sbiw	r26, 0x01	; 1
     4c4:	ec 17       	cp	r30, r28
     4c6:	fd 07       	cpc	r31, r29
     4c8:	c8 f3       	brcs	.-14     	; 0x4bc <prvInsertBlockIntoFreeList+0xc>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
     4ca:	12 96       	adiw	r26, 0x02	; 2
     4cc:	8d 91       	ld	r24, X+
     4ce:	9c 91       	ld	r25, X
     4d0:	13 97       	sbiw	r26, 0x03	; 3
     4d2:	9d 01       	movw	r18, r26
     4d4:	28 0f       	add	r18, r24
     4d6:	39 1f       	adc	r19, r25
     4d8:	c2 17       	cp	r28, r18
     4da:	d3 07       	cpc	r29, r19
     4dc:	49 f4       	brne	.+18     	; 0x4f0 <prvInsertBlockIntoFreeList+0x40>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
     4de:	2a 81       	ldd	r18, Y+2	; 0x02
     4e0:	3b 81       	ldd	r19, Y+3	; 0x03
     4e2:	82 0f       	add	r24, r18
     4e4:	93 1f       	adc	r25, r19
     4e6:	13 96       	adiw	r26, 0x03	; 3
     4e8:	9c 93       	st	X, r25
     4ea:	8e 93       	st	-X, r24
     4ec:	12 97       	sbiw	r26, 0x02	; 2
		pxBlockToInsert = pxIterator;
     4ee:	ed 01       	movw	r28, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     4f0:	8a 81       	ldd	r24, Y+2	; 0x02
     4f2:	9b 81       	ldd	r25, Y+3	; 0x03
     4f4:	9e 01       	movw	r18, r28
     4f6:	28 0f       	add	r18, r24
     4f8:	39 1f       	adc	r19, r25
     4fa:	e2 17       	cp	r30, r18
     4fc:	f3 07       	cpc	r31, r19
     4fe:	c1 f4       	brne	.+48     	; 0x530 <prvInsertBlockIntoFreeList+0x80>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
     500:	20 91 f8 00 	lds	r18, 0x00F8	; 0x8000f8 <pxEnd>
     504:	30 91 f9 00 	lds	r19, 0x00F9	; 0x8000f9 <pxEnd+0x1>
     508:	e2 17       	cp	r30, r18
     50a:	f3 07       	cpc	r31, r19
     50c:	71 f0       	breq	.+28     	; 0x52a <prvInsertBlockIntoFreeList+0x7a>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
     50e:	22 81       	ldd	r18, Z+2	; 0x02
     510:	33 81       	ldd	r19, Z+3	; 0x03
     512:	82 0f       	add	r24, r18
     514:	93 1f       	adc	r25, r19
     516:	9b 83       	std	Y+3, r25	; 0x03
     518:	8a 83       	std	Y+2, r24	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
     51a:	ed 91       	ld	r30, X+
     51c:	fc 91       	ld	r31, X
     51e:	11 97       	sbiw	r26, 0x01	; 1
     520:	80 81       	ld	r24, Z
     522:	91 81       	ldd	r25, Z+1	; 0x01
     524:	99 83       	std	Y+1, r25	; 0x01
     526:	88 83       	st	Y, r24
     528:	05 c0       	rjmp	.+10     	; 0x534 <prvInsertBlockIntoFreeList+0x84>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
     52a:	39 83       	std	Y+1, r19	; 0x01
     52c:	28 83       	st	Y, r18
     52e:	02 c0       	rjmp	.+4      	; 0x534 <prvInsertBlockIntoFreeList+0x84>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
     530:	f9 83       	std	Y+1, r31	; 0x01
     532:	e8 83       	st	Y, r30

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
     534:	ca 17       	cp	r28, r26
     536:	db 07       	cpc	r29, r27
     538:	11 f0       	breq	.+4      	; 0x53e <prvInsertBlockIntoFreeList+0x8e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
     53a:	cd 93       	st	X+, r28
     53c:	dc 93       	st	X, r29
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
     53e:	df 91       	pop	r29
     540:	cf 91       	pop	r28
     542:	08 95       	ret

00000544 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     544:	ef 92       	push	r14
     546:	ff 92       	push	r15
     548:	0f 93       	push	r16
     54a:	1f 93       	push	r17
     54c:	cf 93       	push	r28
     54e:	df 93       	push	r29
     550:	8c 01       	movw	r16, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
     552:	0e 94 4a 05 	call	0xa94	; 0xa94 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
     556:	80 91 f8 00 	lds	r24, 0x00F8	; 0x8000f8 <pxEnd>
     55a:	90 91 f9 00 	lds	r25, 0x00F9	; 0x8000f9 <pxEnd+0x1>
     55e:	89 2b       	or	r24, r25
     560:	11 f4       	brne	.+4      	; 0x566 <pvPortMalloc+0x22>
		{
			prvHeapInit();
     562:	0e 94 2f 02 	call	0x45e	; 0x45e <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
     566:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__data_end>
     56a:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__data_end+0x1>
     56e:	80 23       	and	r24, r16
     570:	91 23       	and	r25, r17
     572:	89 2b       	or	r24, r25
     574:	09 f0       	breq	.+2      	; 0x578 <pvPortMalloc+0x34>
     576:	67 c0       	rjmp	.+206    	; 0x646 <pvPortMalloc+0x102>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
     578:	01 15       	cp	r16, r1
     57a:	11 05       	cpc	r17, r1
     57c:	11 f0       	breq	.+4      	; 0x582 <pvPortMalloc+0x3e>
			{
				xWantedSize += xHeapStructSize;
     57e:	0c 5f       	subi	r16, 0xFC	; 252
     580:	1f 4f       	sbci	r17, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
     582:	01 15       	cp	r16, r1
     584:	11 05       	cpc	r17, r1
     586:	09 f4       	brne	.+2      	; 0x58a <pvPortMalloc+0x46>
     588:	61 c0       	rjmp	.+194    	; 0x64c <pvPortMalloc+0x108>
     58a:	80 91 f6 00 	lds	r24, 0x00F6	; 0x8000f6 <xFreeBytesRemaining>
     58e:	90 91 f7 00 	lds	r25, 0x00F7	; 0x8000f7 <xFreeBytesRemaining+0x1>
     592:	80 17       	cp	r24, r16
     594:	91 07       	cpc	r25, r17
     596:	08 f4       	brcc	.+2      	; 0x59a <pvPortMalloc+0x56>
     598:	5c c0       	rjmp	.+184    	; 0x652 <pvPortMalloc+0x10e>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
     59a:	c0 91 fa 00 	lds	r28, 0x00FA	; 0x8000fa <xStart>
     59e:	d0 91 fb 00 	lds	r29, 0x00FB	; 0x8000fb <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
     5a2:	ea ef       	ldi	r30, 0xFA	; 250
     5a4:	f0 e0       	ldi	r31, 0x00	; 0
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     5a6:	02 c0       	rjmp	.+4      	; 0x5ac <pvPortMalloc+0x68>
				{
					pxPreviousBlock = pxBlock;
     5a8:	fe 01       	movw	r30, r28
					pxBlock = pxBlock->pxNextFreeBlock;
     5aa:	ec 01       	movw	r28, r24
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     5ac:	8a 81       	ldd	r24, Y+2	; 0x02
     5ae:	9b 81       	ldd	r25, Y+3	; 0x03
     5b0:	80 17       	cp	r24, r16
     5b2:	91 07       	cpc	r25, r17
     5b4:	20 f4       	brcc	.+8      	; 0x5be <pvPortMalloc+0x7a>
     5b6:	88 81       	ld	r24, Y
     5b8:	99 81       	ldd	r25, Y+1	; 0x01
     5ba:	00 97       	sbiw	r24, 0x00	; 0
     5bc:	a9 f7       	brne	.-22     	; 0x5a8 <pvPortMalloc+0x64>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
     5be:	80 91 f8 00 	lds	r24, 0x00F8	; 0x8000f8 <pxEnd>
     5c2:	90 91 f9 00 	lds	r25, 0x00F9	; 0x8000f9 <pxEnd+0x1>
     5c6:	c8 17       	cp	r28, r24
     5c8:	d9 07       	cpc	r29, r25
     5ca:	09 f4       	brne	.+2      	; 0x5ce <pvPortMalloc+0x8a>
     5cc:	45 c0       	rjmp	.+138    	; 0x658 <pvPortMalloc+0x114>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     5ce:	e0 80       	ld	r14, Z
     5d0:	f1 80       	ldd	r15, Z+1	; 0x01
     5d2:	84 e0       	ldi	r24, 0x04	; 4
     5d4:	e8 0e       	add	r14, r24
     5d6:	f1 1c       	adc	r15, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     5d8:	88 81       	ld	r24, Y
     5da:	99 81       	ldd	r25, Y+1	; 0x01
     5dc:	91 83       	std	Z+1, r25	; 0x01
     5de:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     5e0:	2a 81       	ldd	r18, Y+2	; 0x02
     5e2:	3b 81       	ldd	r19, Y+3	; 0x03
     5e4:	20 1b       	sub	r18, r16
     5e6:	31 0b       	sbc	r19, r17
     5e8:	29 30       	cpi	r18, 0x09	; 9
     5ea:	31 05       	cpc	r19, r1
     5ec:	50 f0       	brcs	.+20     	; 0x602 <pvPortMalloc+0xbe>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     5ee:	ce 01       	movw	r24, r28
     5f0:	80 0f       	add	r24, r16
     5f2:	91 1f       	adc	r25, r17
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     5f4:	fc 01       	movw	r30, r24
     5f6:	33 83       	std	Z+3, r19	; 0x03
     5f8:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
     5fa:	1b 83       	std	Y+3, r17	; 0x03
     5fc:	0a 83       	std	Y+2, r16	; 0x02

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
     5fe:	0e 94 58 02 	call	0x4b0	; 0x4b0 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
     602:	2a 81       	ldd	r18, Y+2	; 0x02
     604:	3b 81       	ldd	r19, Y+3	; 0x03
     606:	80 91 f6 00 	lds	r24, 0x00F6	; 0x8000f6 <xFreeBytesRemaining>
     60a:	90 91 f7 00 	lds	r25, 0x00F7	; 0x8000f7 <xFreeBytesRemaining+0x1>
     60e:	82 1b       	sub	r24, r18
     610:	93 0b       	sbc	r25, r19
     612:	90 93 f7 00 	sts	0x00F7, r25	; 0x8000f7 <xFreeBytesRemaining+0x1>
     616:	80 93 f6 00 	sts	0x00F6, r24	; 0x8000f6 <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
     61a:	40 91 f4 00 	lds	r20, 0x00F4	; 0x8000f4 <xMinimumEverFreeBytesRemaining>
     61e:	50 91 f5 00 	lds	r21, 0x00F5	; 0x8000f5 <xMinimumEverFreeBytesRemaining+0x1>
     622:	84 17       	cp	r24, r20
     624:	95 07       	cpc	r25, r21
     626:	20 f4       	brcc	.+8      	; 0x630 <pvPortMalloc+0xec>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
     628:	90 93 f5 00 	sts	0x00F5, r25	; 0x8000f5 <xMinimumEverFreeBytesRemaining+0x1>
     62c:	80 93 f4 00 	sts	0x00F4, r24	; 0x8000f4 <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
     630:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__data_end>
     634:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__data_end+0x1>
     638:	28 2b       	or	r18, r24
     63a:	39 2b       	or	r19, r25
     63c:	3b 83       	std	Y+3, r19	; 0x03
     63e:	2a 83       	std	Y+2, r18	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
     640:	19 82       	std	Y+1, r1	; 0x01
     642:	18 82       	st	Y, r1
     644:	0b c0       	rjmp	.+22     	; 0x65c <pvPortMalloc+0x118>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
     646:	e1 2c       	mov	r14, r1
     648:	f1 2c       	mov	r15, r1
     64a:	08 c0       	rjmp	.+16     	; 0x65c <pvPortMalloc+0x118>
     64c:	e1 2c       	mov	r14, r1
     64e:	f1 2c       	mov	r15, r1
     650:	05 c0       	rjmp	.+10     	; 0x65c <pvPortMalloc+0x118>
     652:	e1 2c       	mov	r14, r1
     654:	f1 2c       	mov	r15, r1
     656:	02 c0       	rjmp	.+4      	; 0x65c <pvPortMalloc+0x118>
     658:	e1 2c       	mov	r14, r1
     65a:	f1 2c       	mov	r15, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     65c:	0e 94 14 06 	call	0xc28	; 0xc28 <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
     660:	c7 01       	movw	r24, r14
     662:	df 91       	pop	r29
     664:	cf 91       	pop	r28
     666:	1f 91       	pop	r17
     668:	0f 91       	pop	r16
     66a:	ff 90       	pop	r15
     66c:	ef 90       	pop	r14
     66e:	08 95       	ret

00000670 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     670:	0f 93       	push	r16
     672:	1f 93       	push	r17
     674:	cf 93       	push	r28
     676:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     678:	00 97       	sbiw	r24, 0x00	; 0
     67a:	51 f1       	breq	.+84     	; 0x6d0 <vPortFree+0x60>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
     67c:	ec 01       	movw	r28, r24
     67e:	24 97       	sbiw	r28, 0x04	; 4

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
     680:	4a 81       	ldd	r20, Y+2	; 0x02
     682:	5b 81       	ldd	r21, Y+3	; 0x03
     684:	20 91 f2 00 	lds	r18, 0x00F2	; 0x8000f2 <__data_end>
     688:	30 91 f3 00 	lds	r19, 0x00F3	; 0x8000f3 <__data_end+0x1>
     68c:	ba 01       	movw	r22, r20
     68e:	62 23       	and	r22, r18
     690:	73 23       	and	r23, r19
     692:	67 2b       	or	r22, r23
     694:	e9 f0       	breq	.+58     	; 0x6d0 <vPortFree+0x60>
		{
			if( pxLink->pxNextFreeBlock == NULL )
     696:	68 81       	ld	r22, Y
     698:	79 81       	ldd	r23, Y+1	; 0x01
     69a:	67 2b       	or	r22, r23
     69c:	c9 f4       	brne	.+50     	; 0x6d0 <vPortFree+0x60>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
     69e:	20 95       	com	r18
     6a0:	30 95       	com	r19
     6a2:	24 23       	and	r18, r20
     6a4:	35 23       	and	r19, r21
     6a6:	3b 83       	std	Y+3, r19	; 0x03
     6a8:	2a 83       	std	Y+2, r18	; 0x02

				vTaskSuspendAll();
     6aa:	0e 94 4a 05 	call	0xa94	; 0xa94 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
     6ae:	8a 81       	ldd	r24, Y+2	; 0x02
     6b0:	9b 81       	ldd	r25, Y+3	; 0x03
     6b2:	20 91 f6 00 	lds	r18, 0x00F6	; 0x8000f6 <xFreeBytesRemaining>
     6b6:	30 91 f7 00 	lds	r19, 0x00F7	; 0x8000f7 <xFreeBytesRemaining+0x1>
     6ba:	82 0f       	add	r24, r18
     6bc:	93 1f       	adc	r25, r19
     6be:	90 93 f7 00 	sts	0x00F7, r25	; 0x8000f7 <xFreeBytesRemaining+0x1>
     6c2:	80 93 f6 00 	sts	0x00F6, r24	; 0x8000f6 <xFreeBytesRemaining>
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     6c6:	ce 01       	movw	r24, r28
     6c8:	0e 94 58 02 	call	0x4b0	; 0x4b0 <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
     6cc:	0e 94 14 06 	call	0xc28	; 0xc28 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     6d0:	df 91       	pop	r29
     6d2:	cf 91       	pop	r28
     6d4:	1f 91       	pop	r17
     6d6:	0f 91       	pop	r16
     6d8:	08 95       	ret

000006da <prvResetNextTaskUnblockTime>:
	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     6da:	e0 91 f3 06 	lds	r30, 0x06F3	; 0x8006f3 <pxDelayedTaskList>
     6de:	f0 91 f4 06 	lds	r31, 0x06F4	; 0x8006f4 <pxDelayedTaskList+0x1>
     6e2:	80 81       	ld	r24, Z
     6e4:	81 11       	cpse	r24, r1
     6e6:	07 c0       	rjmp	.+14     	; 0x6f6 <prvResetNextTaskUnblockTime+0x1c>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	9f ef       	ldi	r25, 0xFF	; 255
     6ec:	90 93 de 06 	sts	0x06DE, r25	; 0x8006de <xNextTaskUnblockTime+0x1>
     6f0:	80 93 dd 06 	sts	0x06DD, r24	; 0x8006dd <xNextTaskUnblockTime>
     6f4:	08 95       	ret
     6f6:	e0 91 f3 06 	lds	r30, 0x06F3	; 0x8006f3 <pxDelayedTaskList>
     6fa:	f0 91 f4 06 	lds	r31, 0x06F4	; 0x8006f4 <pxDelayedTaskList+0x1>
     6fe:	05 80       	ldd	r0, Z+5	; 0x05
     700:	f6 81       	ldd	r31, Z+6	; 0x06
     702:	e0 2d       	mov	r30, r0
     704:	06 80       	ldd	r0, Z+6	; 0x06
     706:	f7 81       	ldd	r31, Z+7	; 0x07
     708:	e0 2d       	mov	r30, r0
     70a:	82 81       	ldd	r24, Z+2	; 0x02
     70c:	93 81       	ldd	r25, Z+3	; 0x03
     70e:	90 93 de 06 	sts	0x06DE, r25	; 0x8006de <xNextTaskUnblockTime+0x1>
     712:	80 93 dd 06 	sts	0x06DD, r24	; 0x8006dd <xNextTaskUnblockTime>
     716:	08 95       	ret

00000718 <prvInitialiseNewTask>:
     718:	6f 92       	push	r6
     71a:	7f 92       	push	r7
     71c:	8f 92       	push	r8
     71e:	9f 92       	push	r9
     720:	af 92       	push	r10
     722:	bf 92       	push	r11
     724:	cf 92       	push	r12
     726:	df 92       	push	r13
     728:	ef 92       	push	r14
     72a:	0f 93       	push	r16
     72c:	1f 93       	push	r17
     72e:	cf 93       	push	r28
     730:	df 93       	push	r29
     732:	cd b7       	in	r28, 0x3d	; 61
     734:	de b7       	in	r29, 0x3e	; 62
     736:	4c 01       	movw	r8, r24
     738:	f5 01       	movw	r30, r10
     73a:	87 89       	ldd	r24, Z+23	; 0x17
     73c:	90 8d       	ldd	r25, Z+24	; 0x18
     73e:	21 50       	subi	r18, 0x01	; 1
     740:	31 09       	sbc	r19, r1
     742:	3c 01       	movw	r6, r24
     744:	62 0e       	add	r6, r18
     746:	73 1e       	adc	r7, r19
     748:	20 e0       	ldi	r18, 0x00	; 0
     74a:	0f c0       	rjmp	.+30     	; 0x76a <prvInitialiseNewTask+0x52>
     74c:	82 2f       	mov	r24, r18
     74e:	90 e0       	ldi	r25, 0x00	; 0
     750:	fb 01       	movw	r30, r22
     752:	e8 0f       	add	r30, r24
     754:	f9 1f       	adc	r31, r25
     756:	30 81       	ld	r19, Z
     758:	d5 01       	movw	r26, r10
     75a:	a8 0f       	add	r26, r24
     75c:	b9 1f       	adc	r27, r25
     75e:	59 96       	adiw	r26, 0x19	; 25
     760:	3c 93       	st	X, r19
     762:	80 81       	ld	r24, Z
     764:	88 23       	and	r24, r24
     766:	19 f0       	breq	.+6      	; 0x76e <prvInitialiseNewTask+0x56>
     768:	2f 5f       	subi	r18, 0xFF	; 255
     76a:	28 30       	cpi	r18, 0x08	; 8
     76c:	78 f3       	brcs	.-34     	; 0x74c <prvInitialiseNewTask+0x34>
     76e:	f5 01       	movw	r30, r10
     770:	10 a2       	std	Z+32, r1	; 0x20
     772:	f3 e0       	ldi	r31, 0x03	; 3
     774:	fe 15       	cp	r31, r14
     776:	20 f4       	brcc	.+8      	; 0x780 <prvInitialiseNewTask+0x68>
     778:	0f 2e       	mov	r0, r31
     77a:	f3 e0       	ldi	r31, 0x03	; 3
     77c:	ef 2e       	mov	r14, r31
     77e:	f0 2d       	mov	r31, r0
     780:	f5 01       	movw	r30, r10
     782:	e6 8a       	std	Z+22, r14	; 0x16
     784:	c5 01       	movw	r24, r10
     786:	02 96       	adiw	r24, 0x02	; 2
     788:	0e 94 57 00 	call	0xae	; 0xae <vListInitialiseItem>
     78c:	c5 01       	movw	r24, r10
     78e:	0c 96       	adiw	r24, 0x0c	; 12
     790:	0e 94 57 00 	call	0xae	; 0xae <vListInitialiseItem>
     794:	f5 01       	movw	r30, r10
     796:	b1 86       	std	Z+9, r11	; 0x09
     798:	a0 86       	std	Z+8, r10	; 0x08
     79a:	84 e0       	ldi	r24, 0x04	; 4
     79c:	90 e0       	ldi	r25, 0x00	; 0
     79e:	8e 19       	sub	r24, r14
     7a0:	91 09       	sbc	r25, r1
     7a2:	95 87       	std	Z+13, r25	; 0x0d
     7a4:	84 87       	std	Z+12, r24	; 0x0c
     7a6:	b3 8a       	std	Z+19, r11	; 0x13
     7a8:	a2 8a       	std	Z+18, r10	; 0x12
     7aa:	11 a2       	std	Z+33, r1	; 0x21
     7ac:	12 a2       	std	Z+34, r1	; 0x22
     7ae:	13 a2       	std	Z+35, r1	; 0x23
     7b0:	14 a2       	std	Z+36, r1	; 0x24
     7b2:	15 a2       	std	Z+37, r1	; 0x25
     7b4:	a8 01       	movw	r20, r16
     7b6:	b4 01       	movw	r22, r8
     7b8:	c3 01       	movw	r24, r6
     7ba:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <pxPortInitialiseStack>
     7be:	f5 01       	movw	r30, r10
     7c0:	91 83       	std	Z+1, r25	; 0x01
     7c2:	80 83       	st	Z, r24
     7c4:	c1 14       	cp	r12, r1
     7c6:	d1 04       	cpc	r13, r1
     7c8:	19 f0       	breq	.+6      	; 0x7d0 <prvInitialiseNewTask+0xb8>
     7ca:	f6 01       	movw	r30, r12
     7cc:	b1 82       	std	Z+1, r11	; 0x01
     7ce:	a0 82       	st	Z, r10
     7d0:	df 91       	pop	r29
     7d2:	cf 91       	pop	r28
     7d4:	1f 91       	pop	r17
     7d6:	0f 91       	pop	r16
     7d8:	ef 90       	pop	r14
     7da:	df 90       	pop	r13
     7dc:	cf 90       	pop	r12
     7de:	bf 90       	pop	r11
     7e0:	af 90       	pop	r10
     7e2:	9f 90       	pop	r9
     7e4:	8f 90       	pop	r8
     7e6:	7f 90       	pop	r7
     7e8:	6f 90       	pop	r6
     7ea:	08 95       	ret

000007ec <prvIdleTask>:
     7ec:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <pxReadyTasksLists>
     7f0:	82 30       	cpi	r24, 0x02	; 2
     7f2:	e0 f3       	brcs	.-8      	; 0x7ec <prvIdleTask>
     7f4:	0e 94 77 01 	call	0x2ee	; 0x2ee <vPortYield>
     7f8:	f9 cf       	rjmp	.-14     	; 0x7ec <prvIdleTask>

000007fa <prvInitialiseTaskLists>:
     7fa:	cf 93       	push	r28
     7fc:	c0 e0       	ldi	r28, 0x00	; 0
     7fe:	10 c0       	rjmp	.+32     	; 0x820 <__DATA_REGION_LENGTH__+0x20>
     800:	8c 2f       	mov	r24, r28
     802:	90 e0       	ldi	r25, 0x00	; 0
     804:	9c 01       	movw	r18, r24
     806:	22 0f       	add	r18, r18
     808:	33 1f       	adc	r19, r19
     80a:	22 0f       	add	r18, r18
     80c:	33 1f       	adc	r19, r19
     80e:	22 0f       	add	r18, r18
     810:	33 1f       	adc	r19, r19
     812:	82 0f       	add	r24, r18
     814:	93 1f       	adc	r25, r19
     816:	89 5f       	subi	r24, 0xF9	; 249
     818:	98 4f       	sbci	r25, 0xF8	; 248
     81a:	0e 94 49 00 	call	0x92	; 0x92 <vListInitialise>
     81e:	cf 5f       	subi	r28, 0xFF	; 255
     820:	c4 30       	cpi	r28, 0x04	; 4
     822:	70 f3       	brcs	.-36     	; 0x800 <__DATA_REGION_LENGTH__>
     824:	8e ef       	ldi	r24, 0xFE	; 254
     826:	96 e0       	ldi	r25, 0x06	; 6
     828:	0e 94 49 00 	call	0x92	; 0x92 <vListInitialise>
     82c:	85 ef       	ldi	r24, 0xF5	; 245
     82e:	96 e0       	ldi	r25, 0x06	; 6
     830:	0e 94 49 00 	call	0x92	; 0x92 <vListInitialise>
     834:	88 ee       	ldi	r24, 0xE8	; 232
     836:	96 e0       	ldi	r25, 0x06	; 6
     838:	0e 94 49 00 	call	0x92	; 0x92 <vListInitialise>
     83c:	8e ef       	ldi	r24, 0xFE	; 254
     83e:	96 e0       	ldi	r25, 0x06	; 6
     840:	90 93 f4 06 	sts	0x06F4, r25	; 0x8006f4 <pxDelayedTaskList+0x1>
     844:	80 93 f3 06 	sts	0x06F3, r24	; 0x8006f3 <pxDelayedTaskList>
     848:	85 ef       	ldi	r24, 0xF5	; 245
     84a:	96 e0       	ldi	r25, 0x06	; 6
     84c:	90 93 f2 06 	sts	0x06F2, r25	; 0x8006f2 <pxOverflowDelayedTaskList+0x1>
     850:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <pxOverflowDelayedTaskList>
     854:	cf 91       	pop	r28
     856:	08 95       	ret

00000858 <prvAddNewTaskToReadyList>:
     858:	cf 93       	push	r28
     85a:	df 93       	push	r29
     85c:	ec 01       	movw	r28, r24
     85e:	0f b6       	in	r0, 0x3f	; 63
     860:	f8 94       	cli
     862:	0f 92       	push	r0
     864:	80 91 e7 06 	lds	r24, 0x06E7	; 0x8006e7 <uxCurrentNumberOfTasks>
     868:	8f 5f       	subi	r24, 0xFF	; 255
     86a:	80 93 e7 06 	sts	0x06E7, r24	; 0x8006e7 <uxCurrentNumberOfTasks>
     86e:	80 91 2b 07 	lds	r24, 0x072B	; 0x80072b <pxCurrentTCB>
     872:	90 91 2c 07 	lds	r25, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     876:	89 2b       	or	r24, r25
     878:	59 f4       	brne	.+22     	; 0x890 <__stack+0x31>
     87a:	d0 93 2c 07 	sts	0x072C, r29	; 0x80072c <pxCurrentTCB+0x1>
     87e:	c0 93 2b 07 	sts	0x072B, r28	; 0x80072b <pxCurrentTCB>
     882:	80 91 e7 06 	lds	r24, 0x06E7	; 0x8006e7 <uxCurrentNumberOfTasks>
     886:	81 30       	cpi	r24, 0x01	; 1
     888:	99 f4       	brne	.+38     	; 0x8b0 <__stack+0x51>
     88a:	0e 94 fd 03 	call	0x7fa	; 0x7fa <prvInitialiseTaskLists>
     88e:	10 c0       	rjmp	.+32     	; 0x8b0 <__stack+0x51>
     890:	80 91 e3 06 	lds	r24, 0x06E3	; 0x8006e3 <xSchedulerRunning>
     894:	81 11       	cpse	r24, r1
     896:	0c c0       	rjmp	.+24     	; 0x8b0 <__stack+0x51>
     898:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxCurrentTCB>
     89c:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     8a0:	96 89       	ldd	r25, Z+22	; 0x16
     8a2:	8e 89       	ldd	r24, Y+22	; 0x16
     8a4:	89 17       	cp	r24, r25
     8a6:	20 f0       	brcs	.+8      	; 0x8b0 <__stack+0x51>
     8a8:	d0 93 2c 07 	sts	0x072C, r29	; 0x80072c <pxCurrentTCB+0x1>
     8ac:	c0 93 2b 07 	sts	0x072B, r28	; 0x80072b <pxCurrentTCB>
     8b0:	80 91 df 06 	lds	r24, 0x06DF	; 0x8006df <uxTaskNumber>
     8b4:	8f 5f       	subi	r24, 0xFF	; 255
     8b6:	80 93 df 06 	sts	0x06DF, r24	; 0x8006df <uxTaskNumber>
     8ba:	8e 89       	ldd	r24, Y+22	; 0x16
     8bc:	90 91 e4 06 	lds	r25, 0x06E4	; 0x8006e4 <uxTopReadyPriority>
     8c0:	98 17       	cp	r25, r24
     8c2:	10 f4       	brcc	.+4      	; 0x8c8 <__stack+0x69>
     8c4:	80 93 e4 06 	sts	0x06E4, r24	; 0x8006e4 <uxTopReadyPriority>
     8c8:	90 e0       	ldi	r25, 0x00	; 0
     8ca:	9c 01       	movw	r18, r24
     8cc:	22 0f       	add	r18, r18
     8ce:	33 1f       	adc	r19, r19
     8d0:	22 0f       	add	r18, r18
     8d2:	33 1f       	adc	r19, r19
     8d4:	22 0f       	add	r18, r18
     8d6:	33 1f       	adc	r19, r19
     8d8:	82 0f       	add	r24, r18
     8da:	93 1f       	adc	r25, r19
     8dc:	be 01       	movw	r22, r28
     8de:	6e 5f       	subi	r22, 0xFE	; 254
     8e0:	7f 4f       	sbci	r23, 0xFF	; 255
     8e2:	89 5f       	subi	r24, 0xF9	; 249
     8e4:	98 4f       	sbci	r25, 0xF8	; 248
     8e6:	0e 94 5b 00 	call	0xb6	; 0xb6 <vListInsertEnd>
     8ea:	0f 90       	pop	r0
     8ec:	0f be       	out	0x3f, r0	; 63
     8ee:	80 91 e3 06 	lds	r24, 0x06E3	; 0x8006e3 <xSchedulerRunning>
     8f2:	88 23       	and	r24, r24
     8f4:	51 f0       	breq	.+20     	; 0x90a <__stack+0xab>
     8f6:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxCurrentTCB>
     8fa:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     8fe:	96 89       	ldd	r25, Z+22	; 0x16
     900:	8e 89       	ldd	r24, Y+22	; 0x16
     902:	98 17       	cp	r25, r24
     904:	10 f4       	brcc	.+4      	; 0x90a <__stack+0xab>
     906:	0e 94 77 01 	call	0x2ee	; 0x2ee <vPortYield>
     90a:	df 91       	pop	r29
     90c:	cf 91       	pop	r28
     90e:	08 95       	ret

00000910 <prvAddCurrentTaskToDelayedList>:
     910:	0f 93       	push	r16
     912:	1f 93       	push	r17
     914:	cf 93       	push	r28
     916:	df 93       	push	r29
     918:	ec 01       	movw	r28, r24
     91a:	00 91 e5 06 	lds	r16, 0x06E5	; 0x8006e5 <xTickCount>
     91e:	10 91 e6 06 	lds	r17, 0x06E6	; 0x8006e6 <xTickCount+0x1>
     922:	80 91 2b 07 	lds	r24, 0x072B	; 0x80072b <pxCurrentTCB>
     926:	90 91 2c 07 	lds	r25, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     92a:	02 96       	adiw	r24, 0x02	; 2
     92c:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>
     930:	c0 0f       	add	r28, r16
     932:	d1 1f       	adc	r29, r17
     934:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxCurrentTCB>
     938:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     93c:	d3 83       	std	Z+3, r29	; 0x03
     93e:	c2 83       	std	Z+2, r28	; 0x02
     940:	c0 17       	cp	r28, r16
     942:	d1 07       	cpc	r29, r17
     944:	68 f4       	brcc	.+26     	; 0x960 <prvAddCurrentTaskToDelayedList+0x50>
     946:	60 91 2b 07 	lds	r22, 0x072B	; 0x80072b <pxCurrentTCB>
     94a:	70 91 2c 07 	lds	r23, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     94e:	80 91 f1 06 	lds	r24, 0x06F1	; 0x8006f1 <pxOverflowDelayedTaskList>
     952:	90 91 f2 06 	lds	r25, 0x06F2	; 0x8006f2 <pxOverflowDelayedTaskList+0x1>
     956:	6e 5f       	subi	r22, 0xFE	; 254
     958:	7f 4f       	sbci	r23, 0xFF	; 255
     95a:	0e 94 7c 00 	call	0xf8	; 0xf8 <vListInsert>
     95e:	17 c0       	rjmp	.+46     	; 0x98e <prvAddCurrentTaskToDelayedList+0x7e>
     960:	60 91 2b 07 	lds	r22, 0x072B	; 0x80072b <pxCurrentTCB>
     964:	70 91 2c 07 	lds	r23, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     968:	80 91 f3 06 	lds	r24, 0x06F3	; 0x8006f3 <pxDelayedTaskList>
     96c:	90 91 f4 06 	lds	r25, 0x06F4	; 0x8006f4 <pxDelayedTaskList+0x1>
     970:	6e 5f       	subi	r22, 0xFE	; 254
     972:	7f 4f       	sbci	r23, 0xFF	; 255
     974:	0e 94 7c 00 	call	0xf8	; 0xf8 <vListInsert>
     978:	80 91 dd 06 	lds	r24, 0x06DD	; 0x8006dd <xNextTaskUnblockTime>
     97c:	90 91 de 06 	lds	r25, 0x06DE	; 0x8006de <xNextTaskUnblockTime+0x1>
     980:	c8 17       	cp	r28, r24
     982:	d9 07       	cpc	r29, r25
     984:	20 f4       	brcc	.+8      	; 0x98e <prvAddCurrentTaskToDelayedList+0x7e>
     986:	d0 93 de 06 	sts	0x06DE, r29	; 0x8006de <xNextTaskUnblockTime+0x1>
     98a:	c0 93 dd 06 	sts	0x06DD, r28	; 0x8006dd <xNextTaskUnblockTime>
     98e:	df 91       	pop	r29
     990:	cf 91       	pop	r28
     992:	1f 91       	pop	r17
     994:	0f 91       	pop	r16
     996:	08 95       	ret

00000998 <xTaskCreate>:
     998:	2f 92       	push	r2
     99a:	3f 92       	push	r3
     99c:	4f 92       	push	r4
     99e:	5f 92       	push	r5
     9a0:	6f 92       	push	r6
     9a2:	7f 92       	push	r7
     9a4:	8f 92       	push	r8
     9a6:	9f 92       	push	r9
     9a8:	af 92       	push	r10
     9aa:	bf 92       	push	r11
     9ac:	cf 92       	push	r12
     9ae:	df 92       	push	r13
     9b0:	ef 92       	push	r14
     9b2:	ff 92       	push	r15
     9b4:	0f 93       	push	r16
     9b6:	1f 93       	push	r17
     9b8:	cf 93       	push	r28
     9ba:	df 93       	push	r29
     9bc:	3c 01       	movw	r6, r24
     9be:	1b 01       	movw	r2, r22
     9c0:	5a 01       	movw	r10, r20
     9c2:	29 01       	movw	r4, r18
     9c4:	ca 01       	movw	r24, r20
     9c6:	0e 94 a2 02 	call	0x544	; 0x544 <pvPortMalloc>
     9ca:	6c 01       	movw	r12, r24
     9cc:	89 2b       	or	r24, r25
     9ce:	71 f0       	breq	.+28     	; 0x9ec <xTaskCreate+0x54>
     9d0:	86 e2       	ldi	r24, 0x26	; 38
     9d2:	90 e0       	ldi	r25, 0x00	; 0
     9d4:	0e 94 a2 02 	call	0x544	; 0x544 <pvPortMalloc>
     9d8:	ec 01       	movw	r28, r24
     9da:	89 2b       	or	r24, r25
     9dc:	19 f0       	breq	.+6      	; 0x9e4 <xTaskCreate+0x4c>
     9de:	d8 8e       	std	Y+24, r13	; 0x18
     9e0:	cf 8a       	std	Y+23, r12	; 0x17
     9e2:	06 c0       	rjmp	.+12     	; 0x9f0 <xTaskCreate+0x58>
     9e4:	c6 01       	movw	r24, r12
     9e6:	0e 94 38 03 	call	0x670	; 0x670 <vPortFree>
     9ea:	02 c0       	rjmp	.+4      	; 0x9f0 <xTaskCreate+0x58>
     9ec:	c0 e0       	ldi	r28, 0x00	; 0
     9ee:	d0 e0       	ldi	r29, 0x00	; 0
     9f0:	20 97       	sbiw	r28, 0x00	; 0
     9f2:	91 f0       	breq	.+36     	; 0xa18 <xTaskCreate+0x80>
     9f4:	95 01       	movw	r18, r10
     9f6:	40 e0       	ldi	r20, 0x00	; 0
     9f8:	50 e0       	ldi	r21, 0x00	; 0
     9fa:	81 2c       	mov	r8, r1
     9fc:	91 2c       	mov	r9, r1
     9fe:	5e 01       	movw	r10, r28
     a00:	67 01       	movw	r12, r14
     a02:	e0 2e       	mov	r14, r16
     a04:	82 01       	movw	r16, r4
     a06:	b1 01       	movw	r22, r2
     a08:	c3 01       	movw	r24, r6
     a0a:	0e 94 8c 03 	call	0x718	; 0x718 <prvInitialiseNewTask>
     a0e:	ce 01       	movw	r24, r28
     a10:	0e 94 2c 04 	call	0x858	; 0x858 <prvAddNewTaskToReadyList>
     a14:	81 e0       	ldi	r24, 0x01	; 1
     a16:	01 c0       	rjmp	.+2      	; 0xa1a <xTaskCreate+0x82>
     a18:	8f ef       	ldi	r24, 0xFF	; 255
     a1a:	df 91       	pop	r29
     a1c:	cf 91       	pop	r28
     a1e:	1f 91       	pop	r17
     a20:	0f 91       	pop	r16
     a22:	ff 90       	pop	r15
     a24:	ef 90       	pop	r14
     a26:	df 90       	pop	r13
     a28:	cf 90       	pop	r12
     a2a:	bf 90       	pop	r11
     a2c:	af 90       	pop	r10
     a2e:	9f 90       	pop	r9
     a30:	8f 90       	pop	r8
     a32:	7f 90       	pop	r7
     a34:	6f 90       	pop	r6
     a36:	5f 90       	pop	r5
     a38:	4f 90       	pop	r4
     a3a:	3f 90       	pop	r3
     a3c:	2f 90       	pop	r2
     a3e:	08 95       	ret

00000a40 <vTaskStartScheduler>:
     a40:	ef 92       	push	r14
     a42:	ff 92       	push	r15
     a44:	0f 93       	push	r16
     a46:	0f 2e       	mov	r0, r31
     a48:	fb ed       	ldi	r31, 0xDB	; 219
     a4a:	ef 2e       	mov	r14, r31
     a4c:	f6 e0       	ldi	r31, 0x06	; 6
     a4e:	ff 2e       	mov	r15, r31
     a50:	f0 2d       	mov	r31, r0
     a52:	00 e0       	ldi	r16, 0x00	; 0
     a54:	20 e0       	ldi	r18, 0x00	; 0
     a56:	30 e0       	ldi	r19, 0x00	; 0
     a58:	45 e5       	ldi	r20, 0x55	; 85
     a5a:	50 e0       	ldi	r21, 0x00	; 0
     a5c:	6e e6       	ldi	r22, 0x6E	; 110
     a5e:	70 e0       	ldi	r23, 0x00	; 0
     a60:	86 ef       	ldi	r24, 0xF6	; 246
     a62:	93 e0       	ldi	r25, 0x03	; 3
     a64:	0e 94 cc 04 	call	0x998	; 0x998 <xTaskCreate>
     a68:	81 30       	cpi	r24, 0x01	; 1
     a6a:	81 f4       	brne	.+32     	; 0xa8c <vTaskStartScheduler+0x4c>
     a6c:	f8 94       	cli
     a6e:	8f ef       	ldi	r24, 0xFF	; 255
     a70:	9f ef       	ldi	r25, 0xFF	; 255
     a72:	90 93 de 06 	sts	0x06DE, r25	; 0x8006de <xNextTaskUnblockTime+0x1>
     a76:	80 93 dd 06 	sts	0x06DD, r24	; 0x8006dd <xNextTaskUnblockTime>
     a7a:	81 e0       	ldi	r24, 0x01	; 1
     a7c:	80 93 e3 06 	sts	0x06E3, r24	; 0x8006e3 <xSchedulerRunning>
     a80:	10 92 e6 06 	sts	0x06E6, r1	; 0x8006e6 <xTickCount+0x1>
     a84:	10 92 e5 06 	sts	0x06E5, r1	; 0x8006e5 <xTickCount>
     a88:	0e 94 48 01 	call	0x290	; 0x290 <xPortStartScheduler>
     a8c:	0f 91       	pop	r16
     a8e:	ff 90       	pop	r15
     a90:	ef 90       	pop	r14
     a92:	08 95       	ret

00000a94 <vTaskSuspendAll>:
     a94:	80 91 da 06 	lds	r24, 0x06DA	; 0x8006da <uxSchedulerSuspended>
     a98:	8f 5f       	subi	r24, 0xFF	; 255
     a9a:	80 93 da 06 	sts	0x06DA, r24	; 0x8006da <uxSchedulerSuspended>
     a9e:	08 95       	ret

00000aa0 <xTaskGetTickCount>:
     aa0:	0f b6       	in	r0, 0x3f	; 63
     aa2:	f8 94       	cli
     aa4:	0f 92       	push	r0
     aa6:	80 91 e5 06 	lds	r24, 0x06E5	; 0x8006e5 <xTickCount>
     aaa:	90 91 e6 06 	lds	r25, 0x06E6	; 0x8006e6 <xTickCount+0x1>
     aae:	0f 90       	pop	r0
     ab0:	0f be       	out	0x3f, r0	; 63
     ab2:	08 95       	ret

00000ab4 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     ab4:	df 92       	push	r13
     ab6:	ef 92       	push	r14
     ab8:	ff 92       	push	r15
     aba:	0f 93       	push	r16
     abc:	1f 93       	push	r17
     abe:	cf 93       	push	r28
     ac0:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     ac2:	80 91 da 06 	lds	r24, 0x06DA	; 0x8006da <uxSchedulerSuspended>
     ac6:	81 11       	cpse	r24, r1
     ac8:	97 c0       	rjmp	.+302    	; 0xbf8 <xTaskIncrementTick+0x144>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
     aca:	e0 90 e5 06 	lds	r14, 0x06E5	; 0x8006e5 <xTickCount>
     ace:	f0 90 e6 06 	lds	r15, 0x06E6	; 0x8006e6 <xTickCount+0x1>
     ad2:	8f ef       	ldi	r24, 0xFF	; 255
     ad4:	e8 1a       	sub	r14, r24
     ad6:	f8 0a       	sbc	r15, r24

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     ad8:	f0 92 e6 06 	sts	0x06E6, r15	; 0x8006e6 <xTickCount+0x1>
     adc:	e0 92 e5 06 	sts	0x06E5, r14	; 0x8006e5 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U )
     ae0:	e1 14       	cp	r14, r1
     ae2:	f1 04       	cpc	r15, r1
     ae4:	b9 f4       	brne	.+46     	; 0xb14 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     ae6:	80 91 f3 06 	lds	r24, 0x06F3	; 0x8006f3 <pxDelayedTaskList>
     aea:	90 91 f4 06 	lds	r25, 0x06F4	; 0x8006f4 <pxDelayedTaskList+0x1>
     aee:	20 91 f1 06 	lds	r18, 0x06F1	; 0x8006f1 <pxOverflowDelayedTaskList>
     af2:	30 91 f2 06 	lds	r19, 0x06F2	; 0x8006f2 <pxOverflowDelayedTaskList+0x1>
     af6:	30 93 f4 06 	sts	0x06F4, r19	; 0x8006f4 <pxDelayedTaskList+0x1>
     afa:	20 93 f3 06 	sts	0x06F3, r18	; 0x8006f3 <pxDelayedTaskList>
     afe:	90 93 f2 06 	sts	0x06F2, r25	; 0x8006f2 <pxOverflowDelayedTaskList+0x1>
     b02:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <pxOverflowDelayedTaskList>
     b06:	80 91 e0 06 	lds	r24, 0x06E0	; 0x8006e0 <xNumOfOverflows>
     b0a:	8f 5f       	subi	r24, 0xFF	; 255
     b0c:	80 93 e0 06 	sts	0x06E0, r24	; 0x8006e0 <xNumOfOverflows>
     b10:	0e 94 6d 03 	call	0x6da	; 0x6da <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     b14:	80 91 dd 06 	lds	r24, 0x06DD	; 0x8006dd <xNextTaskUnblockTime>
     b18:	90 91 de 06 	lds	r25, 0x06DE	; 0x8006de <xNextTaskUnblockTime+0x1>
     b1c:	e8 16       	cp	r14, r24
     b1e:	f9 06       	cpc	r15, r25
     b20:	28 f4       	brcc	.+10     	; 0xb2c <xTaskIncrementTick+0x78>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     b22:	d1 2c       	mov	r13, r1
     b24:	53 c0       	rjmp	.+166    	; 0xbcc <xTaskIncrementTick+0x118>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
     b26:	dd 24       	eor	r13, r13
     b28:	d3 94       	inc	r13
     b2a:	01 c0       	rjmp	.+2      	; 0xb2e <xTaskIncrementTick+0x7a>
     b2c:	d1 2c       	mov	r13, r1
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     b2e:	e0 91 f3 06 	lds	r30, 0x06F3	; 0x8006f3 <pxDelayedTaskList>
     b32:	f0 91 f4 06 	lds	r31, 0x06F4	; 0x8006f4 <pxDelayedTaskList+0x1>
     b36:	80 81       	ld	r24, Z
     b38:	81 11       	cpse	r24, r1
     b3a:	07 c0       	rjmp	.+14     	; 0xb4a <xTaskIncrementTick+0x96>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     b3c:	8f ef       	ldi	r24, 0xFF	; 255
     b3e:	9f ef       	ldi	r25, 0xFF	; 255
     b40:	90 93 de 06 	sts	0x06DE, r25	; 0x8006de <xNextTaskUnblockTime+0x1>
     b44:	80 93 dd 06 	sts	0x06DD, r24	; 0x8006dd <xNextTaskUnblockTime>
					break;
     b48:	41 c0       	rjmp	.+130    	; 0xbcc <xTaskIncrementTick+0x118>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     b4a:	e0 91 f3 06 	lds	r30, 0x06F3	; 0x8006f3 <pxDelayedTaskList>
     b4e:	f0 91 f4 06 	lds	r31, 0x06F4	; 0x8006f4 <pxDelayedTaskList+0x1>
     b52:	05 80       	ldd	r0, Z+5	; 0x05
     b54:	f6 81       	ldd	r31, Z+6	; 0x06
     b56:	e0 2d       	mov	r30, r0
     b58:	c6 81       	ldd	r28, Z+6	; 0x06
     b5a:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     b5c:	8a 81       	ldd	r24, Y+2	; 0x02
     b5e:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
     b60:	e8 16       	cp	r14, r24
     b62:	f9 06       	cpc	r15, r25
     b64:	28 f4       	brcc	.+10     	; 0xb70 <xTaskIncrementTick+0xbc>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     b66:	90 93 de 06 	sts	0x06DE, r25	; 0x8006de <xNextTaskUnblockTime+0x1>
     b6a:	80 93 dd 06 	sts	0x06DD, r24	; 0x8006dd <xNextTaskUnblockTime>
						break;
     b6e:	2e c0       	rjmp	.+92     	; 0xbcc <xTaskIncrementTick+0x118>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     b70:	8e 01       	movw	r16, r28
     b72:	0e 5f       	subi	r16, 0xFE	; 254
     b74:	1f 4f       	sbci	r17, 0xFF	; 255
     b76:	c8 01       	movw	r24, r16
     b78:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     b7c:	8c 89       	ldd	r24, Y+20	; 0x14
     b7e:	9d 89       	ldd	r25, Y+21	; 0x15
     b80:	89 2b       	or	r24, r25
     b82:	21 f0       	breq	.+8      	; 0xb8c <xTaskIncrementTick+0xd8>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     b84:	ce 01       	movw	r24, r28
     b86:	0c 96       	adiw	r24, 0x0c	; 12
     b88:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     b8c:	8e 89       	ldd	r24, Y+22	; 0x16
     b8e:	90 91 e4 06 	lds	r25, 0x06E4	; 0x8006e4 <uxTopReadyPriority>
     b92:	98 17       	cp	r25, r24
     b94:	10 f4       	brcc	.+4      	; 0xb9a <xTaskIncrementTick+0xe6>
     b96:	80 93 e4 06 	sts	0x06E4, r24	; 0x8006e4 <uxTopReadyPriority>
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	9c 01       	movw	r18, r24
     b9e:	22 0f       	add	r18, r18
     ba0:	33 1f       	adc	r19, r19
     ba2:	22 0f       	add	r18, r18
     ba4:	33 1f       	adc	r19, r19
     ba6:	22 0f       	add	r18, r18
     ba8:	33 1f       	adc	r19, r19
     baa:	82 0f       	add	r24, r18
     bac:	93 1f       	adc	r25, r19
     bae:	b8 01       	movw	r22, r16
     bb0:	89 5f       	subi	r24, 0xF9	; 249
     bb2:	98 4f       	sbci	r25, 0xF8	; 248
     bb4:	0e 94 5b 00 	call	0xb6	; 0xb6 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     bb8:	9e 89       	ldd	r25, Y+22	; 0x16
     bba:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxCurrentTCB>
     bbe:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     bc2:	86 89       	ldd	r24, Z+22	; 0x16
     bc4:	98 17       	cp	r25, r24
     bc6:	08 f0       	brcs	.+2      	; 0xbca <xTaskIncrementTick+0x116>
     bc8:	ae cf       	rjmp	.-164    	; 0xb26 <xTaskIncrementTick+0x72>
     bca:	b1 cf       	rjmp	.-158    	; 0xb2e <xTaskIncrementTick+0x7a>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     bcc:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxCurrentTCB>
     bd0:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     bd4:	86 89       	ldd	r24, Z+22	; 0x16
     bd6:	90 e0       	ldi	r25, 0x00	; 0
     bd8:	fc 01       	movw	r30, r24
     bda:	ee 0f       	add	r30, r30
     bdc:	ff 1f       	adc	r31, r31
     bde:	ee 0f       	add	r30, r30
     be0:	ff 1f       	adc	r31, r31
     be2:	ee 0f       	add	r30, r30
     be4:	ff 1f       	adc	r31, r31
     be6:	8e 0f       	add	r24, r30
     be8:	9f 1f       	adc	r25, r31
     bea:	fc 01       	movw	r30, r24
     bec:	e9 5f       	subi	r30, 0xF9	; 249
     bee:	f8 4f       	sbci	r31, 0xF8	; 248
     bf0:	80 81       	ld	r24, Z
     bf2:	82 30       	cpi	r24, 0x02	; 2
     bf4:	40 f4       	brcc	.+16     	; 0xc06 <xTaskIncrementTick+0x152>
     bf6:	09 c0       	rjmp	.+18     	; 0xc0a <xTaskIncrementTick+0x156>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     bf8:	80 91 e2 06 	lds	r24, 0x06E2	; 0x8006e2 <uxPendedTicks>
     bfc:	8f 5f       	subi	r24, 0xFF	; 255
     bfe:	80 93 e2 06 	sts	0x06E2, r24	; 0x8006e2 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     c02:	d1 2c       	mov	r13, r1
     c04:	02 c0       	rjmp	.+4      	; 0xc0a <xTaskIncrementTick+0x156>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
     c06:	dd 24       	eor	r13, r13
     c08:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     c0a:	80 91 e1 06 	lds	r24, 0x06E1	; 0x8006e1 <xYieldPending>
     c0e:	88 23       	and	r24, r24
     c10:	11 f0       	breq	.+4      	; 0xc16 <xTaskIncrementTick+0x162>
		{
			xSwitchRequired = pdTRUE;
     c12:	dd 24       	eor	r13, r13
     c14:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     c16:	8d 2d       	mov	r24, r13
     c18:	df 91       	pop	r29
     c1a:	cf 91       	pop	r28
     c1c:	1f 91       	pop	r17
     c1e:	0f 91       	pop	r16
     c20:	ff 90       	pop	r15
     c22:	ef 90       	pop	r14
     c24:	df 90       	pop	r13
     c26:	08 95       	ret

00000c28 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     c28:	0f 93       	push	r16
     c2a:	1f 93       	push	r17
     c2c:	cf 93       	push	r28
     c2e:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     c30:	0f b6       	in	r0, 0x3f	; 63
     c32:	f8 94       	cli
     c34:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     c36:	80 91 da 06 	lds	r24, 0x06DA	; 0x8006da <uxSchedulerSuspended>
     c3a:	81 50       	subi	r24, 0x01	; 1
     c3c:	80 93 da 06 	sts	0x06DA, r24	; 0x8006da <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c40:	80 91 da 06 	lds	r24, 0x06DA	; 0x8006da <uxSchedulerSuspended>
     c44:	81 11       	cpse	r24, r1
     c46:	58 c0       	rjmp	.+176    	; 0xcf8 <xTaskResumeAll+0xd0>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     c48:	80 91 e7 06 	lds	r24, 0x06E7	; 0x8006e7 <uxCurrentNumberOfTasks>
     c4c:	81 11       	cpse	r24, r1
     c4e:	33 c0       	rjmp	.+102    	; 0xcb6 <xTaskResumeAll+0x8e>
     c50:	56 c0       	rjmp	.+172    	; 0xcfe <xTaskResumeAll+0xd6>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     c52:	e0 91 ed 06 	lds	r30, 0x06ED	; 0x8006ed <xPendingReadyList+0x5>
     c56:	f0 91 ee 06 	lds	r31, 0x06EE	; 0x8006ee <xPendingReadyList+0x6>
     c5a:	c6 81       	ldd	r28, Z+6	; 0x06
     c5c:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     c5e:	ce 01       	movw	r24, r28
     c60:	0c 96       	adiw	r24, 0x0c	; 12
     c62:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     c66:	8e 01       	movw	r16, r28
     c68:	0e 5f       	subi	r16, 0xFE	; 254
     c6a:	1f 4f       	sbci	r17, 0xFF	; 255
     c6c:	c8 01       	movw	r24, r16
     c6e:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     c72:	8e 89       	ldd	r24, Y+22	; 0x16
     c74:	90 91 e4 06 	lds	r25, 0x06E4	; 0x8006e4 <uxTopReadyPriority>
     c78:	98 17       	cp	r25, r24
     c7a:	10 f4       	brcc	.+4      	; 0xc80 <xTaskResumeAll+0x58>
     c7c:	80 93 e4 06 	sts	0x06E4, r24	; 0x8006e4 <uxTopReadyPriority>
     c80:	90 e0       	ldi	r25, 0x00	; 0
     c82:	9c 01       	movw	r18, r24
     c84:	22 0f       	add	r18, r18
     c86:	33 1f       	adc	r19, r19
     c88:	22 0f       	add	r18, r18
     c8a:	33 1f       	adc	r19, r19
     c8c:	22 0f       	add	r18, r18
     c8e:	33 1f       	adc	r19, r19
     c90:	82 0f       	add	r24, r18
     c92:	93 1f       	adc	r25, r19
     c94:	b8 01       	movw	r22, r16
     c96:	89 5f       	subi	r24, 0xF9	; 249
     c98:	98 4f       	sbci	r25, 0xF8	; 248
     c9a:	0e 94 5b 00 	call	0xb6	; 0xb6 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     c9e:	9e 89       	ldd	r25, Y+22	; 0x16
     ca0:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxCurrentTCB>
     ca4:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     ca8:	86 89       	ldd	r24, Z+22	; 0x16
     caa:	98 17       	cp	r25, r24
     cac:	30 f0       	brcs	.+12     	; 0xcba <xTaskResumeAll+0x92>
					{
						xYieldPending = pdTRUE;
     cae:	81 e0       	ldi	r24, 0x01	; 1
     cb0:	80 93 e1 06 	sts	0x06E1, r24	; 0x8006e1 <xYieldPending>
     cb4:	02 c0       	rjmp	.+4      	; 0xcba <xTaskResumeAll+0x92>
     cb6:	c0 e0       	ldi	r28, 0x00	; 0
     cb8:	d0 e0       	ldi	r29, 0x00	; 0
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     cba:	80 91 e8 06 	lds	r24, 0x06E8	; 0x8006e8 <xPendingReadyList>
     cbe:	81 11       	cpse	r24, r1
     cc0:	c8 cf       	rjmp	.-112    	; 0xc52 <xTaskResumeAll+0x2a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     cc2:	cd 2b       	or	r28, r29
     cc4:	11 f0       	breq	.+4      	; 0xcca <xTaskResumeAll+0xa2>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     cc6:	0e 94 6d 03 	call	0x6da	; 0x6da <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     cca:	c0 91 e2 06 	lds	r28, 0x06E2	; 0x8006e2 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     cce:	cc 23       	and	r28, r28
     cd0:	59 f0       	breq	.+22     	; 0xce8 <xTaskResumeAll+0xc0>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     cd2:	0e 94 5a 05 	call	0xab4	; 0xab4 <xTaskIncrementTick>
     cd6:	88 23       	and	r24, r24
     cd8:	19 f0       	breq	.+6      	; 0xce0 <xTaskResumeAll+0xb8>
							{
								xYieldPending = pdTRUE;
     cda:	81 e0       	ldi	r24, 0x01	; 1
     cdc:	80 93 e1 06 	sts	0x06E1, r24	; 0x8006e1 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     ce0:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     ce2:	b9 f7       	brne	.-18     	; 0xcd2 <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
     ce4:	10 92 e2 06 	sts	0x06E2, r1	; 0x8006e2 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     ce8:	80 91 e1 06 	lds	r24, 0x06E1	; 0x8006e1 <xYieldPending>
     cec:	88 23       	and	r24, r24
     cee:	31 f0       	breq	.+12     	; 0xcfc <xTaskResumeAll+0xd4>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     cf0:	0e 94 77 01 	call	0x2ee	; 0x2ee <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     cf4:	81 e0       	ldi	r24, 0x01	; 1
     cf6:	03 c0       	rjmp	.+6      	; 0xcfe <xTaskResumeAll+0xd6>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     cf8:	80 e0       	ldi	r24, 0x00	; 0
     cfa:	01 c0       	rjmp	.+2      	; 0xcfe <xTaskResumeAll+0xd6>
     cfc:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     cfe:	0f 90       	pop	r0
     d00:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     d02:	df 91       	pop	r29
     d04:	cf 91       	pop	r28
     d06:	1f 91       	pop	r17
     d08:	0f 91       	pop	r16
     d0a:	08 95       	ret

00000d0c <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     d0c:	0f 93       	push	r16
     d0e:	1f 93       	push	r17
     d10:	cf 93       	push	r28
     d12:	df 93       	push	r29
     d14:	8c 01       	movw	r16, r24
     d16:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     d18:	0e 94 4a 05 	call	0xa94	; 0xa94 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     d1c:	40 91 e5 06 	lds	r20, 0x06E5	; 0x8006e5 <xTickCount>
     d20:	50 91 e6 06 	lds	r21, 0x06E6	; 0x8006e6 <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     d24:	f8 01       	movw	r30, r16
     d26:	20 81       	ld	r18, Z
     d28:	31 81       	ldd	r19, Z+1	; 0x01
     d2a:	c9 01       	movw	r24, r18
     d2c:	8c 0f       	add	r24, r28
     d2e:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     d30:	42 17       	cp	r20, r18
     d32:	53 07       	cpc	r21, r19
     d34:	40 f4       	brcc	.+16     	; 0xd46 <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     d36:	82 17       	cp	r24, r18
     d38:	93 07       	cpc	r25, r19
     d3a:	68 f4       	brcc	.+26     	; 0xd56 <vTaskDelayUntil+0x4a>
     d3c:	48 17       	cp	r20, r24
     d3e:	59 07       	cpc	r21, r25
     d40:	60 f0       	brcs	.+24     	; 0xd5a <vTaskDelayUntil+0x4e>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     d42:	20 e0       	ldi	r18, 0x00	; 0
     d44:	0f c0       	rjmp	.+30     	; 0xd64 <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     d46:	82 17       	cp	r24, r18
     d48:	93 07       	cpc	r25, r19
     d4a:	48 f0       	brcs	.+18     	; 0xd5e <vTaskDelayUntil+0x52>
     d4c:	48 17       	cp	r20, r24
     d4e:	59 07       	cpc	r21, r25
     d50:	40 f0       	brcs	.+16     	; 0xd62 <vTaskDelayUntil+0x56>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     d52:	20 e0       	ldi	r18, 0x00	; 0
     d54:	07 c0       	rjmp	.+14     	; 0xd64 <vTaskDelayUntil+0x58>
     d56:	20 e0       	ldi	r18, 0x00	; 0
     d58:	05 c0       	rjmp	.+10     	; 0xd64 <vTaskDelayUntil+0x58>
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     d5a:	21 e0       	ldi	r18, 0x01	; 1
     d5c:	03 c0       	rjmp	.+6      	; 0xd64 <vTaskDelayUntil+0x58>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     d5e:	21 e0       	ldi	r18, 0x01	; 1
     d60:	01 c0       	rjmp	.+2      	; 0xd64 <vTaskDelayUntil+0x58>
     d62:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     d64:	f8 01       	movw	r30, r16
     d66:	91 83       	std	Z+1, r25	; 0x01
     d68:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     d6a:	22 23       	and	r18, r18
     d6c:	29 f0       	breq	.+10     	; 0xd78 <vTaskDelayUntil+0x6c>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     d6e:	60 e0       	ldi	r22, 0x00	; 0
     d70:	84 1b       	sub	r24, r20
     d72:	95 0b       	sbc	r25, r21
     d74:	0e 94 88 04 	call	0x910	; 0x910 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     d78:	0e 94 14 06 	call	0xc28	; 0xc28 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     d7c:	81 11       	cpse	r24, r1
     d7e:	02 c0       	rjmp	.+4      	; 0xd84 <vTaskDelayUntil+0x78>
		{
			portYIELD_WITHIN_API();
     d80:	0e 94 77 01 	call	0x2ee	; 0x2ee <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     d84:	df 91       	pop	r29
     d86:	cf 91       	pop	r28
     d88:	1f 91       	pop	r17
     d8a:	0f 91       	pop	r16
     d8c:	08 95       	ret

00000d8e <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     d8e:	80 91 da 06 	lds	r24, 0x06DA	; 0x8006da <uxSchedulerSuspended>
     d92:	88 23       	and	r24, r24
     d94:	21 f0       	breq	.+8      	; 0xd9e <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     d96:	81 e0       	ldi	r24, 0x01	; 1
     d98:	80 93 e1 06 	sts	0x06E1, r24	; 0x8006e1 <xYieldPending>
     d9c:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     d9e:	10 92 e1 06 	sts	0x06E1, r1	; 0x8006e1 <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     da2:	20 91 e4 06 	lds	r18, 0x06E4	; 0x8006e4 <uxTopReadyPriority>
     da6:	01 c0       	rjmp	.+2      	; 0xdaa <vTaskSwitchContext+0x1c>
     da8:	21 50       	subi	r18, 0x01	; 1
     daa:	82 2f       	mov	r24, r18
     dac:	90 e0       	ldi	r25, 0x00	; 0
     dae:	fc 01       	movw	r30, r24
     db0:	ee 0f       	add	r30, r30
     db2:	ff 1f       	adc	r31, r31
     db4:	ee 0f       	add	r30, r30
     db6:	ff 1f       	adc	r31, r31
     db8:	ee 0f       	add	r30, r30
     dba:	ff 1f       	adc	r31, r31
     dbc:	e8 0f       	add	r30, r24
     dbe:	f9 1f       	adc	r31, r25
     dc0:	e9 5f       	subi	r30, 0xF9	; 249
     dc2:	f8 4f       	sbci	r31, 0xF8	; 248
     dc4:	30 81       	ld	r19, Z
     dc6:	33 23       	and	r19, r19
     dc8:	79 f3       	breq	.-34     	; 0xda8 <vTaskSwitchContext+0x1a>
     dca:	ac 01       	movw	r20, r24
     dcc:	44 0f       	add	r20, r20
     dce:	55 1f       	adc	r21, r21
     dd0:	44 0f       	add	r20, r20
     dd2:	55 1f       	adc	r21, r21
     dd4:	44 0f       	add	r20, r20
     dd6:	55 1f       	adc	r21, r21
     dd8:	48 0f       	add	r20, r24
     dda:	59 1f       	adc	r21, r25
     ddc:	df 01       	movw	r26, r30
     dde:	01 80       	ldd	r0, Z+1	; 0x01
     de0:	f2 81       	ldd	r31, Z+2	; 0x02
     de2:	e0 2d       	mov	r30, r0
     de4:	02 80       	ldd	r0, Z+2	; 0x02
     de6:	f3 81       	ldd	r31, Z+3	; 0x03
     de8:	e0 2d       	mov	r30, r0
     dea:	12 96       	adiw	r26, 0x02	; 2
     dec:	fc 93       	st	X, r31
     dee:	ee 93       	st	-X, r30
     df0:	11 97       	sbiw	r26, 0x01	; 1
     df2:	46 5f       	subi	r20, 0xF6	; 246
     df4:	58 4f       	sbci	r21, 0xF8	; 248
     df6:	e4 17       	cp	r30, r20
     df8:	f5 07       	cpc	r31, r21
     dfa:	29 f4       	brne	.+10     	; 0xe06 <vTaskSwitchContext+0x78>
     dfc:	42 81       	ldd	r20, Z+2	; 0x02
     dfe:	53 81       	ldd	r21, Z+3	; 0x03
     e00:	fd 01       	movw	r30, r26
     e02:	52 83       	std	Z+2, r21	; 0x02
     e04:	41 83       	std	Z+1, r20	; 0x01
     e06:	fc 01       	movw	r30, r24
     e08:	ee 0f       	add	r30, r30
     e0a:	ff 1f       	adc	r31, r31
     e0c:	ee 0f       	add	r30, r30
     e0e:	ff 1f       	adc	r31, r31
     e10:	ee 0f       	add	r30, r30
     e12:	ff 1f       	adc	r31, r31
     e14:	8e 0f       	add	r24, r30
     e16:	9f 1f       	adc	r25, r31
     e18:	fc 01       	movw	r30, r24
     e1a:	e9 5f       	subi	r30, 0xF9	; 249
     e1c:	f8 4f       	sbci	r31, 0xF8	; 248
     e1e:	01 80       	ldd	r0, Z+1	; 0x01
     e20:	f2 81       	ldd	r31, Z+2	; 0x02
     e22:	e0 2d       	mov	r30, r0
     e24:	86 81       	ldd	r24, Z+6	; 0x06
     e26:	97 81       	ldd	r25, Z+7	; 0x07
     e28:	90 93 2c 07 	sts	0x072C, r25	; 0x80072c <pxCurrentTCB+0x1>
     e2c:	80 93 2b 07 	sts	0x072B, r24	; 0x80072b <pxCurrentTCB>
     e30:	20 93 e4 06 	sts	0x06E4, r18	; 0x8006e4 <uxTopReadyPriority>
     e34:	08 95       	ret

00000e36 <LED_Init>:
* @param [in]  LED_ch   -  LED channel number.
*
* @return function error state.
*/
extern ERROR_STATE_t LED_Init(uint8_t LED_ch)
{
     e36:	ef 92       	push	r14
     e38:	ff 92       	push	r15
     e3a:	0f 93       	push	r16
     e3c:	1f 93       	push	r17
     e3e:	cf 93       	push	r28
     e40:	df 93       	push	r29
   /* Variable to store function error state. */
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
     e42:	81 11       	cpse	r24, r1
     e44:	4e c0       	rjmp	.+156    	; 0xee2 <LED_Init+0xac>
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function was called before */
   else if(INIT == gu8_IsLEDInit[LED_ch])
     e46:	c8 2f       	mov	r28, r24
     e48:	d0 e0       	ldi	r29, 0x00	; 0
     e4a:	fe 01       	movw	r30, r28
     e4c:	e3 5d       	subi	r30, 0xD3	; 211
     e4e:	f8 4f       	sbci	r31, 0xF8	; 248
     e50:	80 81       	ld	r24, Z
     e52:	81 30       	cpi	r24, 0x01	; 1
     e54:	09 f4       	brne	.+2      	; 0xe58 <LED_Init+0x22>
     e56:	47 c0       	rjmp	.+142    	; 0xee6 <LED_Init+0xb0>
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INIT_BEFORE);
   }
   else
   {
      /* Normal LED Config */
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
     e58:	fe 01       	movw	r30, r28
     e5a:	ee 0f       	add	r30, r30
     e5c:	ff 1f       	adc	r31, r31
     e5e:	ee 0f       	add	r30, r30
     e60:	ff 1f       	adc	r31, r31
     e62:	e2 53       	subi	r30, 0x32	; 50
     e64:	ff 4f       	sbci	r31, 0xFF	; 255
     e66:	82 81       	ldd	r24, Z+2	; 0x02
     e68:	81 11       	cpse	r24, r1
     e6a:	14 c0       	rjmp	.+40     	; 0xe94 <LED_Init+0x5e>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* configure LED pin */
         DIO_ErrorState = DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
     e6c:	fe 01       	movw	r30, r28
     e6e:	ee 0f       	add	r30, r30
     e70:	ff 1f       	adc	r31, r31
     e72:	ee 0f       	add	r30, r30
     e74:	ff 1f       	adc	r31, r31
     e76:	e2 53       	subi	r30, 0x32	; 50
     e78:	ff 4f       	sbci	r31, 0xFF	; 255
     e7a:	61 81       	ldd	r22, Z+1	; 0x01
     e7c:	41 e0       	ldi	r20, 0x01	; 1
     e7e:	80 81       	ld	r24, Z
     e80:	0e 94 bb 08 	call	0x1176	; 0x1176 <DIO_SetPinDirection>
         /* make sure pin configuration is successful */
         if(ERROR_OK != DIO_ErrorState)
     e84:	81 11       	cpse	r24, r1
     e86:	31 c0       	rjmp	.+98     	; 0xeea <LED_Init+0xb4>
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            /* Set Channel to INIT */
            gu8_IsLEDInit[LED_ch] = INIT;
     e88:	c3 5d       	subi	r28, 0xD3	; 211
     e8a:	d8 4f       	sbci	r29, 0xF8	; 248
     e8c:	81 e0       	ldi	r24, 0x01	; 1
     e8e:	88 83       	st	Y, r24
            LED_ErrorState = ERROR_OK;
     e90:	80 e0       	ldi	r24, 0x00	; 0
     e92:	30 c0       	rjmp	.+96     	; 0xef4 <LED_Init+0xbe>
         }
      }
      /* PWM LED Config */
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
     e94:	81 30       	cpi	r24, 0x01	; 1
     e96:	59 f5       	brne	.+86     	; 0xeee <LED_Init+0xb8>
      {
         ERROR_STATE_t ErrorState;
         
         /* configure LED pin */
         ErrorState = PWM_Init(gSTR_LEDConfig[LED_ch].u8_PWMCh);
     e98:	ce 01       	movw	r24, r28
     e9a:	88 0f       	add	r24, r24
     e9c:	99 1f       	adc	r25, r25
     e9e:	88 0f       	add	r24, r24
     ea0:	99 1f       	adc	r25, r25
     ea2:	9c 01       	movw	r18, r24
     ea4:	22 53       	subi	r18, 0x32	; 50
     ea6:	3f 4f       	sbci	r19, 0xFF	; 255
     ea8:	79 01       	movw	r14, r18
     eaa:	f9 01       	movw	r30, r18
     eac:	03 81       	ldd	r16, Z+3	; 0x03
     eae:	80 2f       	mov	r24, r16
     eb0:	0e 94 8d 09 	call	0x131a	; 0x131a <PWM_Init>
     eb4:	18 2f       	mov	r17, r24
         ErrorState |= DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
     eb6:	41 e0       	ldi	r20, 0x01	; 1
     eb8:	f7 01       	movw	r30, r14
     eba:	61 81       	ldd	r22, Z+1	; 0x01
     ebc:	80 81       	ld	r24, Z
     ebe:	0e 94 bb 08 	call	0x1176	; 0x1176 <DIO_SetPinDirection>
     ec2:	18 2b       	or	r17, r24
         /*START THE PWM WAVE*/
         ErrorState |= PWM_Start(gSTR_LEDConfig[LED_ch].u8_PWMCh);
     ec4:	80 2f       	mov	r24, r16
     ec6:	0e 94 be 09 	call	0x137c	; 0x137c <PWM_Start>
     eca:	18 2b       	or	r17, r24
         ErrorState |= PWM_Connect(gSTR_LEDConfig[LED_ch].u8_PWMCh);
     ecc:	80 2f       	mov	r24, r16
     ece:	0e 94 ca 09 	call	0x1394	; 0x1394 <PWM_Connect>
     ed2:	81 2b       	or	r24, r17
         /* make sure pin configuration is successful */
         if(ERROR_OK != ErrorState)
     ed4:	71 f4       	brne	.+28     	; 0xef2 <LED_Init+0xbc>
            LED_ErrorState = ERROR_NOK;
         }  
         else
         {
            /* Set Channel to INIT */
            gu8_IsLEDInit[LED_ch] = INIT;
     ed6:	c3 5d       	subi	r28, 0xD3	; 211
     ed8:	d8 4f       	sbci	r29, 0xF8	; 248
     eda:	81 e0       	ldi	r24, 0x01	; 1
     edc:	88 83       	st	Y, r24
            LED_ErrorState = ERROR_OK;
     ede:	80 e0       	ldi	r24, 0x00	; 0
     ee0:	09 c0       	rjmp	.+18     	; 0xef4 <LED_Init+0xbe>
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
     ee2:	81 ec       	ldi	r24, 0xC1	; 193
     ee4:	07 c0       	rjmp	.+14     	; 0xef4 <LED_Init+0xbe>
   }
   /* check if init function was called before */
   else if(INIT == gu8_IsLEDInit[LED_ch])
   {
      /* Set init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INIT_BEFORE);
     ee6:	82 ec       	ldi	r24, 0xC2	; 194
     ee8:	05 c0       	rjmp	.+10     	; 0xef4 <LED_Init+0xbe>
         /* configure LED pin */
         DIO_ErrorState = DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
         /* make sure pin configuration is successful */
         if(ERROR_OK != DIO_ErrorState)
         {
            LED_ErrorState = ERROR_NOK;
     eea:	81 e0       	ldi	r24, 0x01	; 1
     eec:	03 c0       	rjmp	.+6      	; 0xef4 <LED_Init+0xbe>
            LED_ErrorState = ERROR_OK;
         }          
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
     eee:	81 e0       	ldi	r24, 0x01	; 1
     ef0:	01 c0       	rjmp	.+2      	; 0xef4 <LED_Init+0xbe>
         ErrorState |= PWM_Start(gSTR_LEDConfig[LED_ch].u8_PWMCh);
         ErrorState |= PWM_Connect(gSTR_LEDConfig[LED_ch].u8_PWMCh);
         /* make sure pin configuration is successful */
         if(ERROR_OK != ErrorState)
         {
            LED_ErrorState = ERROR_NOK;
     ef2:	81 e0       	ldi	r24, 0x01	; 1
      }   
   }
   
   /* return Error state. */
   return LED_ErrorState;
}
     ef4:	df 91       	pop	r29
     ef6:	cf 91       	pop	r28
     ef8:	1f 91       	pop	r17
     efa:	0f 91       	pop	r16
     efc:	ff 90       	pop	r15
     efe:	ef 90       	pop	r14
     f00:	08 95       	ret

00000f02 <LED_Off>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
     f02:	81 11       	cpse	r24, r1
     f04:	32 c0       	rjmp	.+100    	; 0xf6a <LED_Off+0x68>
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
     f06:	90 e0       	ldi	r25, 0x00	; 0
     f08:	fc 01       	movw	r30, r24
     f0a:	e3 5d       	subi	r30, 0xD3	; 211
     f0c:	f8 4f       	sbci	r31, 0xF8	; 248
     f0e:	20 81       	ld	r18, Z
     f10:	21 30       	cpi	r18, 0x01	; 1
     f12:	69 f5       	brne	.+90     	; 0xf6e <LED_Off+0x6c>
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   else
   {
      /* Normal LED */
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
     f14:	fc 01       	movw	r30, r24
     f16:	ee 0f       	add	r30, r30
     f18:	ff 1f       	adc	r31, r31
     f1a:	ee 0f       	add	r30, r30
     f1c:	ff 1f       	adc	r31, r31
     f1e:	e2 53       	subi	r30, 0x32	; 50
     f20:	ff 4f       	sbci	r31, 0xFF	; 255
     f22:	22 81       	ldd	r18, Z+2	; 0x02
     f24:	21 11       	cpse	r18, r1
     f26:	10 c0       	rjmp	.+32     	; 0xf48 <LED_Off+0x46>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* set LED pin to low */
         DIO_ErrorState = DIO_WritePin(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_LOW);
     f28:	88 0f       	add	r24, r24
     f2a:	99 1f       	adc	r25, r25
     f2c:	88 0f       	add	r24, r24
     f2e:	99 1f       	adc	r25, r25
     f30:	fc 01       	movw	r30, r24
     f32:	e2 53       	subi	r30, 0x32	; 50
     f34:	ff 4f       	sbci	r31, 0xFF	; 255
     f36:	61 81       	ldd	r22, Z+1	; 0x01
     f38:	40 e0       	ldi	r20, 0x00	; 0
     f3a:	80 81       	ld	r24, Z
     f3c:	0e 94 24 09 	call	0x1248	; 0x1248 <DIO_WritePin>
         
         /* make sure DIO function was successful */
         if(ERROR_OK != DIO_ErrorState)
     f40:	88 23       	and	r24, r24
     f42:	b9 f0       	breq	.+46     	; 0xf72 <LED_Off+0x70>
         {
            LED_ErrorState = ERROR_NOK;
     f44:	81 e0       	ldi	r24, 0x01	; 1
     f46:	08 95       	ret
         {
            LED_ErrorState = ERROR_OK;
         }
      }
      /* PWM LED */
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
     f48:	21 30       	cpi	r18, 0x01	; 1
     f4a:	a9 f4       	brne	.+42     	; 0xf76 <LED_Off+0x74>
      {
         ERROR_STATE_t PWM_ErrorState;
         
         /* set LED duty cycle to Minimum */
         PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, MIN_DUTY);
     f4c:	88 0f       	add	r24, r24
     f4e:	99 1f       	adc	r25, r25
     f50:	88 0f       	add	r24, r24
     f52:	99 1f       	adc	r25, r25
     f54:	fc 01       	movw	r30, r24
     f56:	e2 53       	subi	r30, 0x32	; 50
     f58:	ff 4f       	sbci	r31, 0xFF	; 255
     f5a:	60 e0       	ldi	r22, 0x00	; 0
     f5c:	83 81       	ldd	r24, Z+3	; 0x03
     f5e:	0e 94 db 09 	call	0x13b6	; 0x13b6 <PWM_SetDuty>
         
         /* make sure PWM function was successful */
         if(ERROR_OK != PWM_ErrorState)
     f62:	88 23       	and	r24, r24
     f64:	51 f0       	breq	.+20     	; 0xf7a <LED_Off+0x78>
         {
            LED_ErrorState = ERROR_NOK;
     f66:	81 e0       	ldi	r24, 0x01	; 1
     f68:	08 95       	ret
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
     f6a:	81 ec       	ldi	r24, 0xC1	; 193
     f6c:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
     f6e:	83 ec       	ldi	r24, 0xC3	; 195
     f70:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
     f72:	80 e0       	ldi	r24, 0x00	; 0
     f74:	08 95       	ret
            LED_ErrorState = ERROR_OK;
         }
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
     f76:	81 e0       	ldi	r24, 0x01	; 1
     f78:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
     f7a:	80 e0       	ldi	r24, 0x00	; 0
      }
   }
   
   /* return Error state. */
   return LED_ErrorState;
}
     f7c:	08 95       	ret

00000f7e <LED_On>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
     f7e:	81 11       	cpse	r24, r1
     f80:	32 c0       	rjmp	.+100    	; 0xfe6 <LED_On+0x68>
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
     f82:	90 e0       	ldi	r25, 0x00	; 0
     f84:	fc 01       	movw	r30, r24
     f86:	e3 5d       	subi	r30, 0xD3	; 211
     f88:	f8 4f       	sbci	r31, 0xF8	; 248
     f8a:	20 81       	ld	r18, Z
     f8c:	21 30       	cpi	r18, 0x01	; 1
     f8e:	69 f5       	brne	.+90     	; 0xfea <LED_On+0x6c>
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   else
   {
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
     f90:	fc 01       	movw	r30, r24
     f92:	ee 0f       	add	r30, r30
     f94:	ff 1f       	adc	r31, r31
     f96:	ee 0f       	add	r30, r30
     f98:	ff 1f       	adc	r31, r31
     f9a:	e2 53       	subi	r30, 0x32	; 50
     f9c:	ff 4f       	sbci	r31, 0xFF	; 255
     f9e:	22 81       	ldd	r18, Z+2	; 0x02
     fa0:	21 11       	cpse	r18, r1
     fa2:	10 c0       	rjmp	.+32     	; 0xfc4 <LED_On+0x46>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* set LED pin to high */
         DIO_ErrorState = DIO_WritePin(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_HIGH);
     fa4:	88 0f       	add	r24, r24
     fa6:	99 1f       	adc	r25, r25
     fa8:	88 0f       	add	r24, r24
     faa:	99 1f       	adc	r25, r25
     fac:	fc 01       	movw	r30, r24
     fae:	e2 53       	subi	r30, 0x32	; 50
     fb0:	ff 4f       	sbci	r31, 0xFF	; 255
     fb2:	61 81       	ldd	r22, Z+1	; 0x01
     fb4:	41 e0       	ldi	r20, 0x01	; 1
     fb6:	80 81       	ld	r24, Z
     fb8:	0e 94 24 09 	call	0x1248	; 0x1248 <DIO_WritePin>
         
         /* make sure DIO function was successful */
         if(ERROR_OK != DIO_ErrorState)
     fbc:	88 23       	and	r24, r24
     fbe:	b9 f0       	breq	.+46     	; 0xfee <LED_On+0x70>
         {
            LED_ErrorState = ERROR_NOK;
     fc0:	81 e0       	ldi	r24, 0x01	; 1
     fc2:	08 95       	ret
         else
         {
            LED_ErrorState = ERROR_OK;
         }
      }
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
     fc4:	21 30       	cpi	r18, 0x01	; 1
     fc6:	a9 f4       	brne	.+42     	; 0xff2 <LED_On+0x74>
      {
         ERROR_STATE_t PWM_ErrorState;
         
         /* set LED duty cycle to maximum */
         PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, MAX_DUTY);
     fc8:	88 0f       	add	r24, r24
     fca:	99 1f       	adc	r25, r25
     fcc:	88 0f       	add	r24, r24
     fce:	99 1f       	adc	r25, r25
     fd0:	fc 01       	movw	r30, r24
     fd2:	e2 53       	subi	r30, 0x32	; 50
     fd4:	ff 4f       	sbci	r31, 0xFF	; 255
     fd6:	64 e6       	ldi	r22, 0x64	; 100
     fd8:	83 81       	ldd	r24, Z+3	; 0x03
     fda:	0e 94 db 09 	call	0x13b6	; 0x13b6 <PWM_SetDuty>
         
         /* make sure PWM function was successful */
         if(ERROR_OK != PWM_ErrorState)
     fde:	88 23       	and	r24, r24
     fe0:	51 f0       	breq	.+20     	; 0xff6 <LED_On+0x78>
         {
            LED_ErrorState = ERROR_NOK;
     fe2:	81 e0       	ldi	r24, 0x01	; 1
     fe4:	08 95       	ret
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
     fe6:	81 ec       	ldi	r24, 0xC1	; 193
     fe8:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
     fea:	83 ec       	ldi	r24, 0xC3	; 195
     fec:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
     fee:	80 e0       	ldi	r24, 0x00	; 0
     ff0:	08 95       	ret
            LED_ErrorState = ERROR_OK;
         }
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
     ff2:	81 e0       	ldi	r24, 0x01	; 1
     ff4:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
     ff6:	80 e0       	ldi	r24, 0x00	; 0
      }
   }
   
   /* return Error state. */
   return LED_ErrorState;
}
     ff8:	08 95       	ret

00000ffa <LED_Dim>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
     ffa:	81 11       	cpse	r24, r1
     ffc:	21 c0       	rjmp	.+66     	; 0x1040 <LED_Dim+0x46>
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
     ffe:	90 e0       	ldi	r25, 0x00	; 0
    1000:	fc 01       	movw	r30, r24
    1002:	e3 5d       	subi	r30, 0xD3	; 211
    1004:	f8 4f       	sbci	r31, 0xF8	; 248
    1006:	20 81       	ld	r18, Z
    1008:	21 30       	cpi	r18, 0x01	; 1
    100a:	e1 f4       	brne	.+56     	; 0x1044 <LED_Dim+0x4a>
   {
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   /* check if channel is not pwm pin. */
   else if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    100c:	fc 01       	movw	r30, r24
    100e:	ee 0f       	add	r30, r30
    1010:	ff 1f       	adc	r31, r31
    1012:	ee 0f       	add	r30, r30
    1014:	ff 1f       	adc	r31, r31
    1016:	e2 53       	subi	r30, 0x32	; 50
    1018:	ff 4f       	sbci	r31, 0xFF	; 255
    101a:	22 81       	ldd	r18, Z+2	; 0x02
    101c:	22 23       	and	r18, r18
    101e:	a1 f0       	breq	.+40     	; 0x1048 <LED_Dim+0x4e>
   {
      LED_ErrorState = ERROR_NOK;
   }
   /* check valid duty cycle. */
   else if(MAX_DUTY < Duty)
    1020:	65 36       	cpi	r22, 0x65	; 101
    1022:	a0 f4       	brcc	.+40     	; 0x104c <LED_Dim+0x52>
   else
   {
      ERROR_STATE_t PWM_ErrorState;
         
      /* set LED duty cycle */
      PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, Duty);
    1024:	88 0f       	add	r24, r24
    1026:	99 1f       	adc	r25, r25
    1028:	88 0f       	add	r24, r24
    102a:	99 1f       	adc	r25, r25
    102c:	fc 01       	movw	r30, r24
    102e:	e2 53       	subi	r30, 0x32	; 50
    1030:	ff 4f       	sbci	r31, 0xFF	; 255
    1032:	83 81       	ldd	r24, Z+3	; 0x03
    1034:	0e 94 db 09 	call	0x13b6	; 0x13b6 <PWM_SetDuty>
        
      /* make sure PWM function was successful */ 
      if(ERROR_OK != PWM_ErrorState)
    1038:	88 23       	and	r24, r24
    103a:	51 f0       	breq	.+20     	; 0x1050 <LED_Dim+0x56>
      {
         LED_ErrorState = ERROR_NOK;
    103c:	81 e0       	ldi	r24, 0x01	; 1
    103e:	08 95       	ret
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    1040:	81 ec       	ldi	r24, 0xC1	; 193
    1042:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
    1044:	83 ec       	ldi	r24, 0xC3	; 195
    1046:	08 95       	ret
   }
   /* check if channel is not pwm pin. */
   else if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
   {
      LED_ErrorState = ERROR_NOK;
    1048:	81 e0       	ldi	r24, 0x01	; 1
    104a:	08 95       	ret
   }
   /* check valid duty cycle. */
   else if(MAX_DUTY < Duty)
   {
      LED_ErrorState = ERROR_NOK;
    104c:	81 e0       	ldi	r24, 0x01	; 1
    104e:	08 95       	ret
      {
         LED_ErrorState = ERROR_NOK;
      }
      else
      {
         LED_ErrorState = ERROR_OK;
    1050:	80 e0       	ldi	r24, 0x00	; 0
      }
   }
   
   /* return Error state. */
   return LED_ErrorState;
}
    1052:	08 95       	ret

00001054 <SevenSeg_ClearEnable>:
------------------------*/
/**
* @brief: This function Clear all Segments Enable Bits.
*/
static void SevenSeg_ClearEnable(void)
{
    1054:	cf 93       	push	r28
   /* Loop on all channels */
   for(uint8_t u8_ChannelCounter = 0; u8_ChannelCounter < SEVEN_SEG_NUMBERS; u8_ChannelCounter++)
    1056:	c0 e0       	ldi	r28, 0x00	; 0
    1058:	0e c0       	rjmp	.+28     	; 0x1076 <SevenSeg_ClearEnable+0x22>
   {
      /* Set enable pin to low. */
      DIO_WritePin(aSTR_SevenSegConfig[u8_ChannelCounter].u8_EnPort, aSTR_SevenSegConfig[u8_ChannelCounter].u8_EnPin, PIN_LOW);
    105a:	ec 2f       	mov	r30, r28
    105c:	f0 e0       	ldi	r31, 0x00	; 0
    105e:	ee 0f       	add	r30, r30
    1060:	ff 1f       	adc	r31, r31
    1062:	ee 0f       	add	r30, r30
    1064:	ff 1f       	adc	r31, r31
    1066:	ee 52       	subi	r30, 0x2E	; 46
    1068:	ff 4f       	sbci	r31, 0xFF	; 255
    106a:	40 e0       	ldi	r20, 0x00	; 0
    106c:	61 81       	ldd	r22, Z+1	; 0x01
    106e:	80 81       	ld	r24, Z
    1070:	0e 94 24 09 	call	0x1248	; 0x1248 <DIO_WritePin>
* @brief: This function Clear all Segments Enable Bits.
*/
static void SevenSeg_ClearEnable(void)
{
   /* Loop on all channels */
   for(uint8_t u8_ChannelCounter = 0; u8_ChannelCounter < SEVEN_SEG_NUMBERS; u8_ChannelCounter++)
    1074:	cf 5f       	subi	r28, 0xFF	; 255
    1076:	c2 30       	cpi	r28, 0x02	; 2
    1078:	80 f3       	brcs	.-32     	; 0x105a <SevenSeg_ClearEnable+0x6>
   {
      /* Set enable pin to low. */
      DIO_WritePin(aSTR_SevenSegConfig[u8_ChannelCounter].u8_EnPort, aSTR_SevenSegConfig[u8_ChannelCounter].u8_EnPin, PIN_LOW);
   }
}
    107a:	cf 91       	pop	r28
    107c:	08 95       	ret

0000107e <SevenSeg_Init>:
* @param [in]  Channel   -  Channel number.
*
* @return function error state.
*/
extern ERROR_STATE_t SevenSeg_Init(const uint8_t Channel)
{
    107e:	1f 93       	push	r17
    1080:	cf 93       	push	r28
    1082:	df 93       	push	r29
   /* Variable to store function error state. */
   ERROR_STATE_t SevenSeg_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(SEVEN_SEG_INVALID_CH <= Channel)
    1084:	82 30       	cpi	r24, 0x02	; 2
    1086:	60 f5       	brcc	.+88     	; 0x10e0 <SevenSeg_Init+0x62>
   {
      /* Set invalid channel error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_CH);
   }
   else if(INIT == gu8_IsInit[Channel])
    1088:	c8 2f       	mov	r28, r24
    108a:	d0 e0       	ldi	r29, 0x00	; 0
    108c:	fe 01       	movw	r30, r28
    108e:	e2 5d       	subi	r30, 0xD2	; 210
    1090:	f8 4f       	sbci	r31, 0xF8	; 248
    1092:	80 81       	ld	r24, Z
    1094:	81 30       	cpi	r24, 0x01	; 1
    1096:	31 f1       	breq	.+76     	; 0x10e4 <SevenSeg_Init+0x66>
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INIT_BEFORE);
   }
   else
   {
      /* Set enable pin direction to output. */
      DIO_SetPinDirection(aSTR_SevenSegConfig[Channel].u8_EnPort, aSTR_SevenSegConfig[Channel].u8_EnPin, PIN_OUTPUT);
    1098:	fe 01       	movw	r30, r28
    109a:	ee 0f       	add	r30, r30
    109c:	ff 1f       	adc	r31, r31
    109e:	ee 0f       	add	r30, r30
    10a0:	ff 1f       	adc	r31, r31
    10a2:	ee 52       	subi	r30, 0x2E	; 46
    10a4:	ff 4f       	sbci	r31, 0xFF	; 255
    10a6:	41 e0       	ldi	r20, 0x01	; 1
    10a8:	61 81       	ldd	r22, Z+1	; 0x01
    10aa:	80 81       	ld	r24, Z
    10ac:	0e 94 bb 08 	call	0x1176	; 0x1176 <DIO_SetPinDirection>
      /* loop on data pins. */
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
    10b0:	10 e0       	ldi	r17, 0x00	; 0
    10b2:	0e c0       	rjmp	.+28     	; 0x10d0 <SevenSeg_Init+0x52>
      {
         /* Set the data pin direction to output. */
         DIO_SetPinDirection(
            aSTR_SevenSegConfig[Channel].u8_DataPort, 
            (aSTR_SevenSegConfig[Channel].u8_DataPinStart + u8_DataPinsCounter), 
    10b4:	fe 01       	movw	r30, r28
    10b6:	ee 0f       	add	r30, r30
    10b8:	ff 1f       	adc	r31, r31
    10ba:	ee 0f       	add	r30, r30
    10bc:	ff 1f       	adc	r31, r31
    10be:	ee 52       	subi	r30, 0x2E	; 46
    10c0:	ff 4f       	sbci	r31, 0xFF	; 255
    10c2:	63 81       	ldd	r22, Z+3	; 0x03
      DIO_SetPinDirection(aSTR_SevenSegConfig[Channel].u8_EnPort, aSTR_SevenSegConfig[Channel].u8_EnPin, PIN_OUTPUT);
      /* loop on data pins. */
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
      {
         /* Set the data pin direction to output. */
         DIO_SetPinDirection(
    10c4:	61 0f       	add	r22, r17
    10c6:	41 e0       	ldi	r20, 0x01	; 1
    10c8:	82 81       	ldd	r24, Z+2	; 0x02
    10ca:	0e 94 bb 08 	call	0x1176	; 0x1176 <DIO_SetPinDirection>
   else
   {
      /* Set enable pin direction to output. */
      DIO_SetPinDirection(aSTR_SevenSegConfig[Channel].u8_EnPort, aSTR_SevenSegConfig[Channel].u8_EnPin, PIN_OUTPUT);
      /* loop on data pins. */
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
    10ce:	1f 5f       	subi	r17, 0xFF	; 255
    10d0:	14 30       	cpi	r17, 0x04	; 4
    10d2:	80 f3       	brcs	.-32     	; 0x10b4 <SevenSeg_Init+0x36>
            (aSTR_SevenSegConfig[Channel].u8_DataPinStart + u8_DataPinsCounter), 
            PIN_OUTPUT
         );
      }    
      /* Set channel to initialized. */    
      gu8_IsInit[Channel] = INIT;
    10d4:	c2 5d       	subi	r28, 0xD2	; 210
    10d6:	d8 4f       	sbci	r29, 0xF8	; 248
    10d8:	81 e0       	ldi	r24, 0x01	; 1
    10da:	88 83       	st	Y, r24
      SevenSeg_ErrorState = ERROR_OK;
    10dc:	80 e0       	ldi	r24, 0x00	; 0
    10de:	03 c0       	rjmp	.+6      	; 0x10e6 <SevenSeg_Init+0x68>
   
   /* Validate valid Parameters are passed. */
   if(SEVEN_SEG_INVALID_CH <= Channel)
   {
      /* Set invalid channel error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_CH);
    10e0:	81 ea       	ldi	r24, 0xA1	; 161
    10e2:	01 c0       	rjmp	.+2      	; 0x10e6 <SevenSeg_Init+0x68>
   }
   else if(INIT == gu8_IsInit[Channel])
   {
      /* Set initialized before error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INIT_BEFORE);
    10e4:	83 ea       	ldi	r24, 0xA3	; 163
      SevenSeg_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return SevenSeg_ErrorState;
}
    10e6:	df 91       	pop	r29
    10e8:	cf 91       	pop	r28
    10ea:	1f 91       	pop	r17
    10ec:	08 95       	ret

000010ee <SevenSeg_Display>:
* @param [out] Data     -  Pressed Key Value.
*
* @return function error state.
*/
ERROR_STATE_t SevenSeg_Display(const uint8_t Channel, const uint8_t Number)
{
    10ee:	0f 93       	push	r16
    10f0:	1f 93       	push	r17
    10f2:	cf 93       	push	r28
    10f4:	df 93       	push	r29
   /* Variable to store function error state. */
   ERROR_STATE_t SevenSeg_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(SEVEN_SEG_INVALID_CH <= Channel)
    10f6:	82 30       	cpi	r24, 0x02	; 2
    10f8:	a0 f5       	brcc	.+104    	; 0x1162 <SevenSeg_Display+0x74>
   {
      /* Set invalid channel error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_CH);
   }
   else if(INIT != gu8_IsInit[Channel])
    10fa:	c8 2f       	mov	r28, r24
    10fc:	d0 e0       	ldi	r29, 0x00	; 0
    10fe:	fe 01       	movw	r30, r28
    1100:	e2 5d       	subi	r30, 0xD2	; 210
    1102:	f8 4f       	sbci	r31, 0xF8	; 248
    1104:	80 81       	ld	r24, Z
    1106:	81 30       	cpi	r24, 0x01	; 1
    1108:	71 f5       	brne	.+92     	; 0x1166 <SevenSeg_Display+0x78>
   {
      /* Set not initialized error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_NOT_INIT);
   }
   else if(MAX_DISPLAY_NUMBER < Number)
    110a:	6a 30       	cpi	r22, 0x0A	; 10
    110c:	70 f5       	brcc	.+92     	; 0x116a <SevenSeg_Display+0x7c>
    110e:	16 2f       	mov	r17, r22
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_NUMBER);
   }
   else
   {
      /* Clear all enable pins */
      SevenSeg_ClearEnable();
    1110:	0e 94 2a 08 	call	0x1054	; 0x1054 <SevenSeg_ClearEnable>
      /* Loop on data pins. */
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
    1114:	00 e0       	ldi	r16, 0x00	; 0
    1116:	16 c0       	rjmp	.+44     	; 0x1144 <SevenSeg_Display+0x56>
      {
         /* Write the pin value. */
         DIO_WritePin(
         aSTR_SevenSegConfig[Channel].u8_DataPort,
         (aSTR_SevenSegConfig[Channel].u8_DataPinStart + u8_DataPinsCounter),
         ((Number >> u8_DataPinsCounter) & (1))
    1118:	41 2f       	mov	r20, r17
    111a:	50 e0       	ldi	r21, 0x00	; 0
    111c:	00 2e       	mov	r0, r16
    111e:	02 c0       	rjmp	.+4      	; 0x1124 <SevenSeg_Display+0x36>
    1120:	55 95       	asr	r21
    1122:	47 95       	ror	r20
    1124:	0a 94       	dec	r0
    1126:	e2 f7       	brpl	.-8      	; 0x1120 <SevenSeg_Display+0x32>
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
      {
         /* Write the pin value. */
         DIO_WritePin(
         aSTR_SevenSegConfig[Channel].u8_DataPort,
         (aSTR_SevenSegConfig[Channel].u8_DataPinStart + u8_DataPinsCounter),
    1128:	fe 01       	movw	r30, r28
    112a:	ee 0f       	add	r30, r30
    112c:	ff 1f       	adc	r31, r31
    112e:	ee 0f       	add	r30, r30
    1130:	ff 1f       	adc	r31, r31
    1132:	ee 52       	subi	r30, 0x2E	; 46
    1134:	ff 4f       	sbci	r31, 0xFF	; 255
    1136:	63 81       	ldd	r22, Z+3	; 0x03
      SevenSeg_ClearEnable();
      /* Loop on data pins. */
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
      {
         /* Write the pin value. */
         DIO_WritePin(
    1138:	41 70       	andi	r20, 0x01	; 1
    113a:	60 0f       	add	r22, r16
    113c:	82 81       	ldd	r24, Z+2	; 0x02
    113e:	0e 94 24 09 	call	0x1248	; 0x1248 <DIO_WritePin>
   else
   {
      /* Clear all enable pins */
      SevenSeg_ClearEnable();
      /* Loop on data pins. */
      for(uint8_t u8_DataPinsCounter = 0; u8_DataPinsCounter < DATA_PINS_NUMBER; u8_DataPinsCounter++)
    1142:	0f 5f       	subi	r16, 0xFF	; 255
    1144:	04 30       	cpi	r16, 0x04	; 4
    1146:	40 f3       	brcs	.-48     	; 0x1118 <SevenSeg_Display+0x2a>
         (aSTR_SevenSegConfig[Channel].u8_DataPinStart + u8_DataPinsCounter),
         ((Number >> u8_DataPinsCounter) & (1))
         );
      }
      /* Set enable pin to high. */
      DIO_WritePin(aSTR_SevenSegConfig[Channel].u8_EnPort, aSTR_SevenSegConfig[Channel].u8_EnPin, PIN_HIGH);
    1148:	cc 0f       	add	r28, r28
    114a:	dd 1f       	adc	r29, r29
    114c:	cc 0f       	add	r28, r28
    114e:	dd 1f       	adc	r29, r29
    1150:	ce 52       	subi	r28, 0x2E	; 46
    1152:	df 4f       	sbci	r29, 0xFF	; 255
    1154:	41 e0       	ldi	r20, 0x01	; 1
    1156:	69 81       	ldd	r22, Y+1	; 0x01
    1158:	88 81       	ld	r24, Y
    115a:	0e 94 24 09 	call	0x1248	; 0x1248 <DIO_WritePin>
      SevenSeg_ErrorState = ERROR_OK;
    115e:	80 e0       	ldi	r24, 0x00	; 0
    1160:	05 c0       	rjmp	.+10     	; 0x116c <SevenSeg_Display+0x7e>
   
   /* Validate valid Parameters are passed. */
   if(SEVEN_SEG_INVALID_CH <= Channel)
   {
      /* Set invalid channel error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_CH);
    1162:	81 ea       	ldi	r24, 0xA1	; 161
    1164:	03 c0       	rjmp	.+6      	; 0x116c <SevenSeg_Display+0x7e>
   }
   else if(INIT != gu8_IsInit[Channel])
   {
      /* Set not initialized error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_NOT_INIT);
    1166:	82 ea       	ldi	r24, 0xA2	; 162
    1168:	01 c0       	rjmp	.+2      	; 0x116c <SevenSeg_Display+0x7e>
   }
   else if(MAX_DISPLAY_NUMBER < Number)
   {
      /* Set invalid number error. */
      SevenSeg_ErrorState = (E_SEVEN_SEG_ID | E_SEVEN_SEG_INVALID_NUMBER);
    116a:	83 ea       	ldi	r24, 0xA3	; 163
      SevenSeg_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return SevenSeg_ErrorState;
    116c:	df 91       	pop	r29
    116e:	cf 91       	pop	r28
    1170:	1f 91       	pop	r17
    1172:	0f 91       	pop	r16
    1174:	08 95       	ret

00001176 <DIO_SetPinDirection>:
#include "DIO.h"

ERROR_STATE_t DIO_SetPinDirection(uint8_t PortName , uint8_t PinNo ,uint8_t PinDirection)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if((PIN_INPUT!=PinDirection)&&(PIN_OUTPUT!=PinDirection))
    1176:	42 30       	cpi	r20, 0x02	; 2
    1178:	08 f0       	brcs	.+2      	; 0x117c <DIO_SetPinDirection+0x6>
    117a:	60 c0       	rjmp	.+192    	; 0x123c <DIO_SetPinDirection+0xc6>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else if(PinNo>PIN7)
    117c:	68 30       	cpi	r22, 0x08	; 8
    117e:	08 f0       	brcs	.+2      	; 0x1182 <DIO_SetPinDirection+0xc>
    1180:	5f c0       	rjmp	.+190    	; 0x1240 <DIO_SetPinDirection+0xca>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{
		switch(PortName)
    1182:	81 30       	cpi	r24, 0x01	; 1
    1184:	e1 f0       	breq	.+56     	; 0x11be <DIO_SetPinDirection+0x48>
    1186:	30 f0       	brcs	.+12     	; 0x1194 <DIO_SetPinDirection+0x1e>
    1188:	82 30       	cpi	r24, 0x02	; 2
    118a:	71 f1       	breq	.+92     	; 0x11e8 <DIO_SetPinDirection+0x72>
    118c:	83 30       	cpi	r24, 0x03	; 3
    118e:	09 f4       	brne	.+2      	; 0x1192 <DIO_SetPinDirection+0x1c>
    1190:	40 c0       	rjmp	.+128    	; 0x1212 <DIO_SetPinDirection+0x9c>
    1192:	58 c0       	rjmp	.+176    	; 0x1244 <DIO_SetPinDirection+0xce>
		{
			case PORT_A:
				BIT_WRITE(DDRA,PinNo,PinDirection);
    1194:	2a b3       	in	r18, 0x1a	; 26
    1196:	81 e0       	ldi	r24, 0x01	; 1
    1198:	90 e0       	ldi	r25, 0x00	; 0
    119a:	06 2e       	mov	r0, r22
    119c:	02 c0       	rjmp	.+4      	; 0x11a2 <DIO_SetPinDirection+0x2c>
    119e:	88 0f       	add	r24, r24
    11a0:	99 1f       	adc	r25, r25
    11a2:	0a 94       	dec	r0
    11a4:	e2 f7       	brpl	.-8      	; 0x119e <DIO_SetPinDirection+0x28>
    11a6:	50 e0       	ldi	r21, 0x00	; 0
    11a8:	02 c0       	rjmp	.+4      	; 0x11ae <DIO_SetPinDirection+0x38>
    11aa:	44 0f       	add	r20, r20
    11ac:	55 1f       	adc	r21, r21
    11ae:	6a 95       	dec	r22
    11b0:	e2 f7       	brpl	.-8      	; 0x11aa <DIO_SetPinDirection+0x34>
    11b2:	80 95       	com	r24
    11b4:	82 23       	and	r24, r18
    11b6:	48 2b       	or	r20, r24
    11b8:	4a bb       	out	0x1a, r20	; 26
				u8_ErrorState=ERROR_OK;
    11ba:	80 e0       	ldi	r24, 0x00	; 0
				break;
    11bc:	08 95       	ret
			case PORT_B:
				BIT_WRITE(DDRB,PinNo,PinDirection);
    11be:	27 b3       	in	r18, 0x17	; 23
    11c0:	81 e0       	ldi	r24, 0x01	; 1
    11c2:	90 e0       	ldi	r25, 0x00	; 0
    11c4:	06 2e       	mov	r0, r22
    11c6:	02 c0       	rjmp	.+4      	; 0x11cc <DIO_SetPinDirection+0x56>
    11c8:	88 0f       	add	r24, r24
    11ca:	99 1f       	adc	r25, r25
    11cc:	0a 94       	dec	r0
    11ce:	e2 f7       	brpl	.-8      	; 0x11c8 <DIO_SetPinDirection+0x52>
    11d0:	50 e0       	ldi	r21, 0x00	; 0
    11d2:	02 c0       	rjmp	.+4      	; 0x11d8 <DIO_SetPinDirection+0x62>
    11d4:	44 0f       	add	r20, r20
    11d6:	55 1f       	adc	r21, r21
    11d8:	6a 95       	dec	r22
    11da:	e2 f7       	brpl	.-8      	; 0x11d4 <DIO_SetPinDirection+0x5e>
    11dc:	80 95       	com	r24
    11de:	82 23       	and	r24, r18
    11e0:	48 2b       	or	r20, r24
    11e2:	47 bb       	out	0x17, r20	; 23
				u8_ErrorState=ERROR_OK;
    11e4:	80 e0       	ldi	r24, 0x00	; 0
				break;
    11e6:	08 95       	ret
			case PORT_C:
				BIT_WRITE(DDRC,PinNo,PinDirection);
    11e8:	24 b3       	in	r18, 0x14	; 20
    11ea:	81 e0       	ldi	r24, 0x01	; 1
    11ec:	90 e0       	ldi	r25, 0x00	; 0
    11ee:	06 2e       	mov	r0, r22
    11f0:	02 c0       	rjmp	.+4      	; 0x11f6 <DIO_SetPinDirection+0x80>
    11f2:	88 0f       	add	r24, r24
    11f4:	99 1f       	adc	r25, r25
    11f6:	0a 94       	dec	r0
    11f8:	e2 f7       	brpl	.-8      	; 0x11f2 <DIO_SetPinDirection+0x7c>
    11fa:	50 e0       	ldi	r21, 0x00	; 0
    11fc:	02 c0       	rjmp	.+4      	; 0x1202 <DIO_SetPinDirection+0x8c>
    11fe:	44 0f       	add	r20, r20
    1200:	55 1f       	adc	r21, r21
    1202:	6a 95       	dec	r22
    1204:	e2 f7       	brpl	.-8      	; 0x11fe <DIO_SetPinDirection+0x88>
    1206:	80 95       	com	r24
    1208:	82 23       	and	r24, r18
    120a:	48 2b       	or	r20, r24
    120c:	44 bb       	out	0x14, r20	; 20
				u8_ErrorState=ERROR_OK;
    120e:	80 e0       	ldi	r24, 0x00	; 0
				break;
    1210:	08 95       	ret
			case PORT_D:
				BIT_WRITE(DDRD,PinNo,PinDirection);
    1212:	21 b3       	in	r18, 0x11	; 17
    1214:	81 e0       	ldi	r24, 0x01	; 1
    1216:	90 e0       	ldi	r25, 0x00	; 0
    1218:	06 2e       	mov	r0, r22
    121a:	02 c0       	rjmp	.+4      	; 0x1220 <DIO_SetPinDirection+0xaa>
    121c:	88 0f       	add	r24, r24
    121e:	99 1f       	adc	r25, r25
    1220:	0a 94       	dec	r0
    1222:	e2 f7       	brpl	.-8      	; 0x121c <DIO_SetPinDirection+0xa6>
    1224:	50 e0       	ldi	r21, 0x00	; 0
    1226:	02 c0       	rjmp	.+4      	; 0x122c <DIO_SetPinDirection+0xb6>
    1228:	44 0f       	add	r20, r20
    122a:	55 1f       	adc	r21, r21
    122c:	6a 95       	dec	r22
    122e:	e2 f7       	brpl	.-8      	; 0x1228 <DIO_SetPinDirection+0xb2>
    1230:	80 95       	com	r24
    1232:	82 23       	and	r24, r18
    1234:	48 2b       	or	r20, r24
    1236:	41 bb       	out	0x11, r20	; 17
				u8_ErrorState=ERROR_OK;
    1238:	80 e0       	ldi	r24, 0x00	; 0
				break;
    123a:	08 95       	ret
ERROR_STATE_t DIO_SetPinDirection(uint8_t PortName , uint8_t PinNo ,uint8_t PinDirection)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if((PIN_INPUT!=PinDirection)&&(PIN_OUTPUT!=PinDirection))
	{
		u8_ErrorState=ERROR_NOK;
    123c:	81 e0       	ldi	r24, 0x01	; 1
    123e:	08 95       	ret
	}
	else if(PinNo>PIN7)
	{
		u8_ErrorState=ERROR_NOK;
    1240:	81 e0       	ldi	r24, 0x01	; 1
    1242:	08 95       	ret
			case PORT_D:
				BIT_WRITE(DDRD,PinNo,PinDirection);
				u8_ErrorState=ERROR_OK;
				break;
			default:
				u8_ErrorState=ERROR_NOK;
    1244:	81 e0       	ldi	r24, 0x01	; 1
				break;
		}		
	}
	return u8_ErrorState;
}
    1246:	08 95       	ret

00001248 <DIO_WritePin>:

ERROR_STATE_t DIO_WritePin(uint8_t PortName , uint8_t PinNo ,uint8_t PinValue)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if((PIN_LOW!=PinValue)&&(PIN_HIGH!=PinValue))
    1248:	42 30       	cpi	r20, 0x02	; 2
    124a:	08 f0       	brcs	.+2      	; 0x124e <DIO_WritePin+0x6>
    124c:	60 c0       	rjmp	.+192    	; 0x130e <DIO_WritePin+0xc6>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else if(PinNo>PIN7)
    124e:	68 30       	cpi	r22, 0x08	; 8
    1250:	08 f0       	brcs	.+2      	; 0x1254 <DIO_WritePin+0xc>
    1252:	5f c0       	rjmp	.+190    	; 0x1312 <DIO_WritePin+0xca>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{
		switch(PortName)
    1254:	81 30       	cpi	r24, 0x01	; 1
    1256:	e1 f0       	breq	.+56     	; 0x1290 <DIO_WritePin+0x48>
    1258:	30 f0       	brcs	.+12     	; 0x1266 <DIO_WritePin+0x1e>
    125a:	82 30       	cpi	r24, 0x02	; 2
    125c:	71 f1       	breq	.+92     	; 0x12ba <DIO_WritePin+0x72>
    125e:	83 30       	cpi	r24, 0x03	; 3
    1260:	09 f4       	brne	.+2      	; 0x1264 <DIO_WritePin+0x1c>
    1262:	40 c0       	rjmp	.+128    	; 0x12e4 <DIO_WritePin+0x9c>
    1264:	58 c0       	rjmp	.+176    	; 0x1316 <DIO_WritePin+0xce>
		{
			case PORT_A:
				BIT_WRITE(PORTA,PinNo,PinValue);
    1266:	2b b3       	in	r18, 0x1b	; 27
    1268:	81 e0       	ldi	r24, 0x01	; 1
    126a:	90 e0       	ldi	r25, 0x00	; 0
    126c:	06 2e       	mov	r0, r22
    126e:	02 c0       	rjmp	.+4      	; 0x1274 <DIO_WritePin+0x2c>
    1270:	88 0f       	add	r24, r24
    1272:	99 1f       	adc	r25, r25
    1274:	0a 94       	dec	r0
    1276:	e2 f7       	brpl	.-8      	; 0x1270 <DIO_WritePin+0x28>
    1278:	50 e0       	ldi	r21, 0x00	; 0
    127a:	02 c0       	rjmp	.+4      	; 0x1280 <DIO_WritePin+0x38>
    127c:	44 0f       	add	r20, r20
    127e:	55 1f       	adc	r21, r21
    1280:	6a 95       	dec	r22
    1282:	e2 f7       	brpl	.-8      	; 0x127c <DIO_WritePin+0x34>
    1284:	80 95       	com	r24
    1286:	82 23       	and	r24, r18
    1288:	48 2b       	or	r20, r24
    128a:	4b bb       	out	0x1b, r20	; 27
				u8_ErrorState=ERROR_OK;
    128c:	80 e0       	ldi	r24, 0x00	; 0
				break;
    128e:	08 95       	ret
			case PORT_B:
				BIT_WRITE(PORTB,PinNo,PinValue);
    1290:	28 b3       	in	r18, 0x18	; 24
    1292:	81 e0       	ldi	r24, 0x01	; 1
    1294:	90 e0       	ldi	r25, 0x00	; 0
    1296:	06 2e       	mov	r0, r22
    1298:	02 c0       	rjmp	.+4      	; 0x129e <DIO_WritePin+0x56>
    129a:	88 0f       	add	r24, r24
    129c:	99 1f       	adc	r25, r25
    129e:	0a 94       	dec	r0
    12a0:	e2 f7       	brpl	.-8      	; 0x129a <DIO_WritePin+0x52>
    12a2:	50 e0       	ldi	r21, 0x00	; 0
    12a4:	02 c0       	rjmp	.+4      	; 0x12aa <DIO_WritePin+0x62>
    12a6:	44 0f       	add	r20, r20
    12a8:	55 1f       	adc	r21, r21
    12aa:	6a 95       	dec	r22
    12ac:	e2 f7       	brpl	.-8      	; 0x12a6 <DIO_WritePin+0x5e>
    12ae:	80 95       	com	r24
    12b0:	82 23       	and	r24, r18
    12b2:	48 2b       	or	r20, r24
    12b4:	48 bb       	out	0x18, r20	; 24
				u8_ErrorState=ERROR_OK;
    12b6:	80 e0       	ldi	r24, 0x00	; 0
				break;
    12b8:	08 95       	ret
			case PORT_C:
				BIT_WRITE(PORTC,PinNo,PinValue);
    12ba:	25 b3       	in	r18, 0x15	; 21
    12bc:	81 e0       	ldi	r24, 0x01	; 1
    12be:	90 e0       	ldi	r25, 0x00	; 0
    12c0:	06 2e       	mov	r0, r22
    12c2:	02 c0       	rjmp	.+4      	; 0x12c8 <DIO_WritePin+0x80>
    12c4:	88 0f       	add	r24, r24
    12c6:	99 1f       	adc	r25, r25
    12c8:	0a 94       	dec	r0
    12ca:	e2 f7       	brpl	.-8      	; 0x12c4 <DIO_WritePin+0x7c>
    12cc:	50 e0       	ldi	r21, 0x00	; 0
    12ce:	02 c0       	rjmp	.+4      	; 0x12d4 <DIO_WritePin+0x8c>
    12d0:	44 0f       	add	r20, r20
    12d2:	55 1f       	adc	r21, r21
    12d4:	6a 95       	dec	r22
    12d6:	e2 f7       	brpl	.-8      	; 0x12d0 <DIO_WritePin+0x88>
    12d8:	80 95       	com	r24
    12da:	82 23       	and	r24, r18
    12dc:	48 2b       	or	r20, r24
    12de:	45 bb       	out	0x15, r20	; 21
				u8_ErrorState=ERROR_OK;
    12e0:	80 e0       	ldi	r24, 0x00	; 0
				break;
    12e2:	08 95       	ret
			case PORT_D:
				BIT_WRITE(PORTD,PinNo,PinValue);
    12e4:	22 b3       	in	r18, 0x12	; 18
    12e6:	81 e0       	ldi	r24, 0x01	; 1
    12e8:	90 e0       	ldi	r25, 0x00	; 0
    12ea:	06 2e       	mov	r0, r22
    12ec:	02 c0       	rjmp	.+4      	; 0x12f2 <DIO_WritePin+0xaa>
    12ee:	88 0f       	add	r24, r24
    12f0:	99 1f       	adc	r25, r25
    12f2:	0a 94       	dec	r0
    12f4:	e2 f7       	brpl	.-8      	; 0x12ee <DIO_WritePin+0xa6>
    12f6:	50 e0       	ldi	r21, 0x00	; 0
    12f8:	02 c0       	rjmp	.+4      	; 0x12fe <DIO_WritePin+0xb6>
    12fa:	44 0f       	add	r20, r20
    12fc:	55 1f       	adc	r21, r21
    12fe:	6a 95       	dec	r22
    1300:	e2 f7       	brpl	.-8      	; 0x12fa <DIO_WritePin+0xb2>
    1302:	80 95       	com	r24
    1304:	82 23       	and	r24, r18
    1306:	48 2b       	or	r20, r24
    1308:	42 bb       	out	0x12, r20	; 18
				u8_ErrorState=ERROR_OK;
    130a:	80 e0       	ldi	r24, 0x00	; 0
				break;
    130c:	08 95       	ret
ERROR_STATE_t DIO_WritePin(uint8_t PortName , uint8_t PinNo ,uint8_t PinValue)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if((PIN_LOW!=PinValue)&&(PIN_HIGH!=PinValue))
	{
		u8_ErrorState=ERROR_NOK;
    130e:	81 e0       	ldi	r24, 0x01	; 1
    1310:	08 95       	ret
	}
	else if(PinNo>PIN7)
	{
		u8_ErrorState=ERROR_NOK;
    1312:	81 e0       	ldi	r24, 0x01	; 1
    1314:	08 95       	ret
			case PORT_D:
				BIT_WRITE(PORTD,PinNo,PinValue);
				u8_ErrorState=ERROR_OK;
				break;
			default:
				u8_ErrorState=ERROR_NOK;
    1316:	81 e0       	ldi	r24, 0x01	; 1
				break;
		}
	}	
	return u8_ErrorState;
}
    1318:	08 95       	ret

0000131a <PWM_Init>:
		default:
			u8_ErrorState=ERROR_NOK;
			break;			
	}
	return u8_ErrorState;
}
    131a:	83 30       	cpi	r24, 0x03	; 3
    131c:	69 f5       	brne	.+90     	; 0x1378 <PWM_Init+0x5e>
    131e:	85 b5       	in	r24, 0x25	; 37
    1320:	e2 e6       	ldi	r30, 0x62	; 98
    1322:	f0 e0       	ldi	r31, 0x00	; 0
    1324:	92 85       	ldd	r25, Z+10	; 0x0a
    1326:	49 2f       	mov	r20, r25
    1328:	41 70       	andi	r20, 0x01	; 1
    132a:	50 e0       	ldi	r21, 0x00	; 0
    132c:	00 24       	eor	r0, r0
    132e:	56 95       	lsr	r21
    1330:	47 95       	ror	r20
    1332:	07 94       	ror	r0
    1334:	56 95       	lsr	r21
    1336:	47 95       	ror	r20
    1338:	07 94       	ror	r0
    133a:	54 2f       	mov	r21, r20
    133c:	40 2d       	mov	r20, r0
    133e:	8f 7b       	andi	r24, 0xBF	; 191
    1340:	48 2b       	or	r20, r24
    1342:	91 fb       	bst	r25, 1
    1344:	22 27       	eor	r18, r18
    1346:	20 f9       	bld	r18, 0
    1348:	30 e0       	ldi	r19, 0x00	; 0
    134a:	22 0f       	add	r18, r18
    134c:	33 1f       	adc	r19, r19
    134e:	22 0f       	add	r18, r18
    1350:	33 1f       	adc	r19, r19
    1352:	22 0f       	add	r18, r18
    1354:	33 1f       	adc	r19, r19
    1356:	47 7f       	andi	r20, 0xF7	; 247
    1358:	24 2b       	or	r18, r20
    135a:	83 85       	ldd	r24, Z+11	; 0x0b
    135c:	30 e1       	ldi	r19, 0x10	; 16
    135e:	83 9f       	mul	r24, r19
    1360:	c0 01       	movw	r24, r0
    1362:	11 24       	eor	r1, r1
    1364:	2f 7c       	andi	r18, 0xCF	; 207
    1366:	28 2b       	or	r18, r24
    1368:	25 bd       	out	0x25, r18	; 37
    136a:	41 e0       	ldi	r20, 0x01	; 1
    136c:	67 e0       	ldi	r22, 0x07	; 7
    136e:	83 e0       	ldi	r24, 0x03	; 3
    1370:	0e 94 bb 08 	call	0x1176	; 0x1176 <DIO_SetPinDirection>
    1374:	80 e0       	ldi	r24, 0x00	; 0
    1376:	08 95       	ret
    1378:	81 e0       	ldi	r24, 0x01	; 1
    137a:	08 95       	ret

0000137c <PWM_Start>:
    137c:	83 30       	cpi	r24, 0x03	; 3
    137e:	41 f4       	brne	.+16     	; 0x1390 <PWM_Start+0x14>
    1380:	85 b5       	in	r24, 0x25	; 37
    1382:	90 91 6b 00 	lds	r25, 0x006B	; 0x80006b <gastr_PWMConfig+0x9>
    1386:	88 7f       	andi	r24, 0xF8	; 248
    1388:	89 2b       	or	r24, r25
    138a:	85 bd       	out	0x25, r24	; 37
    138c:	80 e0       	ldi	r24, 0x00	; 0
    138e:	08 95       	ret
    1390:	81 e0       	ldi	r24, 0x01	; 1
    1392:	08 95       	ret

00001394 <PWM_Connect>:
    1394:	83 30       	cpi	r24, 0x03	; 3
    1396:	69 f4       	brne	.+26     	; 0x13b2 <PWM_Connect+0x1e>
    1398:	25 b5       	in	r18, 0x25	; 37
    139a:	90 91 6d 00 	lds	r25, 0x006D	; 0x80006d <gastr_PWMConfig+0xb>
    139e:	30 e1       	ldi	r19, 0x10	; 16
    13a0:	93 9f       	mul	r25, r19
    13a2:	c0 01       	movw	r24, r0
    13a4:	11 24       	eor	r1, r1
    13a6:	92 2f       	mov	r25, r18
    13a8:	9f 7c       	andi	r25, 0xCF	; 207
    13aa:	89 2b       	or	r24, r25
    13ac:	85 bd       	out	0x25, r24	; 37
    13ae:	80 e0       	ldi	r24, 0x00	; 0
    13b0:	08 95       	ret
    13b2:	81 e0       	ldi	r24, 0x01	; 1
    13b4:	08 95       	ret

000013b6 <PWM_SetDuty>:

ERROR_STATE_t PWM_SetDuty(uint8_t PwmChannelNumber,uint8_t PwmDuty )
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PwmDuty==0||PwmDuty>100)
    13b6:	9f ef       	ldi	r25, 0xFF	; 255
    13b8:	96 0f       	add	r25, r22
    13ba:	94 36       	cpi	r25, 0x64	; 100
    13bc:	10 f5       	brcc	.+68     	; 0x1402 <PWM_SetDuty+0x4c>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{
		switch(PwmChannelNumber)
    13be:	83 30       	cpi	r24, 0x03	; 3
    13c0:	11 f5       	brne	.+68     	; 0x1406 <PWM_SetDuty+0x50>
					break;	
			#endif	
			
			#if OC2
				case PWM_CHANNEL_OC2:
					switch(gastr_PWMConfig[PWM_CHANNEL_OC2].PWMWaveformMode)
    13c2:	80 91 6d 00 	lds	r24, 0x006D	; 0x80006d <gastr_PWMConfig+0xb>
    13c6:	82 30       	cpi	r24, 0x02	; 2
    13c8:	01 f5       	brne	.+64     	; 0x140a <PWM_SetDuty+0x54>
					{
						case NON_INVERTING:
							OCR2 = (uint8_t)(((PwmDuty/100.0)*256.0)-1);
    13ca:	70 e0       	ldi	r23, 0x00	; 0
    13cc:	80 e0       	ldi	r24, 0x00	; 0
    13ce:	90 e0       	ldi	r25, 0x00	; 0
    13d0:	0e 94 56 0c 	call	0x18ac	; 0x18ac <__floatsisf>
    13d4:	20 e0       	ldi	r18, 0x00	; 0
    13d6:	30 e0       	ldi	r19, 0x00	; 0
    13d8:	48 ec       	ldi	r20, 0xC8	; 200
    13da:	52 e4       	ldi	r21, 0x42	; 66
    13dc:	0e 94 b3 0b 	call	0x1766	; 0x1766 <__divsf3>
    13e0:	20 e0       	ldi	r18, 0x00	; 0
    13e2:	30 e0       	ldi	r19, 0x00	; 0
    13e4:	40 e8       	ldi	r20, 0x80	; 128
    13e6:	53 e4       	ldi	r21, 0x43	; 67
    13e8:	0e 94 e2 0c 	call	0x19c4	; 0x19c4 <__mulsf3>
    13ec:	20 e0       	ldi	r18, 0x00	; 0
    13ee:	30 e0       	ldi	r19, 0x00	; 0
    13f0:	40 e8       	ldi	r20, 0x80	; 128
    13f2:	5f e3       	ldi	r21, 0x3F	; 63
    13f4:	0e 94 46 0b 	call	0x168c	; 0x168c <__subsf3>
    13f8:	0e 94 25 0c 	call	0x184a	; 0x184a <__fixunssfsi>
    13fc:	63 bd       	out	0x23, r22	; 35
							u8_ErrorState=ERROR_OK;
    13fe:	80 e0       	ldi	r24, 0x00	; 0
							break;
    1400:	08 95       	ret
ERROR_STATE_t PWM_SetDuty(uint8_t PwmChannelNumber,uint8_t PwmDuty )
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PwmDuty==0||PwmDuty>100)
	{
		u8_ErrorState=ERROR_NOK;
    1402:	81 e0       	ldi	r24, 0x01	; 1
    1404:	08 95       	ret
							break;
					}
					break;
			#endif	
			default:
				u8_ErrorState=ERROR_NOK;
    1406:	81 e0       	ldi	r24, 0x01	; 1
    1408:	08 95       	ret
						case NON_INVERTING:
							OCR2 = (uint8_t)(((PwmDuty/100.0)*256.0)-1);
							u8_ErrorState=ERROR_OK;
							break;
						default:
							u8_ErrorState=ERROR_NOK;
    140a:	81 e0       	ldi	r24, 0x01	; 1
				u8_ErrorState=ERROR_NOK;
				break;			
		}		
	}
	return u8_ErrorState;
    140c:	08 95       	ret

0000140e <Indicator_MainFunction>:
* @brief: This function is the indicator main function.
*
* @return function error state.
*/
extern void Indicator_MainFunction(void)
{
    140e:	cf 93       	push	r28
    1410:	df 93       	push	r29
    1412:	00 d0       	rcall	.+0      	; 0x1414 <Indicator_MainFunction+0x6>
    1414:	1f 92       	push	r1
    1416:	cd b7       	in	r28, 0x3d	; 61
    1418:	de b7       	in	r29, 0x3e	; 62
   /* OS Variable used for calculating the function waiting period. */
   portTickType xLastWakeTime;
   xLastWakeTime=xTaskGetTickCount();
    141a:	0e 94 50 05 	call	0xaa0	; 0xaa0 <xTaskGetTickCount>
    141e:	9a 83       	std	Y+2, r25	; 0x02
    1420:	89 83       	std	Y+1, r24	; 0x01
   static uint8_t u8_OldPattern = INDICATOR_INVALID_PATTERN;
   static Enu_IndicatorStateMachine State = Indicator_LowTime;
   static uint8_t u8_Duty = 0;
   
   /* Initialization sequence. */
   if (u8_Init == 0)
    1422:	80 91 32 07 	lds	r24, 0x0732	; 0x800732 <u8_Init.1970>
    1426:	81 11       	cpse	r24, r1
    1428:	07 c0       	rjmp	.+14     	; 0x1438 <Indicator_MainFunction+0x2a>
   {
      LED_Init(LED_UsedChannel);
    142a:	80 91 cb 00 	lds	r24, 0x00CB	; 0x8000cb <LED_UsedChannel>
    142e:	0e 94 1b 07 	call	0xe36	; 0xe36 <LED_Init>
      u8_Init = 1;
    1432:	81 e0       	ldi	r24, 0x01	; 1
    1434:	80 93 32 07 	sts	0x0732, r24	; 0x800732 <u8_Init.1970>
   }
   
   /* Get the current pattern. */
   Indicator_GetPattern(&u8_Pattern);
    1438:	ce 01       	movw	r24, r28
    143a:	03 96       	adiw	r24, 0x03	; 3
    143c:	0e 94 b6 0a 	call	0x156c	; 0x156c <Indicator_GetPattern>
   
   /* If a new pattern is set. */
   if( u8_Pattern != u8_OldPattern)
    1440:	eb 81       	ldd	r30, Y+3	; 0x03
    1442:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
    1446:	e8 17       	cp	r30, r24
    1448:	31 f0       	breq	.+12     	; 0x1456 <Indicator_MainFunction+0x48>
   {
      u8_OldPattern = u8_Pattern;
    144a:	e0 93 60 00 	sts	0x0060, r30	; 0x800060 <__data_start>
      /* Reinitialize the state and the duty cycle. */
      State = Indicator_LowTime;
    144e:	10 92 31 07 	sts	0x0731, r1	; 0x800731 <State.1973>
      u8_Duty = MIN_DUTY;
    1452:	10 92 30 07 	sts	0x0730, r1	; 0x800730 <u8_Duty.1974>
   }
   
   if(INDICATOR_INVALID_PATTERN != u8_Pattern)
    1456:	e4 30       	cpi	r30, 0x04	; 4
    1458:	09 f4       	brne	.+2      	; 0x145c <Indicator_MainFunction+0x4e>
    145a:	82 c0       	rjmp	.+260    	; 0x1560 <Indicator_MainFunction+0x152>
   {
      switch(State)
    145c:	80 91 31 07 	lds	r24, 0x0731	; 0x800731 <State.1973>
    1460:	81 30       	cpi	r24, 0x01	; 1
    1462:	f9 f0       	breq	.+62     	; 0x14a2 <Indicator_MainFunction+0x94>
    1464:	38 f0       	brcs	.+14     	; 0x1474 <Indicator_MainFunction+0x66>
    1466:	82 30       	cpi	r24, 0x02	; 2
    1468:	09 f4       	brne	.+2      	; 0x146c <Indicator_MainFunction+0x5e>
    146a:	40 c0       	rjmp	.+128    	; 0x14ec <Indicator_MainFunction+0xde>
    146c:	83 30       	cpi	r24, 0x03	; 3
    146e:	09 f4       	brne	.+2      	; 0x1472 <Indicator_MainFunction+0x64>
    1470:	54 c0       	rjmp	.+168    	; 0x151a <Indicator_MainFunction+0x10c>
    1472:	76 c0       	rjmp	.+236    	; 0x1560 <Indicator_MainFunction+0x152>
      {
         case Indicator_LowTime:
            /* Turn off led */
            LED_Off(LED_UsedChannel);
    1474:	80 91 cb 00 	lds	r24, 0x00CB	; 0x8000cb <LED_UsedChannel>
    1478:	0e 94 81 07 	call	0xf02	; 0xf02 <LED_Off>
            /* Change state to rise time state. */
            State = Indicator_RiseTime;
    147c:	81 e0       	ldi	r24, 0x01	; 1
    147e:	80 93 31 07 	sts	0x0731, r24	; 0x800731 <State.1973>
            /* Put the task in waiting state for the low time period. */
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u32_LowTime);
    1482:	eb 81       	ldd	r30, Y+3	; 0x03
    1484:	86 e1       	ldi	r24, 0x16	; 22
    1486:	e8 9f       	mul	r30, r24
    1488:	f0 01       	movw	r30, r0
    148a:	11 24       	eor	r1, r1
    148c:	ed 58       	subi	r30, 0x8D	; 141
    148e:	ff 4f       	sbci	r31, 0xFF	; 255
    1490:	60 89       	ldd	r22, Z+16	; 0x10
    1492:	71 89       	ldd	r23, Z+17	; 0x11
    1494:	82 89       	ldd	r24, Z+18	; 0x12
    1496:	93 89       	ldd	r25, Z+19	; 0x13
    1498:	ce 01       	movw	r24, r28
    149a:	01 96       	adiw	r24, 0x01	; 1
    149c:	0e 94 86 06 	call	0xd0c	; 0xd0c <vTaskDelayUntil>
            break;
    14a0:	5f c0       	rjmp	.+190    	; 0x1560 <Indicator_MainFunction+0x152>
         case Indicator_RiseTime:
            /* Increase the duty with the rate of change. */
            u8_Duty += aSTR_IndicatorConfig[u8_Pattern].u8_RateOfChange;
    14a2:	86 e1       	ldi	r24, 0x16	; 22
    14a4:	e8 9f       	mul	r30, r24
    14a6:	f0 01       	movw	r30, r0
    14a8:	11 24       	eor	r1, r1
    14aa:	ed 58       	subi	r30, 0x8D	; 141
    14ac:	ff 4f       	sbci	r31, 0xFF	; 255
    14ae:	65 89       	ldd	r22, Z+21	; 0x15
    14b0:	80 91 30 07 	lds	r24, 0x0730	; 0x800730 <u8_Duty.1974>
    14b4:	68 0f       	add	r22, r24
    14b6:	60 93 30 07 	sts	0x0730, r22	; 0x800730 <u8_Duty.1974>
            /* Dim the led with the current duty cycle. */
            LED_Dim(LED_UsedChannel, u8_Duty);
    14ba:	80 91 cb 00 	lds	r24, 0x00CB	; 0x8000cb <LED_UsedChannel>
    14be:	0e 94 fd 07 	call	0xffa	; 0xffa <LED_Dim>
            /* Change state to high time state. */
            if(u8_Duty == MAX_DUTY)
    14c2:	80 91 30 07 	lds	r24, 0x0730	; 0x800730 <u8_Duty.1974>
    14c6:	84 36       	cpi	r24, 0x64	; 100
    14c8:	19 f4       	brne	.+6      	; 0x14d0 <Indicator_MainFunction+0xc2>
            {
               State = Indicator_HighTime;
    14ca:	82 e0       	ldi	r24, 0x02	; 2
    14cc:	80 93 31 07 	sts	0x0731, r24	; 0x800731 <State.1973>
            }
            /* Put the task in waiting state for the step time period. */
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u8_StepTime);
    14d0:	eb 81       	ldd	r30, Y+3	; 0x03
    14d2:	86 e1       	ldi	r24, 0x16	; 22
    14d4:	e8 9f       	mul	r30, r24
    14d6:	f0 01       	movw	r30, r0
    14d8:	11 24       	eor	r1, r1
    14da:	ed 58       	subi	r30, 0x8D	; 141
    14dc:	ff 4f       	sbci	r31, 0xFF	; 255
    14de:	64 89       	ldd	r22, Z+20	; 0x14
    14e0:	70 e0       	ldi	r23, 0x00	; 0
    14e2:	ce 01       	movw	r24, r28
    14e4:	01 96       	adiw	r24, 0x01	; 1
    14e6:	0e 94 86 06 	call	0xd0c	; 0xd0c <vTaskDelayUntil>
            break;
    14ea:	3a c0       	rjmp	.+116    	; 0x1560 <Indicator_MainFunction+0x152>
         case Indicator_HighTime:
            /* Turn led on. */
            LED_On(LED_UsedChannel);
    14ec:	80 91 cb 00 	lds	r24, 0x00CB	; 0x8000cb <LED_UsedChannel>
    14f0:	0e 94 bf 07 	call	0xf7e	; 0xf7e <LED_On>
            /* Change state to fall time state. */
            State = Indicator_FallTime;
    14f4:	83 e0       	ldi	r24, 0x03	; 3
    14f6:	80 93 31 07 	sts	0x0731, r24	; 0x800731 <State.1973>
            /* Put the task in waiting state for the high time period. */
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u32_HighTime);
    14fa:	eb 81       	ldd	r30, Y+3	; 0x03
    14fc:	86 e1       	ldi	r24, 0x16	; 22
    14fe:	e8 9f       	mul	r30, r24
    1500:	f0 01       	movw	r30, r0
    1502:	11 24       	eor	r1, r1
    1504:	ed 58       	subi	r30, 0x8D	; 141
    1506:	ff 4f       	sbci	r31, 0xFF	; 255
    1508:	64 81       	ldd	r22, Z+4	; 0x04
    150a:	75 81       	ldd	r23, Z+5	; 0x05
    150c:	86 81       	ldd	r24, Z+6	; 0x06
    150e:	97 81       	ldd	r25, Z+7	; 0x07
    1510:	ce 01       	movw	r24, r28
    1512:	01 96       	adiw	r24, 0x01	; 1
    1514:	0e 94 86 06 	call	0xd0c	; 0xd0c <vTaskDelayUntil>
            break;
    1518:	23 c0       	rjmp	.+70     	; 0x1560 <Indicator_MainFunction+0x152>
         case Indicator_FallTime:
            /* decrease the duty with the rate of change. */
            u8_Duty -= aSTR_IndicatorConfig[u8_Pattern].u8_RateOfChange;
    151a:	86 e1       	ldi	r24, 0x16	; 22
    151c:	e8 9f       	mul	r30, r24
    151e:	f0 01       	movw	r30, r0
    1520:	11 24       	eor	r1, r1
    1522:	ed 58       	subi	r30, 0x8D	; 141
    1524:	ff 4f       	sbci	r31, 0xFF	; 255
    1526:	85 89       	ldd	r24, Z+21	; 0x15
    1528:	60 91 30 07 	lds	r22, 0x0730	; 0x800730 <u8_Duty.1974>
    152c:	68 1b       	sub	r22, r24
    152e:	60 93 30 07 	sts	0x0730, r22	; 0x800730 <u8_Duty.1974>
            /* Dim the led with the current duty cycle. */
            LED_Dim(LED_UsedChannel, u8_Duty);
    1532:	80 91 cb 00 	lds	r24, 0x00CB	; 0x8000cb <LED_UsedChannel>
    1536:	0e 94 fd 07 	call	0xffa	; 0xffa <LED_Dim>
            /* Change state to low time state. */
            if(u8_Duty == MIN_DUTY)
    153a:	80 91 30 07 	lds	r24, 0x0730	; 0x800730 <u8_Duty.1974>
    153e:	81 11       	cpse	r24, r1
    1540:	02 c0       	rjmp	.+4      	; 0x1546 <Indicator_MainFunction+0x138>
            {
               State = Indicator_LowTime;
    1542:	10 92 31 07 	sts	0x0731, r1	; 0x800731 <State.1973>
            }
            /* Put the task in waiting state for the step time period. */
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u8_StepTime);
    1546:	eb 81       	ldd	r30, Y+3	; 0x03
    1548:	86 e1       	ldi	r24, 0x16	; 22
    154a:	e8 9f       	mul	r30, r24
    154c:	f0 01       	movw	r30, r0
    154e:	11 24       	eor	r1, r1
    1550:	ed 58       	subi	r30, 0x8D	; 141
    1552:	ff 4f       	sbci	r31, 0xFF	; 255
    1554:	64 89       	ldd	r22, Z+20	; 0x14
    1556:	70 e0       	ldi	r23, 0x00	; 0
    1558:	ce 01       	movw	r24, r28
    155a:	01 96       	adiw	r24, 0x01	; 1
    155c:	0e 94 86 06 	call	0xd0c	; 0xd0c <vTaskDelayUntil>
            break;
      }
   }
    1560:	0f 90       	pop	r0
    1562:	0f 90       	pop	r0
    1564:	0f 90       	pop	r0
    1566:	df 91       	pop	r29
    1568:	cf 91       	pop	r28
    156a:	08 95       	ret

0000156c <Indicator_GetPattern>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t Indicator_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Value)
    156c:	00 97       	sbiw	r24, 0x00	; 0
    156e:	31 f0       	breq	.+12     	; 0x157c <Indicator_GetPattern+0x10>
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_NULL_PTR);
   }
   else
   {
      /* Return the indicator pattern. */
      *Value = gu8_IndicatorPattern;
    1570:	20 91 61 00 	lds	r18, 0x0061	; 0x800061 <gu8_IndicatorPattern>
    1574:	fc 01       	movw	r30, r24
    1576:	20 83       	st	Z, r18
      Indicator_ErrorState = ERROR_OK;
    1578:	80 e0       	ldi	r24, 0x00	; 0
    157a:	08 95       	ret
   
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Value)
   {
      /* Set null pointer error. */
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_NULL_PTR);
    157c:	82 eb       	ldi	r24, 0xB2	; 178
      Indicator_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return Indicator_ErrorState;
}
    157e:	08 95       	ret

00001580 <SSD_Display_MainFunction>:
* @brief: This function is the Display main function.
*
* @return function error state.
*/
extern void SSD_Display_MainFunction(void)
{
    1580:	0f 93       	push	r16
    1582:	1f 93       	push	r17
    1584:	cf 93       	push	r28
    1586:	df 93       	push	r29
    1588:	1f 92       	push	r1
    158a:	cd b7       	in	r28, 0x3d	; 61
    158c:	de b7       	in	r29, 0x3e	; 62
   static uint8_t u8_Init = 0;  
   uint8_t u8_SevenSegmentNumber; 
   static Enu_SSDDisplayStateMachine State = SSD_Display_FirstNumber;
   
   /* Initialization sequence. */
   if (u8_Init == 0)
    158e:	80 91 34 07 	lds	r24, 0x0734	; 0x800734 <u8_Init.1652>
    1592:	81 11       	cpse	r24, r1
    1594:	0d c0       	rjmp	.+26     	; 0x15b0 <SSD_Display_MainFunction+0x30>
   {
      SevenSeg_Init(STR_DisplaySegmentConfig.u8_SegmentCh0);
    1596:	0c ec       	ldi	r16, 0xCC	; 204
    1598:	10 e0       	ldi	r17, 0x00	; 0
    159a:	f8 01       	movw	r30, r16
    159c:	80 81       	ld	r24, Z
    159e:	0e 94 3f 08 	call	0x107e	; 0x107e <SevenSeg_Init>
      SevenSeg_Init(STR_DisplaySegmentConfig.u8_SegmentCh1);
    15a2:	f8 01       	movw	r30, r16
    15a4:	81 81       	ldd	r24, Z+1	; 0x01
    15a6:	0e 94 3f 08 	call	0x107e	; 0x107e <SevenSeg_Init>
      u8_Init = 1;
    15aa:	81 e0       	ldi	r24, 0x01	; 1
    15ac:	80 93 34 07 	sts	0x0734, r24	; 0x800734 <u8_Init.1652>
   }
   
   /* Get the number to display. */
   SSD_Display_GetSevenSegment(&u8_SevenSegmentNumber);
    15b0:	ce 01       	movw	r24, r28
    15b2:	01 96       	adiw	r24, 0x01	; 1
    15b4:	0e 94 0d 0b 	call	0x161a	; 0x161a <SSD_Display_GetSevenSegment>
   
   switch(State)
    15b8:	80 91 33 07 	lds	r24, 0x0733	; 0x800733 <State.1654>
    15bc:	88 23       	and	r24, r24
    15be:	19 f0       	breq	.+6      	; 0x15c6 <SSD_Display_MainFunction+0x46>
    15c0:	81 30       	cpi	r24, 0x01	; 1
    15c2:	b9 f0       	breq	.+46     	; 0x15f2 <SSD_Display_MainFunction+0x72>
    15c4:	24 c0       	rjmp	.+72     	; 0x160e <SSD_Display_MainFunction+0x8e>
   {
      case SSD_Display_FirstNumber:
         /* Display the first number. */
         SevenSeg_Display(STR_DisplaySegmentConfig.u8_SegmentCh0, u8_SevenSegmentNumber%10);
    15c6:	69 81       	ldd	r22, Y+1	; 0x01
    15c8:	8d ec       	ldi	r24, 0xCD	; 205
    15ca:	68 9f       	mul	r22, r24
    15cc:	81 2d       	mov	r24, r1
    15ce:	11 24       	eor	r1, r1
    15d0:	86 95       	lsr	r24
    15d2:	86 95       	lsr	r24
    15d4:	86 95       	lsr	r24
    15d6:	88 0f       	add	r24, r24
    15d8:	98 2f       	mov	r25, r24
    15da:	99 0f       	add	r25, r25
    15dc:	99 0f       	add	r25, r25
    15de:	89 0f       	add	r24, r25
    15e0:	68 1b       	sub	r22, r24
    15e2:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <STR_DisplaySegmentConfig>
    15e6:	0e 94 77 08 	call	0x10ee	; 0x10ee <SevenSeg_Display>
         State = SSD_Display_SecondNumber;
    15ea:	81 e0       	ldi	r24, 0x01	; 1
    15ec:	80 93 33 07 	sts	0x0733, r24	; 0x800733 <State.1654>
         break;
    15f0:	0e c0       	rjmp	.+28     	; 0x160e <SSD_Display_MainFunction+0x8e>
      case SSD_Display_SecondNumber:
         /* Display the second number. */
         SevenSeg_Display(STR_DisplaySegmentConfig.u8_SegmentCh1, u8_SevenSegmentNumber/10);
    15f2:	89 81       	ldd	r24, Y+1	; 0x01
    15f4:	6d ec       	ldi	r22, 0xCD	; 205
    15f6:	86 9f       	mul	r24, r22
    15f8:	61 2d       	mov	r22, r1
    15fa:	11 24       	eor	r1, r1
    15fc:	66 95       	lsr	r22
    15fe:	66 95       	lsr	r22
    1600:	66 95       	lsr	r22
    1602:	80 91 cd 00 	lds	r24, 0x00CD	; 0x8000cd <STR_DisplaySegmentConfig+0x1>
    1606:	0e 94 77 08 	call	0x10ee	; 0x10ee <SevenSeg_Display>
         State = SSD_Display_FirstNumber;
    160a:	10 92 33 07 	sts	0x0733, r1	; 0x800733 <State.1654>
         break;
   }      
    160e:	0f 90       	pop	r0
    1610:	df 91       	pop	r29
    1612:	cf 91       	pop	r28
    1614:	1f 91       	pop	r17
    1616:	0f 91       	pop	r16
    1618:	08 95       	ret

0000161a <SSD_Display_GetSevenSegment>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t Display_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Value)
    161a:	00 97       	sbiw	r24, 0x00	; 0
    161c:	31 f0       	breq	.+12     	; 0x162a <SSD_Display_GetSevenSegment+0x10>
      Display_ErrorState = (E_DISPLAY_ID | E_DISPLAY_NULL_PTR);
   }
   else
   {
      /* Return the segment value. */
      *Value = gu8_SevenSegmentValue;
    161e:	20 91 35 07 	lds	r18, 0x0735	; 0x800735 <gu8_SevenSegmentValue>
    1622:	fc 01       	movw	r30, r24
    1624:	20 83       	st	Z, r18
      Display_ErrorState = ERROR_OK;
    1626:	80 e0       	ldi	r24, 0x00	; 0
    1628:	08 95       	ret
   
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Value)
   {
      /* Set null pointer error. */
      Display_ErrorState = (E_DISPLAY_ID | E_DISPLAY_NULL_PTR);
    162a:	82 e9       	ldi	r24, 0x92	; 146
      Display_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return Display_ErrorState;
}
    162c:	08 95       	ret

0000162e <Feedback_Task>:

void Feedback_Task( void *pvParameters )
{  
   for( ;; )
   {
      Indicator_MainFunction();
    162e:	0e 94 07 0a 	call	0x140e	; 0x140e <Indicator_MainFunction>
    1632:	fd cf       	rjmp	.-6      	; 0x162e <Feedback_Task>

00001634 <SSD_Display_Task>:
   }
}

void SSD_Display_Task( void *pvParameters )
{
    1634:	cf 93       	push	r28
    1636:	df 93       	push	r29
    1638:	00 d0       	rcall	.+0      	; 0x163a <SSD_Display_Task+0x6>
    163a:	cd b7       	in	r28, 0x3d	; 61
    163c:	de b7       	in	r29, 0x3e	; 62
   portTickType xLastWakeTime;
   xLastWakeTime=xTaskGetTickCount();
    163e:	0e 94 50 05 	call	0xaa0	; 0xaa0 <xTaskGetTickCount>
    1642:	9a 83       	std	Y+2, r25	; 0x02
    1644:	89 83       	std	Y+1, r24	; 0x01
   
   for( ;; )
   {
      SSD_Display_MainFunction();
    1646:	0e 94 c0 0a 	call	0x1580	; 0x1580 <SSD_Display_MainFunction>
      vTaskDelayUntil(&xLastWakeTime, 10);
    164a:	6a e0       	ldi	r22, 0x0A	; 10
    164c:	70 e0       	ldi	r23, 0x00	; 0
    164e:	ce 01       	movw	r24, r28
    1650:	01 96       	adiw	r24, 0x01	; 1
    1652:	0e 94 86 06 	call	0xd0c	; 0xd0c <vTaskDelayUntil>
    1656:	f7 cf       	rjmp	.-18     	; 0x1646 <SSD_Display_Task+0x12>

00001658 <main>:
}
#endif

int main(void)
{   
   xTaskCreate( Feedback_Task, "Indicator", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );
    1658:	e1 2c       	mov	r14, r1
    165a:	f1 2c       	mov	r15, r1
    165c:	01 e0       	ldi	r16, 0x01	; 1
    165e:	20 e0       	ldi	r18, 0x00	; 0
    1660:	30 e0       	ldi	r19, 0x00	; 0
    1662:	45 e5       	ldi	r20, 0x55	; 85
    1664:	50 e0       	ldi	r21, 0x00	; 0
    1666:	6a ed       	ldi	r22, 0xDA	; 218
    1668:	70 e0       	ldi	r23, 0x00	; 0
    166a:	87 e1       	ldi	r24, 0x17	; 23
    166c:	9b e0       	ldi	r25, 0x0B	; 11
    166e:	0e 94 cc 04 	call	0x998	; 0x998 <xTaskCreate>
   xTaskCreate( SSD_Display_Task, "SevenSegment", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );
    1672:	20 e0       	ldi	r18, 0x00	; 0
    1674:	30 e0       	ldi	r19, 0x00	; 0
    1676:	45 e5       	ldi	r20, 0x55	; 85
    1678:	50 e0       	ldi	r21, 0x00	; 0
    167a:	64 ee       	ldi	r22, 0xE4	; 228
    167c:	70 e0       	ldi	r23, 0x00	; 0
    167e:	8a e1       	ldi	r24, 0x1A	; 26
    1680:	9b e0       	ldi	r25, 0x0B	; 11
    1682:	0e 94 cc 04 	call	0x998	; 0x998 <xTaskCreate>
   /*xTaskCreate( NumberChange_Task, "number", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );*/
   
   vTaskStartScheduler();
    1686:	0e 94 20 05 	call	0xa40	; 0xa40 <vTaskStartScheduler>
    168a:	ff cf       	rjmp	.-2      	; 0x168a <main+0x32>

0000168c <__subsf3>:
    168c:	50 58       	subi	r21, 0x80	; 128

0000168e <__addsf3>:
    168e:	bb 27       	eor	r27, r27
    1690:	aa 27       	eor	r26, r26
    1692:	0e 94 5e 0b 	call	0x16bc	; 0x16bc <__addsf3x>
    1696:	0c 94 a8 0c 	jmp	0x1950	; 0x1950 <__fp_round>
    169a:	0e 94 9a 0c 	call	0x1934	; 0x1934 <__fp_pscA>
    169e:	38 f0       	brcs	.+14     	; 0x16ae <__addsf3+0x20>
    16a0:	0e 94 a1 0c 	call	0x1942	; 0x1942 <__fp_pscB>
    16a4:	20 f0       	brcs	.+8      	; 0x16ae <__addsf3+0x20>
    16a6:	39 f4       	brne	.+14     	; 0x16b6 <__addsf3+0x28>
    16a8:	9f 3f       	cpi	r25, 0xFF	; 255
    16aa:	19 f4       	brne	.+6      	; 0x16b2 <__addsf3+0x24>
    16ac:	26 f4       	brtc	.+8      	; 0x16b6 <__addsf3+0x28>
    16ae:	0c 94 97 0c 	jmp	0x192e	; 0x192e <__fp_nan>
    16b2:	0e f4       	brtc	.+2      	; 0x16b6 <__addsf3+0x28>
    16b4:	e0 95       	com	r30
    16b6:	e7 fb       	bst	r30, 7
    16b8:	0c 94 91 0c 	jmp	0x1922	; 0x1922 <__fp_inf>

000016bc <__addsf3x>:
    16bc:	e9 2f       	mov	r30, r25
    16be:	0e 94 b9 0c 	call	0x1972	; 0x1972 <__fp_split3>
    16c2:	58 f3       	brcs	.-42     	; 0x169a <__addsf3+0xc>
    16c4:	ba 17       	cp	r27, r26
    16c6:	62 07       	cpc	r22, r18
    16c8:	73 07       	cpc	r23, r19
    16ca:	84 07       	cpc	r24, r20
    16cc:	95 07       	cpc	r25, r21
    16ce:	20 f0       	brcs	.+8      	; 0x16d8 <__addsf3x+0x1c>
    16d0:	79 f4       	brne	.+30     	; 0x16f0 <__addsf3x+0x34>
    16d2:	a6 f5       	brtc	.+104    	; 0x173c <__addsf3x+0x80>
    16d4:	0c 94 db 0c 	jmp	0x19b6	; 0x19b6 <__fp_zero>
    16d8:	0e f4       	brtc	.+2      	; 0x16dc <__addsf3x+0x20>
    16da:	e0 95       	com	r30
    16dc:	0b 2e       	mov	r0, r27
    16de:	ba 2f       	mov	r27, r26
    16e0:	a0 2d       	mov	r26, r0
    16e2:	0b 01       	movw	r0, r22
    16e4:	b9 01       	movw	r22, r18
    16e6:	90 01       	movw	r18, r0
    16e8:	0c 01       	movw	r0, r24
    16ea:	ca 01       	movw	r24, r20
    16ec:	a0 01       	movw	r20, r0
    16ee:	11 24       	eor	r1, r1
    16f0:	ff 27       	eor	r31, r31
    16f2:	59 1b       	sub	r21, r25
    16f4:	99 f0       	breq	.+38     	; 0x171c <__addsf3x+0x60>
    16f6:	59 3f       	cpi	r21, 0xF9	; 249
    16f8:	50 f4       	brcc	.+20     	; 0x170e <__addsf3x+0x52>
    16fa:	50 3e       	cpi	r21, 0xE0	; 224
    16fc:	68 f1       	brcs	.+90     	; 0x1758 <__addsf3x+0x9c>
    16fe:	1a 16       	cp	r1, r26
    1700:	f0 40       	sbci	r31, 0x00	; 0
    1702:	a2 2f       	mov	r26, r18
    1704:	23 2f       	mov	r18, r19
    1706:	34 2f       	mov	r19, r20
    1708:	44 27       	eor	r20, r20
    170a:	58 5f       	subi	r21, 0xF8	; 248
    170c:	f3 cf       	rjmp	.-26     	; 0x16f4 <__addsf3x+0x38>
    170e:	46 95       	lsr	r20
    1710:	37 95       	ror	r19
    1712:	27 95       	ror	r18
    1714:	a7 95       	ror	r26
    1716:	f0 40       	sbci	r31, 0x00	; 0
    1718:	53 95       	inc	r21
    171a:	c9 f7       	brne	.-14     	; 0x170e <__addsf3x+0x52>
    171c:	7e f4       	brtc	.+30     	; 0x173c <__addsf3x+0x80>
    171e:	1f 16       	cp	r1, r31
    1720:	ba 0b       	sbc	r27, r26
    1722:	62 0b       	sbc	r22, r18
    1724:	73 0b       	sbc	r23, r19
    1726:	84 0b       	sbc	r24, r20
    1728:	ba f0       	brmi	.+46     	; 0x1758 <__addsf3x+0x9c>
    172a:	91 50       	subi	r25, 0x01	; 1
    172c:	a1 f0       	breq	.+40     	; 0x1756 <__addsf3x+0x9a>
    172e:	ff 0f       	add	r31, r31
    1730:	bb 1f       	adc	r27, r27
    1732:	66 1f       	adc	r22, r22
    1734:	77 1f       	adc	r23, r23
    1736:	88 1f       	adc	r24, r24
    1738:	c2 f7       	brpl	.-16     	; 0x172a <__addsf3x+0x6e>
    173a:	0e c0       	rjmp	.+28     	; 0x1758 <__addsf3x+0x9c>
    173c:	ba 0f       	add	r27, r26
    173e:	62 1f       	adc	r22, r18
    1740:	73 1f       	adc	r23, r19
    1742:	84 1f       	adc	r24, r20
    1744:	48 f4       	brcc	.+18     	; 0x1758 <__addsf3x+0x9c>
    1746:	87 95       	ror	r24
    1748:	77 95       	ror	r23
    174a:	67 95       	ror	r22
    174c:	b7 95       	ror	r27
    174e:	f7 95       	ror	r31
    1750:	9e 3f       	cpi	r25, 0xFE	; 254
    1752:	08 f0       	brcs	.+2      	; 0x1756 <__addsf3x+0x9a>
    1754:	b0 cf       	rjmp	.-160    	; 0x16b6 <__addsf3+0x28>
    1756:	93 95       	inc	r25
    1758:	88 0f       	add	r24, r24
    175a:	08 f0       	brcs	.+2      	; 0x175e <__addsf3x+0xa2>
    175c:	99 27       	eor	r25, r25
    175e:	ee 0f       	add	r30, r30
    1760:	97 95       	ror	r25
    1762:	87 95       	ror	r24
    1764:	08 95       	ret

00001766 <__divsf3>:
    1766:	0e 94 c7 0b 	call	0x178e	; 0x178e <__divsf3x>
    176a:	0c 94 a8 0c 	jmp	0x1950	; 0x1950 <__fp_round>
    176e:	0e 94 a1 0c 	call	0x1942	; 0x1942 <__fp_pscB>
    1772:	58 f0       	brcs	.+22     	; 0x178a <__divsf3+0x24>
    1774:	0e 94 9a 0c 	call	0x1934	; 0x1934 <__fp_pscA>
    1778:	40 f0       	brcs	.+16     	; 0x178a <__divsf3+0x24>
    177a:	29 f4       	brne	.+10     	; 0x1786 <__divsf3+0x20>
    177c:	5f 3f       	cpi	r21, 0xFF	; 255
    177e:	29 f0       	breq	.+10     	; 0x178a <__divsf3+0x24>
    1780:	0c 94 91 0c 	jmp	0x1922	; 0x1922 <__fp_inf>
    1784:	51 11       	cpse	r21, r1
    1786:	0c 94 dc 0c 	jmp	0x19b8	; 0x19b8 <__fp_szero>
    178a:	0c 94 97 0c 	jmp	0x192e	; 0x192e <__fp_nan>

0000178e <__divsf3x>:
    178e:	0e 94 b9 0c 	call	0x1972	; 0x1972 <__fp_split3>
    1792:	68 f3       	brcs	.-38     	; 0x176e <__divsf3+0x8>

00001794 <__divsf3_pse>:
    1794:	99 23       	and	r25, r25
    1796:	b1 f3       	breq	.-20     	; 0x1784 <__divsf3+0x1e>
    1798:	55 23       	and	r21, r21
    179a:	91 f3       	breq	.-28     	; 0x1780 <__divsf3+0x1a>
    179c:	95 1b       	sub	r25, r21
    179e:	55 0b       	sbc	r21, r21
    17a0:	bb 27       	eor	r27, r27
    17a2:	aa 27       	eor	r26, r26
    17a4:	62 17       	cp	r22, r18
    17a6:	73 07       	cpc	r23, r19
    17a8:	84 07       	cpc	r24, r20
    17aa:	38 f0       	brcs	.+14     	; 0x17ba <__divsf3_pse+0x26>
    17ac:	9f 5f       	subi	r25, 0xFF	; 255
    17ae:	5f 4f       	sbci	r21, 0xFF	; 255
    17b0:	22 0f       	add	r18, r18
    17b2:	33 1f       	adc	r19, r19
    17b4:	44 1f       	adc	r20, r20
    17b6:	aa 1f       	adc	r26, r26
    17b8:	a9 f3       	breq	.-22     	; 0x17a4 <__divsf3_pse+0x10>
    17ba:	35 d0       	rcall	.+106    	; 0x1826 <__divsf3_pse+0x92>
    17bc:	0e 2e       	mov	r0, r30
    17be:	3a f0       	brmi	.+14     	; 0x17ce <__divsf3_pse+0x3a>
    17c0:	e0 e8       	ldi	r30, 0x80	; 128
    17c2:	32 d0       	rcall	.+100    	; 0x1828 <__divsf3_pse+0x94>
    17c4:	91 50       	subi	r25, 0x01	; 1
    17c6:	50 40       	sbci	r21, 0x00	; 0
    17c8:	e6 95       	lsr	r30
    17ca:	00 1c       	adc	r0, r0
    17cc:	ca f7       	brpl	.-14     	; 0x17c0 <__divsf3_pse+0x2c>
    17ce:	2b d0       	rcall	.+86     	; 0x1826 <__divsf3_pse+0x92>
    17d0:	fe 2f       	mov	r31, r30
    17d2:	29 d0       	rcall	.+82     	; 0x1826 <__divsf3_pse+0x92>
    17d4:	66 0f       	add	r22, r22
    17d6:	77 1f       	adc	r23, r23
    17d8:	88 1f       	adc	r24, r24
    17da:	bb 1f       	adc	r27, r27
    17dc:	26 17       	cp	r18, r22
    17de:	37 07       	cpc	r19, r23
    17e0:	48 07       	cpc	r20, r24
    17e2:	ab 07       	cpc	r26, r27
    17e4:	b0 e8       	ldi	r27, 0x80	; 128
    17e6:	09 f0       	breq	.+2      	; 0x17ea <__divsf3_pse+0x56>
    17e8:	bb 0b       	sbc	r27, r27
    17ea:	80 2d       	mov	r24, r0
    17ec:	bf 01       	movw	r22, r30
    17ee:	ff 27       	eor	r31, r31
    17f0:	93 58       	subi	r25, 0x83	; 131
    17f2:	5f 4f       	sbci	r21, 0xFF	; 255
    17f4:	3a f0       	brmi	.+14     	; 0x1804 <__divsf3_pse+0x70>
    17f6:	9e 3f       	cpi	r25, 0xFE	; 254
    17f8:	51 05       	cpc	r21, r1
    17fa:	78 f0       	brcs	.+30     	; 0x181a <__divsf3_pse+0x86>
    17fc:	0c 94 91 0c 	jmp	0x1922	; 0x1922 <__fp_inf>
    1800:	0c 94 dc 0c 	jmp	0x19b8	; 0x19b8 <__fp_szero>
    1804:	5f 3f       	cpi	r21, 0xFF	; 255
    1806:	e4 f3       	brlt	.-8      	; 0x1800 <__divsf3_pse+0x6c>
    1808:	98 3e       	cpi	r25, 0xE8	; 232
    180a:	d4 f3       	brlt	.-12     	; 0x1800 <__divsf3_pse+0x6c>
    180c:	86 95       	lsr	r24
    180e:	77 95       	ror	r23
    1810:	67 95       	ror	r22
    1812:	b7 95       	ror	r27
    1814:	f7 95       	ror	r31
    1816:	9f 5f       	subi	r25, 0xFF	; 255
    1818:	c9 f7       	brne	.-14     	; 0x180c <__divsf3_pse+0x78>
    181a:	88 0f       	add	r24, r24
    181c:	91 1d       	adc	r25, r1
    181e:	96 95       	lsr	r25
    1820:	87 95       	ror	r24
    1822:	97 f9       	bld	r25, 7
    1824:	08 95       	ret
    1826:	e1 e0       	ldi	r30, 0x01	; 1
    1828:	66 0f       	add	r22, r22
    182a:	77 1f       	adc	r23, r23
    182c:	88 1f       	adc	r24, r24
    182e:	bb 1f       	adc	r27, r27
    1830:	62 17       	cp	r22, r18
    1832:	73 07       	cpc	r23, r19
    1834:	84 07       	cpc	r24, r20
    1836:	ba 07       	cpc	r27, r26
    1838:	20 f0       	brcs	.+8      	; 0x1842 <__divsf3_pse+0xae>
    183a:	62 1b       	sub	r22, r18
    183c:	73 0b       	sbc	r23, r19
    183e:	84 0b       	sbc	r24, r20
    1840:	ba 0b       	sbc	r27, r26
    1842:	ee 1f       	adc	r30, r30
    1844:	88 f7       	brcc	.-30     	; 0x1828 <__divsf3_pse+0x94>
    1846:	e0 95       	com	r30
    1848:	08 95       	ret

0000184a <__fixunssfsi>:
    184a:	0e 94 c1 0c 	call	0x1982	; 0x1982 <__fp_splitA>
    184e:	88 f0       	brcs	.+34     	; 0x1872 <__fixunssfsi+0x28>
    1850:	9f 57       	subi	r25, 0x7F	; 127
    1852:	98 f0       	brcs	.+38     	; 0x187a <__fixunssfsi+0x30>
    1854:	b9 2f       	mov	r27, r25
    1856:	99 27       	eor	r25, r25
    1858:	b7 51       	subi	r27, 0x17	; 23
    185a:	b0 f0       	brcs	.+44     	; 0x1888 <__fixunssfsi+0x3e>
    185c:	e1 f0       	breq	.+56     	; 0x1896 <__fixunssfsi+0x4c>
    185e:	66 0f       	add	r22, r22
    1860:	77 1f       	adc	r23, r23
    1862:	88 1f       	adc	r24, r24
    1864:	99 1f       	adc	r25, r25
    1866:	1a f0       	brmi	.+6      	; 0x186e <__fixunssfsi+0x24>
    1868:	ba 95       	dec	r27
    186a:	c9 f7       	brne	.-14     	; 0x185e <__fixunssfsi+0x14>
    186c:	14 c0       	rjmp	.+40     	; 0x1896 <__fixunssfsi+0x4c>
    186e:	b1 30       	cpi	r27, 0x01	; 1
    1870:	91 f0       	breq	.+36     	; 0x1896 <__fixunssfsi+0x4c>
    1872:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <__fp_zero>
    1876:	b1 e0       	ldi	r27, 0x01	; 1
    1878:	08 95       	ret
    187a:	0c 94 db 0c 	jmp	0x19b6	; 0x19b6 <__fp_zero>
    187e:	67 2f       	mov	r22, r23
    1880:	78 2f       	mov	r23, r24
    1882:	88 27       	eor	r24, r24
    1884:	b8 5f       	subi	r27, 0xF8	; 248
    1886:	39 f0       	breq	.+14     	; 0x1896 <__fixunssfsi+0x4c>
    1888:	b9 3f       	cpi	r27, 0xF9	; 249
    188a:	cc f3       	brlt	.-14     	; 0x187e <__fixunssfsi+0x34>
    188c:	86 95       	lsr	r24
    188e:	77 95       	ror	r23
    1890:	67 95       	ror	r22
    1892:	b3 95       	inc	r27
    1894:	d9 f7       	brne	.-10     	; 0x188c <__fixunssfsi+0x42>
    1896:	3e f4       	brtc	.+14     	; 0x18a6 <__fixunssfsi+0x5c>
    1898:	90 95       	com	r25
    189a:	80 95       	com	r24
    189c:	70 95       	com	r23
    189e:	61 95       	neg	r22
    18a0:	7f 4f       	sbci	r23, 0xFF	; 255
    18a2:	8f 4f       	sbci	r24, 0xFF	; 255
    18a4:	9f 4f       	sbci	r25, 0xFF	; 255
    18a6:	08 95       	ret

000018a8 <__floatunsisf>:
    18a8:	e8 94       	clt
    18aa:	09 c0       	rjmp	.+18     	; 0x18be <__floatsisf+0x12>

000018ac <__floatsisf>:
    18ac:	97 fb       	bst	r25, 7
    18ae:	3e f4       	brtc	.+14     	; 0x18be <__floatsisf+0x12>
    18b0:	90 95       	com	r25
    18b2:	80 95       	com	r24
    18b4:	70 95       	com	r23
    18b6:	61 95       	neg	r22
    18b8:	7f 4f       	sbci	r23, 0xFF	; 255
    18ba:	8f 4f       	sbci	r24, 0xFF	; 255
    18bc:	9f 4f       	sbci	r25, 0xFF	; 255
    18be:	99 23       	and	r25, r25
    18c0:	a9 f0       	breq	.+42     	; 0x18ec <__floatsisf+0x40>
    18c2:	f9 2f       	mov	r31, r25
    18c4:	96 e9       	ldi	r25, 0x96	; 150
    18c6:	bb 27       	eor	r27, r27
    18c8:	93 95       	inc	r25
    18ca:	f6 95       	lsr	r31
    18cc:	87 95       	ror	r24
    18ce:	77 95       	ror	r23
    18d0:	67 95       	ror	r22
    18d2:	b7 95       	ror	r27
    18d4:	f1 11       	cpse	r31, r1
    18d6:	f8 cf       	rjmp	.-16     	; 0x18c8 <__floatsisf+0x1c>
    18d8:	fa f4       	brpl	.+62     	; 0x1918 <__floatsisf+0x6c>
    18da:	bb 0f       	add	r27, r27
    18dc:	11 f4       	brne	.+4      	; 0x18e2 <__floatsisf+0x36>
    18de:	60 ff       	sbrs	r22, 0
    18e0:	1b c0       	rjmp	.+54     	; 0x1918 <__floatsisf+0x6c>
    18e2:	6f 5f       	subi	r22, 0xFF	; 255
    18e4:	7f 4f       	sbci	r23, 0xFF	; 255
    18e6:	8f 4f       	sbci	r24, 0xFF	; 255
    18e8:	9f 4f       	sbci	r25, 0xFF	; 255
    18ea:	16 c0       	rjmp	.+44     	; 0x1918 <__floatsisf+0x6c>
    18ec:	88 23       	and	r24, r24
    18ee:	11 f0       	breq	.+4      	; 0x18f4 <__floatsisf+0x48>
    18f0:	96 e9       	ldi	r25, 0x96	; 150
    18f2:	11 c0       	rjmp	.+34     	; 0x1916 <__floatsisf+0x6a>
    18f4:	77 23       	and	r23, r23
    18f6:	21 f0       	breq	.+8      	; 0x1900 <__floatsisf+0x54>
    18f8:	9e e8       	ldi	r25, 0x8E	; 142
    18fa:	87 2f       	mov	r24, r23
    18fc:	76 2f       	mov	r23, r22
    18fe:	05 c0       	rjmp	.+10     	; 0x190a <__floatsisf+0x5e>
    1900:	66 23       	and	r22, r22
    1902:	71 f0       	breq	.+28     	; 0x1920 <__floatsisf+0x74>
    1904:	96 e8       	ldi	r25, 0x86	; 134
    1906:	86 2f       	mov	r24, r22
    1908:	70 e0       	ldi	r23, 0x00	; 0
    190a:	60 e0       	ldi	r22, 0x00	; 0
    190c:	2a f0       	brmi	.+10     	; 0x1918 <__floatsisf+0x6c>
    190e:	9a 95       	dec	r25
    1910:	66 0f       	add	r22, r22
    1912:	77 1f       	adc	r23, r23
    1914:	88 1f       	adc	r24, r24
    1916:	da f7       	brpl	.-10     	; 0x190e <__floatsisf+0x62>
    1918:	88 0f       	add	r24, r24
    191a:	96 95       	lsr	r25
    191c:	87 95       	ror	r24
    191e:	97 f9       	bld	r25, 7
    1920:	08 95       	ret

00001922 <__fp_inf>:
    1922:	97 f9       	bld	r25, 7
    1924:	9f 67       	ori	r25, 0x7F	; 127
    1926:	80 e8       	ldi	r24, 0x80	; 128
    1928:	70 e0       	ldi	r23, 0x00	; 0
    192a:	60 e0       	ldi	r22, 0x00	; 0
    192c:	08 95       	ret

0000192e <__fp_nan>:
    192e:	9f ef       	ldi	r25, 0xFF	; 255
    1930:	80 ec       	ldi	r24, 0xC0	; 192
    1932:	08 95       	ret

00001934 <__fp_pscA>:
    1934:	00 24       	eor	r0, r0
    1936:	0a 94       	dec	r0
    1938:	16 16       	cp	r1, r22
    193a:	17 06       	cpc	r1, r23
    193c:	18 06       	cpc	r1, r24
    193e:	09 06       	cpc	r0, r25
    1940:	08 95       	ret

00001942 <__fp_pscB>:
    1942:	00 24       	eor	r0, r0
    1944:	0a 94       	dec	r0
    1946:	12 16       	cp	r1, r18
    1948:	13 06       	cpc	r1, r19
    194a:	14 06       	cpc	r1, r20
    194c:	05 06       	cpc	r0, r21
    194e:	08 95       	ret

00001950 <__fp_round>:
    1950:	09 2e       	mov	r0, r25
    1952:	03 94       	inc	r0
    1954:	00 0c       	add	r0, r0
    1956:	11 f4       	brne	.+4      	; 0x195c <__fp_round+0xc>
    1958:	88 23       	and	r24, r24
    195a:	52 f0       	brmi	.+20     	; 0x1970 <__fp_round+0x20>
    195c:	bb 0f       	add	r27, r27
    195e:	40 f4       	brcc	.+16     	; 0x1970 <__fp_round+0x20>
    1960:	bf 2b       	or	r27, r31
    1962:	11 f4       	brne	.+4      	; 0x1968 <__fp_round+0x18>
    1964:	60 ff       	sbrs	r22, 0
    1966:	04 c0       	rjmp	.+8      	; 0x1970 <__fp_round+0x20>
    1968:	6f 5f       	subi	r22, 0xFF	; 255
    196a:	7f 4f       	sbci	r23, 0xFF	; 255
    196c:	8f 4f       	sbci	r24, 0xFF	; 255
    196e:	9f 4f       	sbci	r25, 0xFF	; 255
    1970:	08 95       	ret

00001972 <__fp_split3>:
    1972:	57 fd       	sbrc	r21, 7
    1974:	90 58       	subi	r25, 0x80	; 128
    1976:	44 0f       	add	r20, r20
    1978:	55 1f       	adc	r21, r21
    197a:	59 f0       	breq	.+22     	; 0x1992 <__fp_splitA+0x10>
    197c:	5f 3f       	cpi	r21, 0xFF	; 255
    197e:	71 f0       	breq	.+28     	; 0x199c <__fp_splitA+0x1a>
    1980:	47 95       	ror	r20

00001982 <__fp_splitA>:
    1982:	88 0f       	add	r24, r24
    1984:	97 fb       	bst	r25, 7
    1986:	99 1f       	adc	r25, r25
    1988:	61 f0       	breq	.+24     	; 0x19a2 <__fp_splitA+0x20>
    198a:	9f 3f       	cpi	r25, 0xFF	; 255
    198c:	79 f0       	breq	.+30     	; 0x19ac <__fp_splitA+0x2a>
    198e:	87 95       	ror	r24
    1990:	08 95       	ret
    1992:	12 16       	cp	r1, r18
    1994:	13 06       	cpc	r1, r19
    1996:	14 06       	cpc	r1, r20
    1998:	55 1f       	adc	r21, r21
    199a:	f2 cf       	rjmp	.-28     	; 0x1980 <__fp_split3+0xe>
    199c:	46 95       	lsr	r20
    199e:	f1 df       	rcall	.-30     	; 0x1982 <__fp_splitA>
    19a0:	08 c0       	rjmp	.+16     	; 0x19b2 <__fp_splitA+0x30>
    19a2:	16 16       	cp	r1, r22
    19a4:	17 06       	cpc	r1, r23
    19a6:	18 06       	cpc	r1, r24
    19a8:	99 1f       	adc	r25, r25
    19aa:	f1 cf       	rjmp	.-30     	; 0x198e <__fp_splitA+0xc>
    19ac:	86 95       	lsr	r24
    19ae:	71 05       	cpc	r23, r1
    19b0:	61 05       	cpc	r22, r1
    19b2:	08 94       	sec
    19b4:	08 95       	ret

000019b6 <__fp_zero>:
    19b6:	e8 94       	clt

000019b8 <__fp_szero>:
    19b8:	bb 27       	eor	r27, r27
    19ba:	66 27       	eor	r22, r22
    19bc:	77 27       	eor	r23, r23
    19be:	cb 01       	movw	r24, r22
    19c0:	97 f9       	bld	r25, 7
    19c2:	08 95       	ret

000019c4 <__mulsf3>:
    19c4:	0e 94 f5 0c 	call	0x19ea	; 0x19ea <__mulsf3x>
    19c8:	0c 94 a8 0c 	jmp	0x1950	; 0x1950 <__fp_round>
    19cc:	0e 94 9a 0c 	call	0x1934	; 0x1934 <__fp_pscA>
    19d0:	38 f0       	brcs	.+14     	; 0x19e0 <__mulsf3+0x1c>
    19d2:	0e 94 a1 0c 	call	0x1942	; 0x1942 <__fp_pscB>
    19d6:	20 f0       	brcs	.+8      	; 0x19e0 <__mulsf3+0x1c>
    19d8:	95 23       	and	r25, r21
    19da:	11 f0       	breq	.+4      	; 0x19e0 <__mulsf3+0x1c>
    19dc:	0c 94 91 0c 	jmp	0x1922	; 0x1922 <__fp_inf>
    19e0:	0c 94 97 0c 	jmp	0x192e	; 0x192e <__fp_nan>
    19e4:	11 24       	eor	r1, r1
    19e6:	0c 94 dc 0c 	jmp	0x19b8	; 0x19b8 <__fp_szero>

000019ea <__mulsf3x>:
    19ea:	0e 94 b9 0c 	call	0x1972	; 0x1972 <__fp_split3>
    19ee:	70 f3       	brcs	.-36     	; 0x19cc <__mulsf3+0x8>

000019f0 <__mulsf3_pse>:
    19f0:	95 9f       	mul	r25, r21
    19f2:	c1 f3       	breq	.-16     	; 0x19e4 <__mulsf3+0x20>
    19f4:	95 0f       	add	r25, r21
    19f6:	50 e0       	ldi	r21, 0x00	; 0
    19f8:	55 1f       	adc	r21, r21
    19fa:	62 9f       	mul	r22, r18
    19fc:	f0 01       	movw	r30, r0
    19fe:	72 9f       	mul	r23, r18
    1a00:	bb 27       	eor	r27, r27
    1a02:	f0 0d       	add	r31, r0
    1a04:	b1 1d       	adc	r27, r1
    1a06:	63 9f       	mul	r22, r19
    1a08:	aa 27       	eor	r26, r26
    1a0a:	f0 0d       	add	r31, r0
    1a0c:	b1 1d       	adc	r27, r1
    1a0e:	aa 1f       	adc	r26, r26
    1a10:	64 9f       	mul	r22, r20
    1a12:	66 27       	eor	r22, r22
    1a14:	b0 0d       	add	r27, r0
    1a16:	a1 1d       	adc	r26, r1
    1a18:	66 1f       	adc	r22, r22
    1a1a:	82 9f       	mul	r24, r18
    1a1c:	22 27       	eor	r18, r18
    1a1e:	b0 0d       	add	r27, r0
    1a20:	a1 1d       	adc	r26, r1
    1a22:	62 1f       	adc	r22, r18
    1a24:	73 9f       	mul	r23, r19
    1a26:	b0 0d       	add	r27, r0
    1a28:	a1 1d       	adc	r26, r1
    1a2a:	62 1f       	adc	r22, r18
    1a2c:	83 9f       	mul	r24, r19
    1a2e:	a0 0d       	add	r26, r0
    1a30:	61 1d       	adc	r22, r1
    1a32:	22 1f       	adc	r18, r18
    1a34:	74 9f       	mul	r23, r20
    1a36:	33 27       	eor	r19, r19
    1a38:	a0 0d       	add	r26, r0
    1a3a:	61 1d       	adc	r22, r1
    1a3c:	23 1f       	adc	r18, r19
    1a3e:	84 9f       	mul	r24, r20
    1a40:	60 0d       	add	r22, r0
    1a42:	21 1d       	adc	r18, r1
    1a44:	82 2f       	mov	r24, r18
    1a46:	76 2f       	mov	r23, r22
    1a48:	6a 2f       	mov	r22, r26
    1a4a:	11 24       	eor	r1, r1
    1a4c:	9f 57       	subi	r25, 0x7F	; 127
    1a4e:	50 40       	sbci	r21, 0x00	; 0
    1a50:	9a f0       	brmi	.+38     	; 0x1a78 <__mulsf3_pse+0x88>
    1a52:	f1 f0       	breq	.+60     	; 0x1a90 <__mulsf3_pse+0xa0>
    1a54:	88 23       	and	r24, r24
    1a56:	4a f0       	brmi	.+18     	; 0x1a6a <__mulsf3_pse+0x7a>
    1a58:	ee 0f       	add	r30, r30
    1a5a:	ff 1f       	adc	r31, r31
    1a5c:	bb 1f       	adc	r27, r27
    1a5e:	66 1f       	adc	r22, r22
    1a60:	77 1f       	adc	r23, r23
    1a62:	88 1f       	adc	r24, r24
    1a64:	91 50       	subi	r25, 0x01	; 1
    1a66:	50 40       	sbci	r21, 0x00	; 0
    1a68:	a9 f7       	brne	.-22     	; 0x1a54 <__mulsf3_pse+0x64>
    1a6a:	9e 3f       	cpi	r25, 0xFE	; 254
    1a6c:	51 05       	cpc	r21, r1
    1a6e:	80 f0       	brcs	.+32     	; 0x1a90 <__mulsf3_pse+0xa0>
    1a70:	0c 94 91 0c 	jmp	0x1922	; 0x1922 <__fp_inf>
    1a74:	0c 94 dc 0c 	jmp	0x19b8	; 0x19b8 <__fp_szero>
    1a78:	5f 3f       	cpi	r21, 0xFF	; 255
    1a7a:	e4 f3       	brlt	.-8      	; 0x1a74 <__mulsf3_pse+0x84>
    1a7c:	98 3e       	cpi	r25, 0xE8	; 232
    1a7e:	d4 f3       	brlt	.-12     	; 0x1a74 <__mulsf3_pse+0x84>
    1a80:	86 95       	lsr	r24
    1a82:	77 95       	ror	r23
    1a84:	67 95       	ror	r22
    1a86:	b7 95       	ror	r27
    1a88:	f7 95       	ror	r31
    1a8a:	e7 95       	ror	r30
    1a8c:	9f 5f       	subi	r25, 0xFF	; 255
    1a8e:	c1 f7       	brne	.-16     	; 0x1a80 <__mulsf3_pse+0x90>
    1a90:	fe 2b       	or	r31, r30
    1a92:	88 0f       	add	r24, r24
    1a94:	91 1d       	adc	r25, r1
    1a96:	96 95       	lsr	r25
    1a98:	87 95       	ror	r24
    1a9a:	97 f9       	bld	r25, 7
    1a9c:	08 95       	ret

00001a9e <_exit>:
    1a9e:	f8 94       	cli

00001aa0 <__stop_program>:
    1aa0:	ff cf       	rjmp	.-2      	; 0x1aa0 <__stop_program>
