
Transmiter.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001d18  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000092  00800060  00001d18  00001dac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000064b  008000f2  008000f2  00001e3e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001e3e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001e70  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000448  00000000  00000000  00001eac  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000042b2  00000000  00000000  000022f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000016c7  00000000  00000000  000065a6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002ad3  00000000  00000000  00007c6d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000988  00000000  00000000  0000a740  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000186d  00000000  00000000  0000b0c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000030f7  00000000  00000000  0000c935  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000448  00000000  00000000  0000fa2c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 2c 02 	jmp	0x458	; 0x458 <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	10 e0       	ldi	r17, 0x00	; 0
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e8 e1       	ldi	r30, 0x18	; 24
      68:	fd e1       	ldi	r31, 0x1D	; 29
      6a:	02 c0       	rjmp	.+4      	; 0x70 <__do_copy_data+0x10>
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0
      70:	a2 3f       	cpi	r26, 0xF2	; 242
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <__do_copy_data+0xc>

00000076 <__do_clear_bss>:
      76:	27 e0       	ldi	r18, 0x07	; 7
      78:	a2 ef       	ldi	r26, 0xF2	; 242
      7a:	b0 e0       	ldi	r27, 0x00	; 0
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	ad 33       	cpi	r26, 0x3D	; 61
      82:	b2 07       	cpc	r27, r18
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 67 0c 	call	0x18ce	; 0x18ce <main>
      8a:	0c 94 8a 0e 	jmp	0x1d14	; 0x1d14 <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
      92:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      94:	03 96       	adiw	r24, 0x03	; 3
      96:	92 83       	std	Z+2, r25	; 0x02
      98:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
      9a:	2f ef       	ldi	r18, 0xFF	; 255
      9c:	3f ef       	ldi	r19, 0xFF	; 255
      9e:	34 83       	std	Z+4, r19	; 0x04
      a0:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      a2:	96 83       	std	Z+6, r25	; 0x06
      a4:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
      a6:	90 87       	std	Z+8, r25	; 0x08
      a8:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
      aa:	10 82       	st	Z, r1
      ac:	08 95       	ret

000000ae <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
      ae:	fc 01       	movw	r30, r24
      b0:	11 86       	std	Z+9, r1	; 0x09
      b2:	10 86       	std	Z+8, r1	; 0x08
      b4:	08 95       	ret

000000b6 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
      b6:	cf 93       	push	r28
      b8:	df 93       	push	r29
      ba:	9c 01       	movw	r18, r24
      bc:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
      be:	dc 01       	movw	r26, r24
      c0:	11 96       	adiw	r26, 0x01	; 1
      c2:	cd 91       	ld	r28, X+
      c4:	dc 91       	ld	r29, X
      c6:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
      c8:	d3 83       	std	Z+3, r29	; 0x03
      ca:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
      cc:	8c 81       	ldd	r24, Y+4	; 0x04
      ce:	9d 81       	ldd	r25, Y+5	; 0x05
      d0:	95 83       	std	Z+5, r25	; 0x05
      d2:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
      d4:	8c 81       	ldd	r24, Y+4	; 0x04
      d6:	9d 81       	ldd	r25, Y+5	; 0x05
      d8:	dc 01       	movw	r26, r24
      da:	13 96       	adiw	r26, 0x03	; 3
      dc:	7c 93       	st	X, r23
      de:	6e 93       	st	-X, r22
      e0:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
      e2:	7d 83       	std	Y+5, r23	; 0x05
      e4:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
      e6:	31 87       	std	Z+9, r19	; 0x09
      e8:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
      ea:	f9 01       	movw	r30, r18
      ec:	80 81       	ld	r24, Z
      ee:	8f 5f       	subi	r24, 0xFF	; 255
      f0:	80 83       	st	Z, r24
}
      f2:	df 91       	pop	r29
      f4:	cf 91       	pop	r28
      f6:	08 95       	ret

000000f8 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
      f8:	cf 93       	push	r28
      fa:	df 93       	push	r29
      fc:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
      fe:	48 81       	ld	r20, Y
     100:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     102:	4f 3f       	cpi	r20, 0xFF	; 255
     104:	2f ef       	ldi	r18, 0xFF	; 255
     106:	52 07       	cpc	r21, r18
     108:	21 f4       	brne	.+8      	; 0x112 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     10a:	fc 01       	movw	r30, r24
     10c:	a7 81       	ldd	r26, Z+7	; 0x07
     10e:	b0 85       	ldd	r27, Z+8	; 0x08
     110:	0d c0       	rjmp	.+26     	; 0x12c <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     112:	dc 01       	movw	r26, r24
     114:	13 96       	adiw	r26, 0x03	; 3
     116:	01 c0       	rjmp	.+2      	; 0x11a <vListInsert+0x22>
     118:	df 01       	movw	r26, r30
     11a:	12 96       	adiw	r26, 0x02	; 2
     11c:	ed 91       	ld	r30, X+
     11e:	fc 91       	ld	r31, X
     120:	13 97       	sbiw	r26, 0x03	; 3
     122:	20 81       	ld	r18, Z
     124:	31 81       	ldd	r19, Z+1	; 0x01
     126:	42 17       	cp	r20, r18
     128:	53 07       	cpc	r21, r19
     12a:	b0 f7       	brcc	.-20     	; 0x118 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     12c:	12 96       	adiw	r26, 0x02	; 2
     12e:	ed 91       	ld	r30, X+
     130:	fc 91       	ld	r31, X
     132:	13 97       	sbiw	r26, 0x03	; 3
     134:	fb 83       	std	Y+3, r31	; 0x03
     136:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     138:	d5 83       	std	Z+5, r29	; 0x05
     13a:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     13c:	bd 83       	std	Y+5, r27	; 0x05
     13e:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     140:	13 96       	adiw	r26, 0x03	; 3
     142:	dc 93       	st	X, r29
     144:	ce 93       	st	-X, r28
     146:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     148:	99 87       	std	Y+9, r25	; 0x09
     14a:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     14c:	fc 01       	movw	r30, r24
     14e:	20 81       	ld	r18, Z
     150:	2f 5f       	subi	r18, 0xFF	; 255
     152:	20 83       	st	Z, r18
}
     154:	df 91       	pop	r29
     156:	cf 91       	pop	r28
     158:	08 95       	ret

0000015a <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     15a:	cf 93       	push	r28
     15c:	df 93       	push	r29
     15e:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     160:	a0 85       	ldd	r26, Z+8	; 0x08
     162:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     164:	c2 81       	ldd	r28, Z+2	; 0x02
     166:	d3 81       	ldd	r29, Z+3	; 0x03
     168:	84 81       	ldd	r24, Z+4	; 0x04
     16a:	95 81       	ldd	r25, Z+5	; 0x05
     16c:	9d 83       	std	Y+5, r25	; 0x05
     16e:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     170:	c4 81       	ldd	r28, Z+4	; 0x04
     172:	d5 81       	ldd	r29, Z+5	; 0x05
     174:	82 81       	ldd	r24, Z+2	; 0x02
     176:	93 81       	ldd	r25, Z+3	; 0x03
     178:	9b 83       	std	Y+3, r25	; 0x03
     17a:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     17c:	11 96       	adiw	r26, 0x01	; 1
     17e:	8d 91       	ld	r24, X+
     180:	9c 91       	ld	r25, X
     182:	12 97       	sbiw	r26, 0x02	; 2
     184:	e8 17       	cp	r30, r24
     186:	f9 07       	cpc	r31, r25
     188:	31 f4       	brne	.+12     	; 0x196 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     18a:	84 81       	ldd	r24, Z+4	; 0x04
     18c:	95 81       	ldd	r25, Z+5	; 0x05
     18e:	12 96       	adiw	r26, 0x02	; 2
     190:	9c 93       	st	X, r25
     192:	8e 93       	st	-X, r24
     194:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     196:	11 86       	std	Z+9, r1	; 0x09
     198:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     19a:	8c 91       	ld	r24, X
     19c:	81 50       	subi	r24, 0x01	; 1
     19e:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     1a0:	df 91       	pop	r29
     1a2:	cf 91       	pop	r28
     1a4:	08 95       	ret

000001a6 <prvSetupTimerInterrupt>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     1a6:	1b bc       	out	0x2b, r1	; 43
     1a8:	89 ef       	ldi	r24, 0xF9	; 249
     1aa:	8a bd       	out	0x2a, r24	; 42
     1ac:	8b e0       	ldi	r24, 0x0B	; 11
     1ae:	8e bd       	out	0x2e, r24	; 46
     1b0:	89 b7       	in	r24, 0x39	; 57
     1b2:	80 61       	ori	r24, 0x10	; 16
     1b4:	89 bf       	out	0x39, r24	; 57
     1b6:	08 95       	ret

000001b8 <pxPortInitialiseStack>:
     1b8:	31 e1       	ldi	r19, 0x11	; 17
     1ba:	fc 01       	movw	r30, r24
     1bc:	30 83       	st	Z, r19
     1be:	31 97       	sbiw	r30, 0x01	; 1
     1c0:	22 e2       	ldi	r18, 0x22	; 34
     1c2:	20 83       	st	Z, r18
     1c4:	31 97       	sbiw	r30, 0x01	; 1
     1c6:	a3 e3       	ldi	r26, 0x33	; 51
     1c8:	a0 83       	st	Z, r26
     1ca:	31 97       	sbiw	r30, 0x01	; 1
     1cc:	60 83       	st	Z, r22
     1ce:	31 97       	sbiw	r30, 0x01	; 1
     1d0:	70 83       	st	Z, r23
     1d2:	31 97       	sbiw	r30, 0x01	; 1
     1d4:	10 82       	st	Z, r1
     1d6:	31 97       	sbiw	r30, 0x01	; 1
     1d8:	60 e8       	ldi	r22, 0x80	; 128
     1da:	60 83       	st	Z, r22
     1dc:	31 97       	sbiw	r30, 0x01	; 1
     1de:	10 82       	st	Z, r1
     1e0:	31 97       	sbiw	r30, 0x01	; 1
     1e2:	62 e0       	ldi	r22, 0x02	; 2
     1e4:	60 83       	st	Z, r22
     1e6:	31 97       	sbiw	r30, 0x01	; 1
     1e8:	63 e0       	ldi	r22, 0x03	; 3
     1ea:	60 83       	st	Z, r22
     1ec:	31 97       	sbiw	r30, 0x01	; 1
     1ee:	64 e0       	ldi	r22, 0x04	; 4
     1f0:	60 83       	st	Z, r22
     1f2:	31 97       	sbiw	r30, 0x01	; 1
     1f4:	65 e0       	ldi	r22, 0x05	; 5
     1f6:	60 83       	st	Z, r22
     1f8:	31 97       	sbiw	r30, 0x01	; 1
     1fa:	66 e0       	ldi	r22, 0x06	; 6
     1fc:	60 83       	st	Z, r22
     1fe:	31 97       	sbiw	r30, 0x01	; 1
     200:	67 e0       	ldi	r22, 0x07	; 7
     202:	60 83       	st	Z, r22
     204:	31 97       	sbiw	r30, 0x01	; 1
     206:	68 e0       	ldi	r22, 0x08	; 8
     208:	60 83       	st	Z, r22
     20a:	31 97       	sbiw	r30, 0x01	; 1
     20c:	69 e0       	ldi	r22, 0x09	; 9
     20e:	60 83       	st	Z, r22
     210:	31 97       	sbiw	r30, 0x01	; 1
     212:	60 e1       	ldi	r22, 0x10	; 16
     214:	60 83       	st	Z, r22
     216:	31 97       	sbiw	r30, 0x01	; 1
     218:	30 83       	st	Z, r19
     21a:	31 97       	sbiw	r30, 0x01	; 1
     21c:	32 e1       	ldi	r19, 0x12	; 18
     21e:	30 83       	st	Z, r19
     220:	31 97       	sbiw	r30, 0x01	; 1
     222:	33 e1       	ldi	r19, 0x13	; 19
     224:	30 83       	st	Z, r19
     226:	31 97       	sbiw	r30, 0x01	; 1
     228:	34 e1       	ldi	r19, 0x14	; 20
     22a:	30 83       	st	Z, r19
     22c:	31 97       	sbiw	r30, 0x01	; 1
     22e:	35 e1       	ldi	r19, 0x15	; 21
     230:	30 83       	st	Z, r19
     232:	31 97       	sbiw	r30, 0x01	; 1
     234:	36 e1       	ldi	r19, 0x16	; 22
     236:	30 83       	st	Z, r19
     238:	31 97       	sbiw	r30, 0x01	; 1
     23a:	37 e1       	ldi	r19, 0x17	; 23
     23c:	30 83       	st	Z, r19
     23e:	31 97       	sbiw	r30, 0x01	; 1
     240:	38 e1       	ldi	r19, 0x18	; 24
     242:	30 83       	st	Z, r19
     244:	31 97       	sbiw	r30, 0x01	; 1
     246:	39 e1       	ldi	r19, 0x19	; 25
     248:	30 83       	st	Z, r19
     24a:	31 97       	sbiw	r30, 0x01	; 1
     24c:	30 e2       	ldi	r19, 0x20	; 32
     24e:	30 83       	st	Z, r19
     250:	31 97       	sbiw	r30, 0x01	; 1
     252:	31 e2       	ldi	r19, 0x21	; 33
     254:	30 83       	st	Z, r19
     256:	31 97       	sbiw	r30, 0x01	; 1
     258:	20 83       	st	Z, r18
     25a:	31 97       	sbiw	r30, 0x01	; 1
     25c:	23 e2       	ldi	r18, 0x23	; 35
     25e:	20 83       	st	Z, r18
     260:	31 97       	sbiw	r30, 0x01	; 1
     262:	40 83       	st	Z, r20
     264:	31 97       	sbiw	r30, 0x01	; 1
     266:	50 83       	st	Z, r21
     268:	31 97       	sbiw	r30, 0x01	; 1
     26a:	26 e2       	ldi	r18, 0x26	; 38
     26c:	20 83       	st	Z, r18
     26e:	31 97       	sbiw	r30, 0x01	; 1
     270:	27 e2       	ldi	r18, 0x27	; 39
     272:	20 83       	st	Z, r18
     274:	31 97       	sbiw	r30, 0x01	; 1
     276:	28 e2       	ldi	r18, 0x28	; 40
     278:	20 83       	st	Z, r18
     27a:	31 97       	sbiw	r30, 0x01	; 1
     27c:	29 e2       	ldi	r18, 0x29	; 41
     27e:	20 83       	st	Z, r18
     280:	31 97       	sbiw	r30, 0x01	; 1
     282:	20 e3       	ldi	r18, 0x30	; 48
     284:	20 83       	st	Z, r18
     286:	31 97       	sbiw	r30, 0x01	; 1
     288:	21 e3       	ldi	r18, 0x31	; 49
     28a:	20 83       	st	Z, r18
     28c:	86 97       	sbiw	r24, 0x26	; 38
     28e:	08 95       	ret

00000290 <xPortStartScheduler>:
     290:	0e 94 d3 00 	call	0x1a6	; 0x1a6 <prvSetupTimerInterrupt>
     294:	a0 91 2b 07 	lds	r26, 0x072B	; 0x80072b <pxCurrentTCB>
     298:	b0 91 2c 07 	lds	r27, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     29c:	cd 91       	ld	r28, X+
     29e:	cd bf       	out	0x3d, r28	; 61
     2a0:	dd 91       	ld	r29, X+
     2a2:	de bf       	out	0x3e, r29	; 62
     2a4:	ff 91       	pop	r31
     2a6:	ef 91       	pop	r30
     2a8:	df 91       	pop	r29
     2aa:	cf 91       	pop	r28
     2ac:	bf 91       	pop	r27
     2ae:	af 91       	pop	r26
     2b0:	9f 91       	pop	r25
     2b2:	8f 91       	pop	r24
     2b4:	7f 91       	pop	r23
     2b6:	6f 91       	pop	r22
     2b8:	5f 91       	pop	r21
     2ba:	4f 91       	pop	r20
     2bc:	3f 91       	pop	r19
     2be:	2f 91       	pop	r18
     2c0:	1f 91       	pop	r17
     2c2:	0f 91       	pop	r16
     2c4:	ff 90       	pop	r15
     2c6:	ef 90       	pop	r14
     2c8:	df 90       	pop	r13
     2ca:	cf 90       	pop	r12
     2cc:	bf 90       	pop	r11
     2ce:	af 90       	pop	r10
     2d0:	9f 90       	pop	r9
     2d2:	8f 90       	pop	r8
     2d4:	7f 90       	pop	r7
     2d6:	6f 90       	pop	r6
     2d8:	5f 90       	pop	r5
     2da:	4f 90       	pop	r4
     2dc:	3f 90       	pop	r3
     2de:	2f 90       	pop	r2
     2e0:	1f 90       	pop	r1
     2e2:	0f 90       	pop	r0
     2e4:	0f be       	out	0x3f, r0	; 63
     2e6:	0f 90       	pop	r0
     2e8:	08 95       	ret
     2ea:	81 e0       	ldi	r24, 0x01	; 1
     2ec:	08 95       	ret

000002ee <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     2ee:	0f 92       	push	r0
     2f0:	0f b6       	in	r0, 0x3f	; 63
     2f2:	f8 94       	cli
     2f4:	0f 92       	push	r0
     2f6:	1f 92       	push	r1
     2f8:	11 24       	eor	r1, r1
     2fa:	2f 92       	push	r2
     2fc:	3f 92       	push	r3
     2fe:	4f 92       	push	r4
     300:	5f 92       	push	r5
     302:	6f 92       	push	r6
     304:	7f 92       	push	r7
     306:	8f 92       	push	r8
     308:	9f 92       	push	r9
     30a:	af 92       	push	r10
     30c:	bf 92       	push	r11
     30e:	cf 92       	push	r12
     310:	df 92       	push	r13
     312:	ef 92       	push	r14
     314:	ff 92       	push	r15
     316:	0f 93       	push	r16
     318:	1f 93       	push	r17
     31a:	2f 93       	push	r18
     31c:	3f 93       	push	r19
     31e:	4f 93       	push	r20
     320:	5f 93       	push	r21
     322:	6f 93       	push	r22
     324:	7f 93       	push	r23
     326:	8f 93       	push	r24
     328:	9f 93       	push	r25
     32a:	af 93       	push	r26
     32c:	bf 93       	push	r27
     32e:	cf 93       	push	r28
     330:	df 93       	push	r29
     332:	ef 93       	push	r30
     334:	ff 93       	push	r31
     336:	a0 91 2b 07 	lds	r26, 0x072B	; 0x80072b <pxCurrentTCB>
     33a:	b0 91 2c 07 	lds	r27, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     33e:	0d b6       	in	r0, 0x3d	; 61
     340:	0d 92       	st	X+, r0
     342:	0e b6       	in	r0, 0x3e	; 62
     344:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     346:	0e 94 c7 06 	call	0xd8e	; 0xd8e <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     34a:	a0 91 2b 07 	lds	r26, 0x072B	; 0x80072b <pxCurrentTCB>
     34e:	b0 91 2c 07 	lds	r27, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     352:	cd 91       	ld	r28, X+
     354:	cd bf       	out	0x3d, r28	; 61
     356:	dd 91       	ld	r29, X+
     358:	de bf       	out	0x3e, r29	; 62
     35a:	ff 91       	pop	r31
     35c:	ef 91       	pop	r30
     35e:	df 91       	pop	r29
     360:	cf 91       	pop	r28
     362:	bf 91       	pop	r27
     364:	af 91       	pop	r26
     366:	9f 91       	pop	r25
     368:	8f 91       	pop	r24
     36a:	7f 91       	pop	r23
     36c:	6f 91       	pop	r22
     36e:	5f 91       	pop	r21
     370:	4f 91       	pop	r20
     372:	3f 91       	pop	r19
     374:	2f 91       	pop	r18
     376:	1f 91       	pop	r17
     378:	0f 91       	pop	r16
     37a:	ff 90       	pop	r15
     37c:	ef 90       	pop	r14
     37e:	df 90       	pop	r13
     380:	cf 90       	pop	r12
     382:	bf 90       	pop	r11
     384:	af 90       	pop	r10
     386:	9f 90       	pop	r9
     388:	8f 90       	pop	r8
     38a:	7f 90       	pop	r7
     38c:	6f 90       	pop	r6
     38e:	5f 90       	pop	r5
     390:	4f 90       	pop	r4
     392:	3f 90       	pop	r3
     394:	2f 90       	pop	r2
     396:	1f 90       	pop	r1
     398:	0f 90       	pop	r0
     39a:	0f be       	out	0x3f, r0	; 63
     39c:	0f 90       	pop	r0

	asm volatile ( "ret" );
     39e:	08 95       	ret

000003a0 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     3a0:	0f 92       	push	r0
     3a2:	0f b6       	in	r0, 0x3f	; 63
     3a4:	f8 94       	cli
     3a6:	0f 92       	push	r0
     3a8:	1f 92       	push	r1
     3aa:	11 24       	eor	r1, r1
     3ac:	2f 92       	push	r2
     3ae:	3f 92       	push	r3
     3b0:	4f 92       	push	r4
     3b2:	5f 92       	push	r5
     3b4:	6f 92       	push	r6
     3b6:	7f 92       	push	r7
     3b8:	8f 92       	push	r8
     3ba:	9f 92       	push	r9
     3bc:	af 92       	push	r10
     3be:	bf 92       	push	r11
     3c0:	cf 92       	push	r12
     3c2:	df 92       	push	r13
     3c4:	ef 92       	push	r14
     3c6:	ff 92       	push	r15
     3c8:	0f 93       	push	r16
     3ca:	1f 93       	push	r17
     3cc:	2f 93       	push	r18
     3ce:	3f 93       	push	r19
     3d0:	4f 93       	push	r20
     3d2:	5f 93       	push	r21
     3d4:	6f 93       	push	r22
     3d6:	7f 93       	push	r23
     3d8:	8f 93       	push	r24
     3da:	9f 93       	push	r25
     3dc:	af 93       	push	r26
     3de:	bf 93       	push	r27
     3e0:	cf 93       	push	r28
     3e2:	df 93       	push	r29
     3e4:	ef 93       	push	r30
     3e6:	ff 93       	push	r31
     3e8:	a0 91 2b 07 	lds	r26, 0x072B	; 0x80072b <pxCurrentTCB>
     3ec:	b0 91 2c 07 	lds	r27, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     3f0:	0d b6       	in	r0, 0x3d	; 61
     3f2:	0d 92       	st	X+, r0
     3f4:	0e b6       	in	r0, 0x3e	; 62
     3f6:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     3f8:	0e 94 5a 05 	call	0xab4	; 0xab4 <xTaskIncrementTick>
     3fc:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     3fe:	0e 94 c7 06 	call	0xd8e	; 0xd8e <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     402:	a0 91 2b 07 	lds	r26, 0x072B	; 0x80072b <pxCurrentTCB>
     406:	b0 91 2c 07 	lds	r27, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     40a:	cd 91       	ld	r28, X+
     40c:	cd bf       	out	0x3d, r28	; 61
     40e:	dd 91       	ld	r29, X+
     410:	de bf       	out	0x3e, r29	; 62
     412:	ff 91       	pop	r31
     414:	ef 91       	pop	r30
     416:	df 91       	pop	r29
     418:	cf 91       	pop	r28
     41a:	bf 91       	pop	r27
     41c:	af 91       	pop	r26
     41e:	9f 91       	pop	r25
     420:	8f 91       	pop	r24
     422:	7f 91       	pop	r23
     424:	6f 91       	pop	r22
     426:	5f 91       	pop	r21
     428:	4f 91       	pop	r20
     42a:	3f 91       	pop	r19
     42c:	2f 91       	pop	r18
     42e:	1f 91       	pop	r17
     430:	0f 91       	pop	r16
     432:	ff 90       	pop	r15
     434:	ef 90       	pop	r14
     436:	df 90       	pop	r13
     438:	cf 90       	pop	r12
     43a:	bf 90       	pop	r11
     43c:	af 90       	pop	r10
     43e:	9f 90       	pop	r9
     440:	8f 90       	pop	r8
     442:	7f 90       	pop	r7
     444:	6f 90       	pop	r6
     446:	5f 90       	pop	r5
     448:	4f 90       	pop	r4
     44a:	3f 90       	pop	r3
     44c:	2f 90       	pop	r2
     44e:	1f 90       	pop	r1
     450:	0f 90       	pop	r0
     452:	0f be       	out	0x3f, r0	; 63
     454:	0f 90       	pop	r0

	asm volatile ( "ret" );
     456:	08 95       	ret

00000458 <__vector_7>:
	 * DeeThe: Changed from SIG_OUTPUT_COMPARE1A to TIMER1_COMPA_vect
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     458:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <vPortYieldFromTick>
		asm volatile ( "reti" );
     45c:	18 95       	reti

0000045e <prvHeapInit>:

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     45e:	ea ef       	ldi	r30, 0xFA	; 250
     460:	f0 e0       	ldi	r31, 0x00	; 0
     462:	ae ef       	ldi	r26, 0xFE	; 254
     464:	b0 e0       	ldi	r27, 0x00	; 0
     466:	b1 83       	std	Z+1, r27	; 0x01
     468:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
     46a:	13 82       	std	Z+3, r1	; 0x03
     46c:	12 82       	std	Z+2, r1	; 0x02

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
     46e:	e6 ed       	ldi	r30, 0xD6	; 214
     470:	f6 e0       	ldi	r31, 0x06	; 6
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
     472:	f0 93 f9 00 	sts	0x00F9, r31	; 0x8000f9 <pxEnd+0x1>
     476:	e0 93 f8 00 	sts	0x00F8, r30	; 0x8000f8 <pxEnd>
	pxEnd->xBlockSize = 0;
     47a:	13 82       	std	Z+3, r1	; 0x03
     47c:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
     47e:	11 82       	std	Z+1, r1	; 0x01
     480:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
     482:	88 ed       	ldi	r24, 0xD8	; 216
     484:	95 e0       	ldi	r25, 0x05	; 5
     486:	13 96       	adiw	r26, 0x03	; 3
     488:	9c 93       	st	X, r25
     48a:	8e 93       	st	-X, r24
     48c:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
     48e:	ed 93       	st	X+, r30
     490:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     492:	90 93 f5 00 	sts	0x00F5, r25	; 0x8000f5 <xMinimumEverFreeBytesRemaining+0x1>
     496:	80 93 f4 00 	sts	0x00F4, r24	; 0x8000f4 <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     49a:	90 93 f7 00 	sts	0x00F7, r25	; 0x8000f7 <xFreeBytesRemaining+0x1>
     49e:	80 93 f6 00 	sts	0x00F6, r24	; 0x8000f6 <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
     4a2:	80 e0       	ldi	r24, 0x00	; 0
     4a4:	90 e8       	ldi	r25, 0x80	; 128
     4a6:	90 93 f3 00 	sts	0x00F3, r25	; 0x8000f3 <__data_end+0x1>
     4aa:	80 93 f2 00 	sts	0x00F2, r24	; 0x8000f2 <__data_end>
     4ae:	08 95       	ret

000004b0 <prvInsertBlockIntoFreeList>:
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
     4b0:	cf 93       	push	r28
     4b2:	df 93       	push	r29
     4b4:	ec 01       	movw	r28, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     4b6:	aa ef       	ldi	r26, 0xFA	; 250
     4b8:	b0 e0       	ldi	r27, 0x00	; 0
     4ba:	01 c0       	rjmp	.+2      	; 0x4be <prvInsertBlockIntoFreeList+0xe>
     4bc:	df 01       	movw	r26, r30
     4be:	ed 91       	ld	r30, X+
     4c0:	fc 91       	ld	r31, X
     4c2:	11 97       	sbiw	r26, 0x01	; 1
     4c4:	ec 17       	cp	r30, r28
     4c6:	fd 07       	cpc	r31, r29
     4c8:	c8 f3       	brcs	.-14     	; 0x4bc <prvInsertBlockIntoFreeList+0xc>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
     4ca:	12 96       	adiw	r26, 0x02	; 2
     4cc:	8d 91       	ld	r24, X+
     4ce:	9c 91       	ld	r25, X
     4d0:	13 97       	sbiw	r26, 0x03	; 3
     4d2:	9d 01       	movw	r18, r26
     4d4:	28 0f       	add	r18, r24
     4d6:	39 1f       	adc	r19, r25
     4d8:	c2 17       	cp	r28, r18
     4da:	d3 07       	cpc	r29, r19
     4dc:	49 f4       	brne	.+18     	; 0x4f0 <prvInsertBlockIntoFreeList+0x40>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
     4de:	2a 81       	ldd	r18, Y+2	; 0x02
     4e0:	3b 81       	ldd	r19, Y+3	; 0x03
     4e2:	82 0f       	add	r24, r18
     4e4:	93 1f       	adc	r25, r19
     4e6:	13 96       	adiw	r26, 0x03	; 3
     4e8:	9c 93       	st	X, r25
     4ea:	8e 93       	st	-X, r24
     4ec:	12 97       	sbiw	r26, 0x02	; 2
		pxBlockToInsert = pxIterator;
     4ee:	ed 01       	movw	r28, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     4f0:	8a 81       	ldd	r24, Y+2	; 0x02
     4f2:	9b 81       	ldd	r25, Y+3	; 0x03
     4f4:	9e 01       	movw	r18, r28
     4f6:	28 0f       	add	r18, r24
     4f8:	39 1f       	adc	r19, r25
     4fa:	e2 17       	cp	r30, r18
     4fc:	f3 07       	cpc	r31, r19
     4fe:	c1 f4       	brne	.+48     	; 0x530 <prvInsertBlockIntoFreeList+0x80>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
     500:	20 91 f8 00 	lds	r18, 0x00F8	; 0x8000f8 <pxEnd>
     504:	30 91 f9 00 	lds	r19, 0x00F9	; 0x8000f9 <pxEnd+0x1>
     508:	e2 17       	cp	r30, r18
     50a:	f3 07       	cpc	r31, r19
     50c:	71 f0       	breq	.+28     	; 0x52a <prvInsertBlockIntoFreeList+0x7a>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
     50e:	22 81       	ldd	r18, Z+2	; 0x02
     510:	33 81       	ldd	r19, Z+3	; 0x03
     512:	82 0f       	add	r24, r18
     514:	93 1f       	adc	r25, r19
     516:	9b 83       	std	Y+3, r25	; 0x03
     518:	8a 83       	std	Y+2, r24	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
     51a:	ed 91       	ld	r30, X+
     51c:	fc 91       	ld	r31, X
     51e:	11 97       	sbiw	r26, 0x01	; 1
     520:	80 81       	ld	r24, Z
     522:	91 81       	ldd	r25, Z+1	; 0x01
     524:	99 83       	std	Y+1, r25	; 0x01
     526:	88 83       	st	Y, r24
     528:	05 c0       	rjmp	.+10     	; 0x534 <prvInsertBlockIntoFreeList+0x84>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
     52a:	39 83       	std	Y+1, r19	; 0x01
     52c:	28 83       	st	Y, r18
     52e:	02 c0       	rjmp	.+4      	; 0x534 <prvInsertBlockIntoFreeList+0x84>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
     530:	f9 83       	std	Y+1, r31	; 0x01
     532:	e8 83       	st	Y, r30

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
     534:	ca 17       	cp	r28, r26
     536:	db 07       	cpc	r29, r27
     538:	11 f0       	breq	.+4      	; 0x53e <prvInsertBlockIntoFreeList+0x8e>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
     53a:	cd 93       	st	X+, r28
     53c:	dc 93       	st	X, r29
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
     53e:	df 91       	pop	r29
     540:	cf 91       	pop	r28
     542:	08 95       	ret

00000544 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     544:	ef 92       	push	r14
     546:	ff 92       	push	r15
     548:	0f 93       	push	r16
     54a:	1f 93       	push	r17
     54c:	cf 93       	push	r28
     54e:	df 93       	push	r29
     550:	8c 01       	movw	r16, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
     552:	0e 94 4a 05 	call	0xa94	; 0xa94 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
     556:	80 91 f8 00 	lds	r24, 0x00F8	; 0x8000f8 <pxEnd>
     55a:	90 91 f9 00 	lds	r25, 0x00F9	; 0x8000f9 <pxEnd+0x1>
     55e:	89 2b       	or	r24, r25
     560:	11 f4       	brne	.+4      	; 0x566 <pvPortMalloc+0x22>
		{
			prvHeapInit();
     562:	0e 94 2f 02 	call	0x45e	; 0x45e <prvHeapInit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
     566:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__data_end>
     56a:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__data_end+0x1>
     56e:	80 23       	and	r24, r16
     570:	91 23       	and	r25, r17
     572:	89 2b       	or	r24, r25
     574:	09 f0       	breq	.+2      	; 0x578 <pvPortMalloc+0x34>
     576:	67 c0       	rjmp	.+206    	; 0x646 <pvPortMalloc+0x102>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
     578:	01 15       	cp	r16, r1
     57a:	11 05       	cpc	r17, r1
     57c:	11 f0       	breq	.+4      	; 0x582 <pvPortMalloc+0x3e>
			{
				xWantedSize += xHeapStructSize;
     57e:	0c 5f       	subi	r16, 0xFC	; 252
     580:	1f 4f       	sbci	r17, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
     582:	01 15       	cp	r16, r1
     584:	11 05       	cpc	r17, r1
     586:	09 f4       	brne	.+2      	; 0x58a <pvPortMalloc+0x46>
     588:	61 c0       	rjmp	.+194    	; 0x64c <pvPortMalloc+0x108>
     58a:	80 91 f6 00 	lds	r24, 0x00F6	; 0x8000f6 <xFreeBytesRemaining>
     58e:	90 91 f7 00 	lds	r25, 0x00F7	; 0x8000f7 <xFreeBytesRemaining+0x1>
     592:	80 17       	cp	r24, r16
     594:	91 07       	cpc	r25, r17
     596:	08 f4       	brcc	.+2      	; 0x59a <pvPortMalloc+0x56>
     598:	5c c0       	rjmp	.+184    	; 0x652 <pvPortMalloc+0x10e>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
     59a:	c0 91 fa 00 	lds	r28, 0x00FA	; 0x8000fa <xStart>
     59e:	d0 91 fb 00 	lds	r29, 0x00FB	; 0x8000fb <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
     5a2:	ea ef       	ldi	r30, 0xFA	; 250
     5a4:	f0 e0       	ldi	r31, 0x00	; 0
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     5a6:	02 c0       	rjmp	.+4      	; 0x5ac <pvPortMalloc+0x68>
				{
					pxPreviousBlock = pxBlock;
     5a8:	fe 01       	movw	r30, r28
					pxBlock = pxBlock->pxNextFreeBlock;
     5aa:	ec 01       	movw	r28, r24
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     5ac:	8a 81       	ldd	r24, Y+2	; 0x02
     5ae:	9b 81       	ldd	r25, Y+3	; 0x03
     5b0:	80 17       	cp	r24, r16
     5b2:	91 07       	cpc	r25, r17
     5b4:	20 f4       	brcc	.+8      	; 0x5be <pvPortMalloc+0x7a>
     5b6:	88 81       	ld	r24, Y
     5b8:	99 81       	ldd	r25, Y+1	; 0x01
     5ba:	00 97       	sbiw	r24, 0x00	; 0
     5bc:	a9 f7       	brne	.-22     	; 0x5a8 <pvPortMalloc+0x64>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
     5be:	80 91 f8 00 	lds	r24, 0x00F8	; 0x8000f8 <pxEnd>
     5c2:	90 91 f9 00 	lds	r25, 0x00F9	; 0x8000f9 <pxEnd+0x1>
     5c6:	c8 17       	cp	r28, r24
     5c8:	d9 07       	cpc	r29, r25
     5ca:	09 f4       	brne	.+2      	; 0x5ce <pvPortMalloc+0x8a>
     5cc:	45 c0       	rjmp	.+138    	; 0x658 <pvPortMalloc+0x114>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     5ce:	e0 80       	ld	r14, Z
     5d0:	f1 80       	ldd	r15, Z+1	; 0x01
     5d2:	84 e0       	ldi	r24, 0x04	; 4
     5d4:	e8 0e       	add	r14, r24
     5d6:	f1 1c       	adc	r15, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     5d8:	88 81       	ld	r24, Y
     5da:	99 81       	ldd	r25, Y+1	; 0x01
     5dc:	91 83       	std	Z+1, r25	; 0x01
     5de:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     5e0:	2a 81       	ldd	r18, Y+2	; 0x02
     5e2:	3b 81       	ldd	r19, Y+3	; 0x03
     5e4:	20 1b       	sub	r18, r16
     5e6:	31 0b       	sbc	r19, r17
     5e8:	29 30       	cpi	r18, 0x09	; 9
     5ea:	31 05       	cpc	r19, r1
     5ec:	50 f0       	brcs	.+20     	; 0x602 <pvPortMalloc+0xbe>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     5ee:	ce 01       	movw	r24, r28
     5f0:	80 0f       	add	r24, r16
     5f2:	91 1f       	adc	r25, r17
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     5f4:	fc 01       	movw	r30, r24
     5f6:	33 83       	std	Z+3, r19	; 0x03
     5f8:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
     5fa:	1b 83       	std	Y+3, r17	; 0x03
     5fc:	0a 83       	std	Y+2, r16	; 0x02

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
     5fe:	0e 94 58 02 	call	0x4b0	; 0x4b0 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
     602:	2a 81       	ldd	r18, Y+2	; 0x02
     604:	3b 81       	ldd	r19, Y+3	; 0x03
     606:	80 91 f6 00 	lds	r24, 0x00F6	; 0x8000f6 <xFreeBytesRemaining>
     60a:	90 91 f7 00 	lds	r25, 0x00F7	; 0x8000f7 <xFreeBytesRemaining+0x1>
     60e:	82 1b       	sub	r24, r18
     610:	93 0b       	sbc	r25, r19
     612:	90 93 f7 00 	sts	0x00F7, r25	; 0x8000f7 <xFreeBytesRemaining+0x1>
     616:	80 93 f6 00 	sts	0x00F6, r24	; 0x8000f6 <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
     61a:	40 91 f4 00 	lds	r20, 0x00F4	; 0x8000f4 <xMinimumEverFreeBytesRemaining>
     61e:	50 91 f5 00 	lds	r21, 0x00F5	; 0x8000f5 <xMinimumEverFreeBytesRemaining+0x1>
     622:	84 17       	cp	r24, r20
     624:	95 07       	cpc	r25, r21
     626:	20 f4       	brcc	.+8      	; 0x630 <pvPortMalloc+0xec>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
     628:	90 93 f5 00 	sts	0x00F5, r25	; 0x8000f5 <xMinimumEverFreeBytesRemaining+0x1>
     62c:	80 93 f4 00 	sts	0x00F4, r24	; 0x8000f4 <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
     630:	80 91 f2 00 	lds	r24, 0x00F2	; 0x8000f2 <__data_end>
     634:	90 91 f3 00 	lds	r25, 0x00F3	; 0x8000f3 <__data_end+0x1>
     638:	28 2b       	or	r18, r24
     63a:	39 2b       	or	r19, r25
     63c:	3b 83       	std	Y+3, r19	; 0x03
     63e:	2a 83       	std	Y+2, r18	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
     640:	19 82       	std	Y+1, r1	; 0x01
     642:	18 82       	st	Y, r1
     644:	0b c0       	rjmp	.+22     	; 0x65c <pvPortMalloc+0x118>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
     646:	e1 2c       	mov	r14, r1
     648:	f1 2c       	mov	r15, r1
     64a:	08 c0       	rjmp	.+16     	; 0x65c <pvPortMalloc+0x118>
     64c:	e1 2c       	mov	r14, r1
     64e:	f1 2c       	mov	r15, r1
     650:	05 c0       	rjmp	.+10     	; 0x65c <pvPortMalloc+0x118>
     652:	e1 2c       	mov	r14, r1
     654:	f1 2c       	mov	r15, r1
     656:	02 c0       	rjmp	.+4      	; 0x65c <pvPortMalloc+0x118>
     658:	e1 2c       	mov	r14, r1
     65a:	f1 2c       	mov	r15, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     65c:	0e 94 14 06 	call	0xc28	; 0xc28 <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
     660:	c7 01       	movw	r24, r14
     662:	df 91       	pop	r29
     664:	cf 91       	pop	r28
     666:	1f 91       	pop	r17
     668:	0f 91       	pop	r16
     66a:	ff 90       	pop	r15
     66c:	ef 90       	pop	r14
     66e:	08 95       	ret

00000670 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     670:	0f 93       	push	r16
     672:	1f 93       	push	r17
     674:	cf 93       	push	r28
     676:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     678:	00 97       	sbiw	r24, 0x00	; 0
     67a:	51 f1       	breq	.+84     	; 0x6d0 <vPortFree+0x60>
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
     67c:	ec 01       	movw	r28, r24
     67e:	24 97       	sbiw	r28, 0x04	; 4

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
     680:	4a 81       	ldd	r20, Y+2	; 0x02
     682:	5b 81       	ldd	r21, Y+3	; 0x03
     684:	20 91 f2 00 	lds	r18, 0x00F2	; 0x8000f2 <__data_end>
     688:	30 91 f3 00 	lds	r19, 0x00F3	; 0x8000f3 <__data_end+0x1>
     68c:	ba 01       	movw	r22, r20
     68e:	62 23       	and	r22, r18
     690:	73 23       	and	r23, r19
     692:	67 2b       	or	r22, r23
     694:	e9 f0       	breq	.+58     	; 0x6d0 <vPortFree+0x60>
		{
			if( pxLink->pxNextFreeBlock == NULL )
     696:	68 81       	ld	r22, Y
     698:	79 81       	ldd	r23, Y+1	; 0x01
     69a:	67 2b       	or	r22, r23
     69c:	c9 f4       	brne	.+50     	; 0x6d0 <vPortFree+0x60>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
     69e:	20 95       	com	r18
     6a0:	30 95       	com	r19
     6a2:	24 23       	and	r18, r20
     6a4:	35 23       	and	r19, r21
     6a6:	3b 83       	std	Y+3, r19	; 0x03
     6a8:	2a 83       	std	Y+2, r18	; 0x02

				vTaskSuspendAll();
     6aa:	0e 94 4a 05 	call	0xa94	; 0xa94 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
     6ae:	8a 81       	ldd	r24, Y+2	; 0x02
     6b0:	9b 81       	ldd	r25, Y+3	; 0x03
     6b2:	20 91 f6 00 	lds	r18, 0x00F6	; 0x8000f6 <xFreeBytesRemaining>
     6b6:	30 91 f7 00 	lds	r19, 0x00F7	; 0x8000f7 <xFreeBytesRemaining+0x1>
     6ba:	82 0f       	add	r24, r18
     6bc:	93 1f       	adc	r25, r19
     6be:	90 93 f7 00 	sts	0x00F7, r25	; 0x8000f7 <xFreeBytesRemaining+0x1>
     6c2:	80 93 f6 00 	sts	0x00F6, r24	; 0x8000f6 <xFreeBytesRemaining>
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
     6c6:	ce 01       	movw	r24, r28
     6c8:	0e 94 58 02 	call	0x4b0	; 0x4b0 <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
     6cc:	0e 94 14 06 	call	0xc28	; 0xc28 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     6d0:	df 91       	pop	r29
     6d2:	cf 91       	pop	r28
     6d4:	1f 91       	pop	r17
     6d6:	0f 91       	pop	r16
     6d8:	08 95       	ret

000006da <prvResetNextTaskUnblockTime>:
	/* If null is passed in here then the name of the calling task is being
	queried. */
	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
	configASSERT( pxTCB );
	return &( pxTCB->pcTaskName[ 0 ] );
}
     6da:	e0 91 f3 06 	lds	r30, 0x06F3	; 0x8006f3 <pxDelayedTaskList>
     6de:	f0 91 f4 06 	lds	r31, 0x06F4	; 0x8006f4 <pxDelayedTaskList+0x1>
     6e2:	80 81       	ld	r24, Z
     6e4:	81 11       	cpse	r24, r1
     6e6:	07 c0       	rjmp	.+14     	; 0x6f6 <prvResetNextTaskUnblockTime+0x1c>
     6e8:	8f ef       	ldi	r24, 0xFF	; 255
     6ea:	9f ef       	ldi	r25, 0xFF	; 255
     6ec:	90 93 de 06 	sts	0x06DE, r25	; 0x8006de <xNextTaskUnblockTime+0x1>
     6f0:	80 93 dd 06 	sts	0x06DD, r24	; 0x8006dd <xNextTaskUnblockTime>
     6f4:	08 95       	ret
     6f6:	e0 91 f3 06 	lds	r30, 0x06F3	; 0x8006f3 <pxDelayedTaskList>
     6fa:	f0 91 f4 06 	lds	r31, 0x06F4	; 0x8006f4 <pxDelayedTaskList+0x1>
     6fe:	05 80       	ldd	r0, Z+5	; 0x05
     700:	f6 81       	ldd	r31, Z+6	; 0x06
     702:	e0 2d       	mov	r30, r0
     704:	06 80       	ldd	r0, Z+6	; 0x06
     706:	f7 81       	ldd	r31, Z+7	; 0x07
     708:	e0 2d       	mov	r30, r0
     70a:	82 81       	ldd	r24, Z+2	; 0x02
     70c:	93 81       	ldd	r25, Z+3	; 0x03
     70e:	90 93 de 06 	sts	0x06DE, r25	; 0x8006de <xNextTaskUnblockTime+0x1>
     712:	80 93 dd 06 	sts	0x06DD, r24	; 0x8006dd <xNextTaskUnblockTime>
     716:	08 95       	ret

00000718 <prvInitialiseNewTask>:
     718:	6f 92       	push	r6
     71a:	7f 92       	push	r7
     71c:	8f 92       	push	r8
     71e:	9f 92       	push	r9
     720:	af 92       	push	r10
     722:	bf 92       	push	r11
     724:	cf 92       	push	r12
     726:	df 92       	push	r13
     728:	ef 92       	push	r14
     72a:	0f 93       	push	r16
     72c:	1f 93       	push	r17
     72e:	cf 93       	push	r28
     730:	df 93       	push	r29
     732:	cd b7       	in	r28, 0x3d	; 61
     734:	de b7       	in	r29, 0x3e	; 62
     736:	4c 01       	movw	r8, r24
     738:	f5 01       	movw	r30, r10
     73a:	87 89       	ldd	r24, Z+23	; 0x17
     73c:	90 8d       	ldd	r25, Z+24	; 0x18
     73e:	21 50       	subi	r18, 0x01	; 1
     740:	31 09       	sbc	r19, r1
     742:	3c 01       	movw	r6, r24
     744:	62 0e       	add	r6, r18
     746:	73 1e       	adc	r7, r19
     748:	20 e0       	ldi	r18, 0x00	; 0
     74a:	0f c0       	rjmp	.+30     	; 0x76a <prvInitialiseNewTask+0x52>
     74c:	82 2f       	mov	r24, r18
     74e:	90 e0       	ldi	r25, 0x00	; 0
     750:	fb 01       	movw	r30, r22
     752:	e8 0f       	add	r30, r24
     754:	f9 1f       	adc	r31, r25
     756:	30 81       	ld	r19, Z
     758:	d5 01       	movw	r26, r10
     75a:	a8 0f       	add	r26, r24
     75c:	b9 1f       	adc	r27, r25
     75e:	59 96       	adiw	r26, 0x19	; 25
     760:	3c 93       	st	X, r19
     762:	80 81       	ld	r24, Z
     764:	88 23       	and	r24, r24
     766:	19 f0       	breq	.+6      	; 0x76e <prvInitialiseNewTask+0x56>
     768:	2f 5f       	subi	r18, 0xFF	; 255
     76a:	28 30       	cpi	r18, 0x08	; 8
     76c:	78 f3       	brcs	.-34     	; 0x74c <prvInitialiseNewTask+0x34>
     76e:	f5 01       	movw	r30, r10
     770:	10 a2       	std	Z+32, r1	; 0x20
     772:	f3 e0       	ldi	r31, 0x03	; 3
     774:	fe 15       	cp	r31, r14
     776:	20 f4       	brcc	.+8      	; 0x780 <prvInitialiseNewTask+0x68>
     778:	0f 2e       	mov	r0, r31
     77a:	f3 e0       	ldi	r31, 0x03	; 3
     77c:	ef 2e       	mov	r14, r31
     77e:	f0 2d       	mov	r31, r0
     780:	f5 01       	movw	r30, r10
     782:	e6 8a       	std	Z+22, r14	; 0x16
     784:	c5 01       	movw	r24, r10
     786:	02 96       	adiw	r24, 0x02	; 2
     788:	0e 94 57 00 	call	0xae	; 0xae <vListInitialiseItem>
     78c:	c5 01       	movw	r24, r10
     78e:	0c 96       	adiw	r24, 0x0c	; 12
     790:	0e 94 57 00 	call	0xae	; 0xae <vListInitialiseItem>
     794:	f5 01       	movw	r30, r10
     796:	b1 86       	std	Z+9, r11	; 0x09
     798:	a0 86       	std	Z+8, r10	; 0x08
     79a:	84 e0       	ldi	r24, 0x04	; 4
     79c:	90 e0       	ldi	r25, 0x00	; 0
     79e:	8e 19       	sub	r24, r14
     7a0:	91 09       	sbc	r25, r1
     7a2:	95 87       	std	Z+13, r25	; 0x0d
     7a4:	84 87       	std	Z+12, r24	; 0x0c
     7a6:	b3 8a       	std	Z+19, r11	; 0x13
     7a8:	a2 8a       	std	Z+18, r10	; 0x12
     7aa:	11 a2       	std	Z+33, r1	; 0x21
     7ac:	12 a2       	std	Z+34, r1	; 0x22
     7ae:	13 a2       	std	Z+35, r1	; 0x23
     7b0:	14 a2       	std	Z+36, r1	; 0x24
     7b2:	15 a2       	std	Z+37, r1	; 0x25
     7b4:	a8 01       	movw	r20, r16
     7b6:	b4 01       	movw	r22, r8
     7b8:	c3 01       	movw	r24, r6
     7ba:	0e 94 dc 00 	call	0x1b8	; 0x1b8 <pxPortInitialiseStack>
     7be:	f5 01       	movw	r30, r10
     7c0:	91 83       	std	Z+1, r25	; 0x01
     7c2:	80 83       	st	Z, r24
     7c4:	c1 14       	cp	r12, r1
     7c6:	d1 04       	cpc	r13, r1
     7c8:	19 f0       	breq	.+6      	; 0x7d0 <prvInitialiseNewTask+0xb8>
     7ca:	f6 01       	movw	r30, r12
     7cc:	b1 82       	std	Z+1, r11	; 0x01
     7ce:	a0 82       	st	Z, r10
     7d0:	df 91       	pop	r29
     7d2:	cf 91       	pop	r28
     7d4:	1f 91       	pop	r17
     7d6:	0f 91       	pop	r16
     7d8:	ef 90       	pop	r14
     7da:	df 90       	pop	r13
     7dc:	cf 90       	pop	r12
     7de:	bf 90       	pop	r11
     7e0:	af 90       	pop	r10
     7e2:	9f 90       	pop	r9
     7e4:	8f 90       	pop	r8
     7e6:	7f 90       	pop	r7
     7e8:	6f 90       	pop	r6
     7ea:	08 95       	ret

000007ec <prvIdleTask>:
     7ec:	80 91 07 07 	lds	r24, 0x0707	; 0x800707 <pxReadyTasksLists>
     7f0:	82 30       	cpi	r24, 0x02	; 2
     7f2:	e0 f3       	brcs	.-8      	; 0x7ec <prvIdleTask>
     7f4:	0e 94 77 01 	call	0x2ee	; 0x2ee <vPortYield>
     7f8:	f9 cf       	rjmp	.-14     	; 0x7ec <prvIdleTask>

000007fa <prvInitialiseTaskLists>:
     7fa:	cf 93       	push	r28
     7fc:	c0 e0       	ldi	r28, 0x00	; 0
     7fe:	10 c0       	rjmp	.+32     	; 0x820 <__DATA_REGION_LENGTH__+0x20>
     800:	8c 2f       	mov	r24, r28
     802:	90 e0       	ldi	r25, 0x00	; 0
     804:	9c 01       	movw	r18, r24
     806:	22 0f       	add	r18, r18
     808:	33 1f       	adc	r19, r19
     80a:	22 0f       	add	r18, r18
     80c:	33 1f       	adc	r19, r19
     80e:	22 0f       	add	r18, r18
     810:	33 1f       	adc	r19, r19
     812:	82 0f       	add	r24, r18
     814:	93 1f       	adc	r25, r19
     816:	89 5f       	subi	r24, 0xF9	; 249
     818:	98 4f       	sbci	r25, 0xF8	; 248
     81a:	0e 94 49 00 	call	0x92	; 0x92 <vListInitialise>
     81e:	cf 5f       	subi	r28, 0xFF	; 255
     820:	c4 30       	cpi	r28, 0x04	; 4
     822:	70 f3       	brcs	.-36     	; 0x800 <__DATA_REGION_LENGTH__>
     824:	8e ef       	ldi	r24, 0xFE	; 254
     826:	96 e0       	ldi	r25, 0x06	; 6
     828:	0e 94 49 00 	call	0x92	; 0x92 <vListInitialise>
     82c:	85 ef       	ldi	r24, 0xF5	; 245
     82e:	96 e0       	ldi	r25, 0x06	; 6
     830:	0e 94 49 00 	call	0x92	; 0x92 <vListInitialise>
     834:	88 ee       	ldi	r24, 0xE8	; 232
     836:	96 e0       	ldi	r25, 0x06	; 6
     838:	0e 94 49 00 	call	0x92	; 0x92 <vListInitialise>
     83c:	8e ef       	ldi	r24, 0xFE	; 254
     83e:	96 e0       	ldi	r25, 0x06	; 6
     840:	90 93 f4 06 	sts	0x06F4, r25	; 0x8006f4 <pxDelayedTaskList+0x1>
     844:	80 93 f3 06 	sts	0x06F3, r24	; 0x8006f3 <pxDelayedTaskList>
     848:	85 ef       	ldi	r24, 0xF5	; 245
     84a:	96 e0       	ldi	r25, 0x06	; 6
     84c:	90 93 f2 06 	sts	0x06F2, r25	; 0x8006f2 <pxOverflowDelayedTaskList+0x1>
     850:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <pxOverflowDelayedTaskList>
     854:	cf 91       	pop	r28
     856:	08 95       	ret

00000858 <prvAddNewTaskToReadyList>:
     858:	cf 93       	push	r28
     85a:	df 93       	push	r29
     85c:	ec 01       	movw	r28, r24
     85e:	0f b6       	in	r0, 0x3f	; 63
     860:	f8 94       	cli
     862:	0f 92       	push	r0
     864:	80 91 e7 06 	lds	r24, 0x06E7	; 0x8006e7 <uxCurrentNumberOfTasks>
     868:	8f 5f       	subi	r24, 0xFF	; 255
     86a:	80 93 e7 06 	sts	0x06E7, r24	; 0x8006e7 <uxCurrentNumberOfTasks>
     86e:	80 91 2b 07 	lds	r24, 0x072B	; 0x80072b <pxCurrentTCB>
     872:	90 91 2c 07 	lds	r25, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     876:	89 2b       	or	r24, r25
     878:	59 f4       	brne	.+22     	; 0x890 <__stack+0x31>
     87a:	d0 93 2c 07 	sts	0x072C, r29	; 0x80072c <pxCurrentTCB+0x1>
     87e:	c0 93 2b 07 	sts	0x072B, r28	; 0x80072b <pxCurrentTCB>
     882:	80 91 e7 06 	lds	r24, 0x06E7	; 0x8006e7 <uxCurrentNumberOfTasks>
     886:	81 30       	cpi	r24, 0x01	; 1
     888:	99 f4       	brne	.+38     	; 0x8b0 <__stack+0x51>
     88a:	0e 94 fd 03 	call	0x7fa	; 0x7fa <prvInitialiseTaskLists>
     88e:	10 c0       	rjmp	.+32     	; 0x8b0 <__stack+0x51>
     890:	80 91 e3 06 	lds	r24, 0x06E3	; 0x8006e3 <xSchedulerRunning>
     894:	81 11       	cpse	r24, r1
     896:	0c c0       	rjmp	.+24     	; 0x8b0 <__stack+0x51>
     898:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxCurrentTCB>
     89c:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     8a0:	96 89       	ldd	r25, Z+22	; 0x16
     8a2:	8e 89       	ldd	r24, Y+22	; 0x16
     8a4:	89 17       	cp	r24, r25
     8a6:	20 f0       	brcs	.+8      	; 0x8b0 <__stack+0x51>
     8a8:	d0 93 2c 07 	sts	0x072C, r29	; 0x80072c <pxCurrentTCB+0x1>
     8ac:	c0 93 2b 07 	sts	0x072B, r28	; 0x80072b <pxCurrentTCB>
     8b0:	80 91 df 06 	lds	r24, 0x06DF	; 0x8006df <uxTaskNumber>
     8b4:	8f 5f       	subi	r24, 0xFF	; 255
     8b6:	80 93 df 06 	sts	0x06DF, r24	; 0x8006df <uxTaskNumber>
     8ba:	8e 89       	ldd	r24, Y+22	; 0x16
     8bc:	90 91 e4 06 	lds	r25, 0x06E4	; 0x8006e4 <uxTopReadyPriority>
     8c0:	98 17       	cp	r25, r24
     8c2:	10 f4       	brcc	.+4      	; 0x8c8 <__stack+0x69>
     8c4:	80 93 e4 06 	sts	0x06E4, r24	; 0x8006e4 <uxTopReadyPriority>
     8c8:	90 e0       	ldi	r25, 0x00	; 0
     8ca:	9c 01       	movw	r18, r24
     8cc:	22 0f       	add	r18, r18
     8ce:	33 1f       	adc	r19, r19
     8d0:	22 0f       	add	r18, r18
     8d2:	33 1f       	adc	r19, r19
     8d4:	22 0f       	add	r18, r18
     8d6:	33 1f       	adc	r19, r19
     8d8:	82 0f       	add	r24, r18
     8da:	93 1f       	adc	r25, r19
     8dc:	be 01       	movw	r22, r28
     8de:	6e 5f       	subi	r22, 0xFE	; 254
     8e0:	7f 4f       	sbci	r23, 0xFF	; 255
     8e2:	89 5f       	subi	r24, 0xF9	; 249
     8e4:	98 4f       	sbci	r25, 0xF8	; 248
     8e6:	0e 94 5b 00 	call	0xb6	; 0xb6 <vListInsertEnd>
     8ea:	0f 90       	pop	r0
     8ec:	0f be       	out	0x3f, r0	; 63
     8ee:	80 91 e3 06 	lds	r24, 0x06E3	; 0x8006e3 <xSchedulerRunning>
     8f2:	88 23       	and	r24, r24
     8f4:	51 f0       	breq	.+20     	; 0x90a <__stack+0xab>
     8f6:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxCurrentTCB>
     8fa:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     8fe:	96 89       	ldd	r25, Z+22	; 0x16
     900:	8e 89       	ldd	r24, Y+22	; 0x16
     902:	98 17       	cp	r25, r24
     904:	10 f4       	brcc	.+4      	; 0x90a <__stack+0xab>
     906:	0e 94 77 01 	call	0x2ee	; 0x2ee <vPortYield>
     90a:	df 91       	pop	r29
     90c:	cf 91       	pop	r28
     90e:	08 95       	ret

00000910 <prvAddCurrentTaskToDelayedList>:
     910:	0f 93       	push	r16
     912:	1f 93       	push	r17
     914:	cf 93       	push	r28
     916:	df 93       	push	r29
     918:	ec 01       	movw	r28, r24
     91a:	00 91 e5 06 	lds	r16, 0x06E5	; 0x8006e5 <xTickCount>
     91e:	10 91 e6 06 	lds	r17, 0x06E6	; 0x8006e6 <xTickCount+0x1>
     922:	80 91 2b 07 	lds	r24, 0x072B	; 0x80072b <pxCurrentTCB>
     926:	90 91 2c 07 	lds	r25, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     92a:	02 96       	adiw	r24, 0x02	; 2
     92c:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>
     930:	c0 0f       	add	r28, r16
     932:	d1 1f       	adc	r29, r17
     934:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxCurrentTCB>
     938:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     93c:	d3 83       	std	Z+3, r29	; 0x03
     93e:	c2 83       	std	Z+2, r28	; 0x02
     940:	c0 17       	cp	r28, r16
     942:	d1 07       	cpc	r29, r17
     944:	68 f4       	brcc	.+26     	; 0x960 <prvAddCurrentTaskToDelayedList+0x50>
     946:	60 91 2b 07 	lds	r22, 0x072B	; 0x80072b <pxCurrentTCB>
     94a:	70 91 2c 07 	lds	r23, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     94e:	80 91 f1 06 	lds	r24, 0x06F1	; 0x8006f1 <pxOverflowDelayedTaskList>
     952:	90 91 f2 06 	lds	r25, 0x06F2	; 0x8006f2 <pxOverflowDelayedTaskList+0x1>
     956:	6e 5f       	subi	r22, 0xFE	; 254
     958:	7f 4f       	sbci	r23, 0xFF	; 255
     95a:	0e 94 7c 00 	call	0xf8	; 0xf8 <vListInsert>
     95e:	17 c0       	rjmp	.+46     	; 0x98e <prvAddCurrentTaskToDelayedList+0x7e>
     960:	60 91 2b 07 	lds	r22, 0x072B	; 0x80072b <pxCurrentTCB>
     964:	70 91 2c 07 	lds	r23, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     968:	80 91 f3 06 	lds	r24, 0x06F3	; 0x8006f3 <pxDelayedTaskList>
     96c:	90 91 f4 06 	lds	r25, 0x06F4	; 0x8006f4 <pxDelayedTaskList+0x1>
     970:	6e 5f       	subi	r22, 0xFE	; 254
     972:	7f 4f       	sbci	r23, 0xFF	; 255
     974:	0e 94 7c 00 	call	0xf8	; 0xf8 <vListInsert>
     978:	80 91 dd 06 	lds	r24, 0x06DD	; 0x8006dd <xNextTaskUnblockTime>
     97c:	90 91 de 06 	lds	r25, 0x06DE	; 0x8006de <xNextTaskUnblockTime+0x1>
     980:	c8 17       	cp	r28, r24
     982:	d9 07       	cpc	r29, r25
     984:	20 f4       	brcc	.+8      	; 0x98e <prvAddCurrentTaskToDelayedList+0x7e>
     986:	d0 93 de 06 	sts	0x06DE, r29	; 0x8006de <xNextTaskUnblockTime+0x1>
     98a:	c0 93 dd 06 	sts	0x06DD, r28	; 0x8006dd <xNextTaskUnblockTime>
     98e:	df 91       	pop	r29
     990:	cf 91       	pop	r28
     992:	1f 91       	pop	r17
     994:	0f 91       	pop	r16
     996:	08 95       	ret

00000998 <xTaskCreate>:
     998:	2f 92       	push	r2
     99a:	3f 92       	push	r3
     99c:	4f 92       	push	r4
     99e:	5f 92       	push	r5
     9a0:	6f 92       	push	r6
     9a2:	7f 92       	push	r7
     9a4:	8f 92       	push	r8
     9a6:	9f 92       	push	r9
     9a8:	af 92       	push	r10
     9aa:	bf 92       	push	r11
     9ac:	cf 92       	push	r12
     9ae:	df 92       	push	r13
     9b0:	ef 92       	push	r14
     9b2:	ff 92       	push	r15
     9b4:	0f 93       	push	r16
     9b6:	1f 93       	push	r17
     9b8:	cf 93       	push	r28
     9ba:	df 93       	push	r29
     9bc:	3c 01       	movw	r6, r24
     9be:	1b 01       	movw	r2, r22
     9c0:	5a 01       	movw	r10, r20
     9c2:	29 01       	movw	r4, r18
     9c4:	ca 01       	movw	r24, r20
     9c6:	0e 94 a2 02 	call	0x544	; 0x544 <pvPortMalloc>
     9ca:	6c 01       	movw	r12, r24
     9cc:	89 2b       	or	r24, r25
     9ce:	71 f0       	breq	.+28     	; 0x9ec <xTaskCreate+0x54>
     9d0:	86 e2       	ldi	r24, 0x26	; 38
     9d2:	90 e0       	ldi	r25, 0x00	; 0
     9d4:	0e 94 a2 02 	call	0x544	; 0x544 <pvPortMalloc>
     9d8:	ec 01       	movw	r28, r24
     9da:	89 2b       	or	r24, r25
     9dc:	19 f0       	breq	.+6      	; 0x9e4 <xTaskCreate+0x4c>
     9de:	d8 8e       	std	Y+24, r13	; 0x18
     9e0:	cf 8a       	std	Y+23, r12	; 0x17
     9e2:	06 c0       	rjmp	.+12     	; 0x9f0 <xTaskCreate+0x58>
     9e4:	c6 01       	movw	r24, r12
     9e6:	0e 94 38 03 	call	0x670	; 0x670 <vPortFree>
     9ea:	02 c0       	rjmp	.+4      	; 0x9f0 <xTaskCreate+0x58>
     9ec:	c0 e0       	ldi	r28, 0x00	; 0
     9ee:	d0 e0       	ldi	r29, 0x00	; 0
     9f0:	20 97       	sbiw	r28, 0x00	; 0
     9f2:	91 f0       	breq	.+36     	; 0xa18 <xTaskCreate+0x80>
     9f4:	95 01       	movw	r18, r10
     9f6:	40 e0       	ldi	r20, 0x00	; 0
     9f8:	50 e0       	ldi	r21, 0x00	; 0
     9fa:	81 2c       	mov	r8, r1
     9fc:	91 2c       	mov	r9, r1
     9fe:	5e 01       	movw	r10, r28
     a00:	67 01       	movw	r12, r14
     a02:	e0 2e       	mov	r14, r16
     a04:	82 01       	movw	r16, r4
     a06:	b1 01       	movw	r22, r2
     a08:	c3 01       	movw	r24, r6
     a0a:	0e 94 8c 03 	call	0x718	; 0x718 <prvInitialiseNewTask>
     a0e:	ce 01       	movw	r24, r28
     a10:	0e 94 2c 04 	call	0x858	; 0x858 <prvAddNewTaskToReadyList>
     a14:	81 e0       	ldi	r24, 0x01	; 1
     a16:	01 c0       	rjmp	.+2      	; 0xa1a <xTaskCreate+0x82>
     a18:	8f ef       	ldi	r24, 0xFF	; 255
     a1a:	df 91       	pop	r29
     a1c:	cf 91       	pop	r28
     a1e:	1f 91       	pop	r17
     a20:	0f 91       	pop	r16
     a22:	ff 90       	pop	r15
     a24:	ef 90       	pop	r14
     a26:	df 90       	pop	r13
     a28:	cf 90       	pop	r12
     a2a:	bf 90       	pop	r11
     a2c:	af 90       	pop	r10
     a2e:	9f 90       	pop	r9
     a30:	8f 90       	pop	r8
     a32:	7f 90       	pop	r7
     a34:	6f 90       	pop	r6
     a36:	5f 90       	pop	r5
     a38:	4f 90       	pop	r4
     a3a:	3f 90       	pop	r3
     a3c:	2f 90       	pop	r2
     a3e:	08 95       	ret

00000a40 <vTaskStartScheduler>:
     a40:	ef 92       	push	r14
     a42:	ff 92       	push	r15
     a44:	0f 93       	push	r16
     a46:	0f 2e       	mov	r0, r31
     a48:	fb ed       	ldi	r31, 0xDB	; 219
     a4a:	ef 2e       	mov	r14, r31
     a4c:	f6 e0       	ldi	r31, 0x06	; 6
     a4e:	ff 2e       	mov	r15, r31
     a50:	f0 2d       	mov	r31, r0
     a52:	00 e0       	ldi	r16, 0x00	; 0
     a54:	20 e0       	ldi	r18, 0x00	; 0
     a56:	30 e0       	ldi	r19, 0x00	; 0
     a58:	45 e5       	ldi	r20, 0x55	; 85
     a5a:	50 e0       	ldi	r21, 0x00	; 0
     a5c:	6e e6       	ldi	r22, 0x6E	; 110
     a5e:	70 e0       	ldi	r23, 0x00	; 0
     a60:	86 ef       	ldi	r24, 0xF6	; 246
     a62:	93 e0       	ldi	r25, 0x03	; 3
     a64:	0e 94 cc 04 	call	0x998	; 0x998 <xTaskCreate>
     a68:	81 30       	cpi	r24, 0x01	; 1
     a6a:	81 f4       	brne	.+32     	; 0xa8c <vTaskStartScheduler+0x4c>
     a6c:	f8 94       	cli
     a6e:	8f ef       	ldi	r24, 0xFF	; 255
     a70:	9f ef       	ldi	r25, 0xFF	; 255
     a72:	90 93 de 06 	sts	0x06DE, r25	; 0x8006de <xNextTaskUnblockTime+0x1>
     a76:	80 93 dd 06 	sts	0x06DD, r24	; 0x8006dd <xNextTaskUnblockTime>
     a7a:	81 e0       	ldi	r24, 0x01	; 1
     a7c:	80 93 e3 06 	sts	0x06E3, r24	; 0x8006e3 <xSchedulerRunning>
     a80:	10 92 e6 06 	sts	0x06E6, r1	; 0x8006e6 <xTickCount+0x1>
     a84:	10 92 e5 06 	sts	0x06E5, r1	; 0x8006e5 <xTickCount>
     a88:	0e 94 48 01 	call	0x290	; 0x290 <xPortStartScheduler>
     a8c:	0f 91       	pop	r16
     a8e:	ff 90       	pop	r15
     a90:	ef 90       	pop	r14
     a92:	08 95       	ret

00000a94 <vTaskSuspendAll>:
     a94:	80 91 da 06 	lds	r24, 0x06DA	; 0x8006da <uxSchedulerSuspended>
     a98:	8f 5f       	subi	r24, 0xFF	; 255
     a9a:	80 93 da 06 	sts	0x06DA, r24	; 0x8006da <uxSchedulerSuspended>
     a9e:	08 95       	ret

00000aa0 <xTaskGetTickCount>:
     aa0:	0f b6       	in	r0, 0x3f	; 63
     aa2:	f8 94       	cli
     aa4:	0f 92       	push	r0
     aa6:	80 91 e5 06 	lds	r24, 0x06E5	; 0x8006e5 <xTickCount>
     aaa:	90 91 e6 06 	lds	r25, 0x06E6	; 0x8006e6 <xTickCount+0x1>
     aae:	0f 90       	pop	r0
     ab0:	0f be       	out	0x3f, r0	; 63
     ab2:	08 95       	ret

00000ab4 <xTaskIncrementTick>:

#endif /* INCLUDE_xTaskAbortDelay */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     ab4:	df 92       	push	r13
     ab6:	ef 92       	push	r14
     ab8:	ff 92       	push	r15
     aba:	0f 93       	push	r16
     abc:	1f 93       	push	r17
     abe:	cf 93       	push	r28
     ac0:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     ac2:	80 91 da 06 	lds	r24, 0x06DA	; 0x8006da <uxSchedulerSuspended>
     ac6:	81 11       	cpse	r24, r1
     ac8:	97 c0       	rjmp	.+302    	; 0xbf8 <xTaskIncrementTick+0x144>
	{
		/* Minor optimisation.  The tick count cannot change in this
		block. */
		const TickType_t xConstTickCount = xTickCount + 1;
     aca:	e0 90 e5 06 	lds	r14, 0x06E5	; 0x8006e5 <xTickCount>
     ace:	f0 90 e6 06 	lds	r15, 0x06E6	; 0x8006e6 <xTickCount+0x1>
     ad2:	8f ef       	ldi	r24, 0xFF	; 255
     ad4:	e8 1a       	sub	r14, r24
     ad6:	f8 0a       	sbc	r15, r24

		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		xTickCount = xConstTickCount;
     ad8:	f0 92 e6 06 	sts	0x06E6, r15	; 0x8006e6 <xTickCount+0x1>
     adc:	e0 92 e5 06 	sts	0x06E5, r14	; 0x8006e5 <xTickCount>

		if( xConstTickCount == ( TickType_t ) 0U )
     ae0:	e1 14       	cp	r14, r1
     ae2:	f1 04       	cpc	r15, r1
     ae4:	b9 f4       	brne	.+46     	; 0xb14 <xTaskIncrementTick+0x60>
		{
			taskSWITCH_DELAYED_LISTS();
     ae6:	80 91 f3 06 	lds	r24, 0x06F3	; 0x8006f3 <pxDelayedTaskList>
     aea:	90 91 f4 06 	lds	r25, 0x06F4	; 0x8006f4 <pxDelayedTaskList+0x1>
     aee:	20 91 f1 06 	lds	r18, 0x06F1	; 0x8006f1 <pxOverflowDelayedTaskList>
     af2:	30 91 f2 06 	lds	r19, 0x06F2	; 0x8006f2 <pxOverflowDelayedTaskList+0x1>
     af6:	30 93 f4 06 	sts	0x06F4, r19	; 0x8006f4 <pxDelayedTaskList+0x1>
     afa:	20 93 f3 06 	sts	0x06F3, r18	; 0x8006f3 <pxDelayedTaskList>
     afe:	90 93 f2 06 	sts	0x06F2, r25	; 0x8006f2 <pxOverflowDelayedTaskList+0x1>
     b02:	80 93 f1 06 	sts	0x06F1, r24	; 0x8006f1 <pxOverflowDelayedTaskList>
     b06:	80 91 e0 06 	lds	r24, 0x06E0	; 0x8006e0 <xNumOfOverflows>
     b0a:	8f 5f       	subi	r24, 0xFF	; 255
     b0c:	80 93 e0 06 	sts	0x06E0, r24	; 0x8006e0 <xNumOfOverflows>
     b10:	0e 94 6d 03 	call	0x6da	; 0x6da <prvResetNextTaskUnblockTime>

		/* See if this tick has made a timeout expire.  Tasks are stored in
		the	queue in the order of their wake time - meaning once one task
		has been found whose block time has not expired there is no need to
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
     b14:	80 91 dd 06 	lds	r24, 0x06DD	; 0x8006dd <xNextTaskUnblockTime>
     b18:	90 91 de 06 	lds	r25, 0x06DE	; 0x8006de <xNextTaskUnblockTime+0x1>
     b1c:	e8 16       	cp	r14, r24
     b1e:	f9 06       	cpc	r15, r25
     b20:	28 f4       	brcc	.+10     	; 0xb2c <xTaskIncrementTick+0x78>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     b22:	d1 2c       	mov	r13, r1
     b24:	53 c0       	rjmp	.+166    	; 0xbcc <xTaskIncrementTick+0x118>
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
						{
							xSwitchRequired = pdTRUE;
     b26:	dd 24       	eor	r13, r13
     b28:	d3 94       	inc	r13
     b2a:	01 c0       	rjmp	.+2      	; 0xb2e <xTaskIncrementTick+0x7a>
     b2c:	d1 2c       	mov	r13, r1
		look any further down the list. */
		if( xConstTickCount >= xNextTaskUnblockTime )
		{
			for( ;; )
			{
				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     b2e:	e0 91 f3 06 	lds	r30, 0x06F3	; 0x8006f3 <pxDelayedTaskList>
     b32:	f0 91 f4 06 	lds	r31, 0x06F4	; 0x8006f4 <pxDelayedTaskList+0x1>
     b36:	80 81       	ld	r24, Z
     b38:	81 11       	cpse	r24, r1
     b3a:	07 c0       	rjmp	.+14     	; 0xb4a <xTaskIncrementTick+0x96>
					/* The delayed list is empty.  Set xNextTaskUnblockTime
					to the maximum possible value so it is extremely
					unlikely that the
					if( xTickCount >= xNextTaskUnblockTime ) test will pass
					next time through. */
					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     b3c:	8f ef       	ldi	r24, 0xFF	; 255
     b3e:	9f ef       	ldi	r25, 0xFF	; 255
     b40:	90 93 de 06 	sts	0x06DE, r25	; 0x8006de <xNextTaskUnblockTime+0x1>
     b44:	80 93 dd 06 	sts	0x06DD, r24	; 0x8006dd <xNextTaskUnblockTime>
					break;
     b48:	41 c0       	rjmp	.+130    	; 0xbcc <xTaskIncrementTick+0x118>
				{
					/* The delayed list is not empty, get the value of the
					item at the head of the delayed list.  This is the time
					at which the task at the head of the delayed list must
					be removed from the Blocked state. */
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     b4a:	e0 91 f3 06 	lds	r30, 0x06F3	; 0x8006f3 <pxDelayedTaskList>
     b4e:	f0 91 f4 06 	lds	r31, 0x06F4	; 0x8006f4 <pxDelayedTaskList+0x1>
     b52:	05 80       	ldd	r0, Z+5	; 0x05
     b54:	f6 81       	ldd	r31, Z+6	; 0x06
     b56:	e0 2d       	mov	r30, r0
     b58:	c6 81       	ldd	r28, Z+6	; 0x06
     b5a:	d7 81       	ldd	r29, Z+7	; 0x07
					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
     b5c:	8a 81       	ldd	r24, Y+2	; 0x02
     b5e:	9b 81       	ldd	r25, Y+3	; 0x03

					if( xConstTickCount < xItemValue )
     b60:	e8 16       	cp	r14, r24
     b62:	f9 06       	cpc	r15, r25
     b64:	28 f4       	brcc	.+10     	; 0xb70 <xTaskIncrementTick+0xbc>
						/* It is not time to unblock this item yet, but the
						item value is the time at which the task at the head
						of the blocked list must be removed from the Blocked
						state -	so record the item value in
						xNextTaskUnblockTime. */
						xNextTaskUnblockTime = xItemValue;
     b66:	90 93 de 06 	sts	0x06DE, r25	; 0x8006de <xNextTaskUnblockTime+0x1>
     b6a:	80 93 dd 06 	sts	0x06DD, r24	; 0x8006dd <xNextTaskUnblockTime>
						break;
     b6e:	2e c0       	rjmp	.+92     	; 0xbcc <xTaskIncrementTick+0x118>
					{
						mtCOVERAGE_TEST_MARKER();
					}

					/* It is time to remove the item from the Blocked state. */
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     b70:	8e 01       	movw	r16, r28
     b72:	0e 5f       	subi	r16, 0xFE	; 254
     b74:	1f 4f       	sbci	r17, 0xFF	; 255
     b76:	c8 01       	movw	r24, r16
     b78:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>

					/* Is the task waiting on an event also?  If so remove
					it from the event list. */
					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     b7c:	8c 89       	ldd	r24, Y+20	; 0x14
     b7e:	9d 89       	ldd	r25, Y+21	; 0x15
     b80:	89 2b       	or	r24, r25
     b82:	21 f0       	breq	.+8      	; 0xb8c <xTaskIncrementTick+0xd8>
					{
						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     b84:	ce 01       	movw	r24, r28
     b86:	0c 96       	adiw	r24, 0x0c	; 12
     b88:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					/* Place the unblocked task into the appropriate ready
					list. */
					prvAddTaskToReadyList( pxTCB );
     b8c:	8e 89       	ldd	r24, Y+22	; 0x16
     b8e:	90 91 e4 06 	lds	r25, 0x06E4	; 0x8006e4 <uxTopReadyPriority>
     b92:	98 17       	cp	r25, r24
     b94:	10 f4       	brcc	.+4      	; 0xb9a <xTaskIncrementTick+0xe6>
     b96:	80 93 e4 06 	sts	0x06E4, r24	; 0x8006e4 <uxTopReadyPriority>
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	9c 01       	movw	r18, r24
     b9e:	22 0f       	add	r18, r18
     ba0:	33 1f       	adc	r19, r19
     ba2:	22 0f       	add	r18, r18
     ba4:	33 1f       	adc	r19, r19
     ba6:	22 0f       	add	r18, r18
     ba8:	33 1f       	adc	r19, r19
     baa:	82 0f       	add	r24, r18
     bac:	93 1f       	adc	r25, r19
     bae:	b8 01       	movw	r22, r16
     bb0:	89 5f       	subi	r24, 0xF9	; 249
     bb2:	98 4f       	sbci	r25, 0xF8	; 248
     bb4:	0e 94 5b 00 	call	0xb6	; 0xb6 <vListInsertEnd>
					{
						/* Preemption is on, but a context switch should
						only be performed if the unblocked task has a
						priority that is equal to or higher than the
						currently executing task. */
						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     bb8:	9e 89       	ldd	r25, Y+22	; 0x16
     bba:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxCurrentTCB>
     bbe:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     bc2:	86 89       	ldd	r24, Z+22	; 0x16
     bc4:	98 17       	cp	r25, r24
     bc6:	08 f0       	brcs	.+2      	; 0xbca <xTaskIncrementTick+0x116>
     bc8:	ae cf       	rjmp	.-164    	; 0xb26 <xTaskIncrementTick+0x72>
     bca:	b1 cf       	rjmp	.-158    	; 0xb2e <xTaskIncrementTick+0x7a>
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     bcc:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxCurrentTCB>
     bd0:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     bd4:	86 89       	ldd	r24, Z+22	; 0x16
     bd6:	90 e0       	ldi	r25, 0x00	; 0
     bd8:	fc 01       	movw	r30, r24
     bda:	ee 0f       	add	r30, r30
     bdc:	ff 1f       	adc	r31, r31
     bde:	ee 0f       	add	r30, r30
     be0:	ff 1f       	adc	r31, r31
     be2:	ee 0f       	add	r30, r30
     be4:	ff 1f       	adc	r31, r31
     be6:	8e 0f       	add	r24, r30
     be8:	9f 1f       	adc	r25, r31
     bea:	fc 01       	movw	r30, r24
     bec:	e9 5f       	subi	r30, 0xF9	; 249
     bee:	f8 4f       	sbci	r31, 0xF8	; 248
     bf0:	80 81       	ld	r24, Z
     bf2:	82 30       	cpi	r24, 0x02	; 2
     bf4:	40 f4       	brcc	.+16     	; 0xc06 <xTaskIncrementTick+0x152>
     bf6:	09 c0       	rjmp	.+18     	; 0xc0a <xTaskIncrementTick+0x156>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     bf8:	80 91 e2 06 	lds	r24, 0x06E2	; 0x8006e2 <uxPendedTicks>
     bfc:	8f 5f       	subi	r24, 0xFF	; 255
     bfe:	80 93 e2 06 	sts	0x06E2, r24	; 0x8006e2 <uxPendedTicks>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     c02:	d1 2c       	mov	r13, r1
     c04:	02 c0       	rjmp	.+4      	; 0xc0a <xTaskIncrementTick+0x156>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
     c06:	dd 24       	eor	r13, r13
     c08:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     c0a:	80 91 e1 06 	lds	r24, 0x06E1	; 0x8006e1 <xYieldPending>
     c0e:	88 23       	and	r24, r24
     c10:	11 f0       	breq	.+4      	; 0xc16 <xTaskIncrementTick+0x162>
		{
			xSwitchRequired = pdTRUE;
     c12:	dd 24       	eor	r13, r13
     c14:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     c16:	8d 2d       	mov	r24, r13
     c18:	df 91       	pop	r29
     c1a:	cf 91       	pop	r28
     c1c:	1f 91       	pop	r17
     c1e:	0f 91       	pop	r16
     c20:	ff 90       	pop	r15
     c22:	ef 90       	pop	r14
     c24:	df 90       	pop	r13
     c26:	08 95       	ret

00000c28 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     c28:	0f 93       	push	r16
     c2a:	1f 93       	push	r17
     c2c:	cf 93       	push	r28
     c2e:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     c30:	0f b6       	in	r0, 0x3f	; 63
     c32:	f8 94       	cli
     c34:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     c36:	80 91 da 06 	lds	r24, 0x06DA	; 0x8006da <uxSchedulerSuspended>
     c3a:	81 50       	subi	r24, 0x01	; 1
     c3c:	80 93 da 06 	sts	0x06DA, r24	; 0x8006da <uxSchedulerSuspended>

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c40:	80 91 da 06 	lds	r24, 0x06DA	; 0x8006da <uxSchedulerSuspended>
     c44:	81 11       	cpse	r24, r1
     c46:	58 c0       	rjmp	.+176    	; 0xcf8 <xTaskResumeAll+0xd0>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     c48:	80 91 e7 06 	lds	r24, 0x06E7	; 0x8006e7 <uxCurrentNumberOfTasks>
     c4c:	81 11       	cpse	r24, r1
     c4e:	33 c0       	rjmp	.+102    	; 0xcb6 <xTaskResumeAll+0x8e>
     c50:	56 c0       	rjmp	.+172    	; 0xcfe <xTaskResumeAll+0xd6>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     c52:	e0 91 ed 06 	lds	r30, 0x06ED	; 0x8006ed <xPendingReadyList+0x5>
     c56:	f0 91 ee 06 	lds	r31, 0x06EE	; 0x8006ee <xPendingReadyList+0x6>
     c5a:	c6 81       	ldd	r28, Z+6	; 0x06
     c5c:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     c5e:	ce 01       	movw	r24, r28
     c60:	0c 96       	adiw	r24, 0x0c	; 12
     c62:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
     c66:	8e 01       	movw	r16, r28
     c68:	0e 5f       	subi	r16, 0xFE	; 254
     c6a:	1f 4f       	sbci	r17, 0xFF	; 255
     c6c:	c8 01       	movw	r24, r16
     c6e:	0e 94 ad 00 	call	0x15a	; 0x15a <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     c72:	8e 89       	ldd	r24, Y+22	; 0x16
     c74:	90 91 e4 06 	lds	r25, 0x06E4	; 0x8006e4 <uxTopReadyPriority>
     c78:	98 17       	cp	r25, r24
     c7a:	10 f4       	brcc	.+4      	; 0xc80 <xTaskResumeAll+0x58>
     c7c:	80 93 e4 06 	sts	0x06E4, r24	; 0x8006e4 <uxTopReadyPriority>
     c80:	90 e0       	ldi	r25, 0x00	; 0
     c82:	9c 01       	movw	r18, r24
     c84:	22 0f       	add	r18, r18
     c86:	33 1f       	adc	r19, r19
     c88:	22 0f       	add	r18, r18
     c8a:	33 1f       	adc	r19, r19
     c8c:	22 0f       	add	r18, r18
     c8e:	33 1f       	adc	r19, r19
     c90:	82 0f       	add	r24, r18
     c92:	93 1f       	adc	r25, r19
     c94:	b8 01       	movw	r22, r16
     c96:	89 5f       	subi	r24, 0xF9	; 249
     c98:	98 4f       	sbci	r25, 0xF8	; 248
     c9a:	0e 94 5b 00 	call	0xb6	; 0xb6 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     c9e:	9e 89       	ldd	r25, Y+22	; 0x16
     ca0:	e0 91 2b 07 	lds	r30, 0x072B	; 0x80072b <pxCurrentTCB>
     ca4:	f0 91 2c 07 	lds	r31, 0x072C	; 0x80072c <pxCurrentTCB+0x1>
     ca8:	86 89       	ldd	r24, Z+22	; 0x16
     caa:	98 17       	cp	r25, r24
     cac:	30 f0       	brcs	.+12     	; 0xcba <xTaskResumeAll+0x92>
					{
						xYieldPending = pdTRUE;
     cae:	81 e0       	ldi	r24, 0x01	; 1
     cb0:	80 93 e1 06 	sts	0x06E1, r24	; 0x8006e1 <xYieldPending>
     cb4:	02 c0       	rjmp	.+4      	; 0xcba <xTaskResumeAll+0x92>
     cb6:	c0 e0       	ldi	r28, 0x00	; 0
     cb8:	d0 e0       	ldi	r29, 0x00	; 0
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     cba:	80 91 e8 06 	lds	r24, 0x06E8	; 0x8006e8 <xPendingReadyList>
     cbe:	81 11       	cpse	r24, r1
     cc0:	c8 cf       	rjmp	.-112    	; 0xc52 <xTaskResumeAll+0x2a>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( pxTCB != NULL )
     cc2:	cd 2b       	or	r28, r29
     cc4:	11 f0       	breq	.+4      	; 0xcca <xTaskResumeAll+0xa2>
					which may have prevented the next unblock time from being
					re-calculated, in which case re-calculate it now.  Mainly
					important for low power tickless implementations, where
					this can prevent an unnecessary exit from low power
					state. */
					prvResetNextTaskUnblockTime();
     cc6:	0e 94 6d 03 	call	0x6da	; 0x6da <prvResetNextTaskUnblockTime>
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				{
					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
     cca:	c0 91 e2 06 	lds	r28, 0x06E2	; 0x8006e2 <uxPendedTicks>

					if( uxPendedCounts > ( UBaseType_t ) 0U )
     cce:	cc 23       	and	r28, r28
     cd0:	59 f0       	breq	.+22     	; 0xce8 <xTaskResumeAll+0xc0>
					{
						do
						{
							if( xTaskIncrementTick() != pdFALSE )
     cd2:	0e 94 5a 05 	call	0xab4	; 0xab4 <xTaskIncrementTick>
     cd6:	88 23       	and	r24, r24
     cd8:	19 f0       	breq	.+6      	; 0xce0 <xTaskResumeAll+0xb8>
							{
								xYieldPending = pdTRUE;
     cda:	81 e0       	ldi	r24, 0x01	; 1
     cdc:	80 93 e1 06 	sts	0x06E1, r24	; 0x8006e1 <xYieldPending>
							}
							else
							{
								mtCOVERAGE_TEST_MARKER();
							}
							--uxPendedCounts;
     ce0:	c1 50       	subi	r28, 0x01	; 1
						} while( uxPendedCounts > ( UBaseType_t ) 0U );
     ce2:	b9 f7       	brne	.-18     	; 0xcd2 <xTaskResumeAll+0xaa>

						uxPendedTicks = 0;
     ce4:	10 92 e2 06 	sts	0x06E2, r1	; 0x8006e2 <uxPendedTicks>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				if( xYieldPending != pdFALSE )
     ce8:	80 91 e1 06 	lds	r24, 0x06E1	; 0x8006e1 <xYieldPending>
     cec:	88 23       	and	r24, r24
     cee:	31 f0       	breq	.+12     	; 0xcfc <xTaskResumeAll+0xd4>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     cf0:	0e 94 77 01 	call	0x2ee	; 0x2ee <vPortYield>

				if( xYieldPending != pdFALSE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     cf4:	81 e0       	ldi	r24, 0x01	; 1
     cf6:	03 c0       	rjmp	.+6      	; 0xcfe <xTaskResumeAll+0xd6>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB = NULL;
BaseType_t xAlreadyYielded = pdFALSE;
     cf8:	80 e0       	ldi	r24, 0x00	; 0
     cfa:	01 c0       	rjmp	.+2      	; 0xcfe <xTaskResumeAll+0xd6>
     cfc:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     cfe:	0f 90       	pop	r0
     d00:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     d02:	df 91       	pop	r29
     d04:	cf 91       	pop	r28
     d06:	1f 91       	pop	r17
     d08:	0f 91       	pop	r16
     d0a:	08 95       	ret

00000d0c <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     d0c:	0f 93       	push	r16
     d0e:	1f 93       	push	r17
     d10:	cf 93       	push	r28
     d12:	df 93       	push	r29
     d14:	8c 01       	movw	r16, r24
     d16:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     d18:	0e 94 4a 05 	call	0xa94	; 0xa94 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     d1c:	40 91 e5 06 	lds	r20, 0x06E5	; 0x8006e5 <xTickCount>
     d20:	50 91 e6 06 	lds	r21, 0x06E6	; 0x8006e6 <xTickCount+0x1>

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     d24:	f8 01       	movw	r30, r16
     d26:	20 81       	ld	r18, Z
     d28:	31 81       	ldd	r19, Z+1	; 0x01
     d2a:	c9 01       	movw	r24, r18
     d2c:	8c 0f       	add	r24, r28
     d2e:	9d 1f       	adc	r25, r29

			if( xConstTickCount < *pxPreviousWakeTime )
     d30:	42 17       	cp	r20, r18
     d32:	53 07       	cpc	r21, r19
     d34:	40 f4       	brcc	.+16     	; 0xd46 <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     d36:	82 17       	cp	r24, r18
     d38:	93 07       	cpc	r25, r19
     d3a:	68 f4       	brcc	.+26     	; 0xd56 <vTaskDelayUntil+0x4a>
     d3c:	48 17       	cp	r20, r24
     d3e:	59 07       	cpc	r21, r25
     d40:	60 f0       	brcs	.+24     	; 0xd5a <vTaskDelayUntil+0x4e>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     d42:	20 e0       	ldi	r18, 0x00	; 0
     d44:	0f c0       	rjmp	.+30     	; 0xd64 <vTaskDelayUntil+0x58>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     d46:	82 17       	cp	r24, r18
     d48:	93 07       	cpc	r25, r19
     d4a:	48 f0       	brcs	.+18     	; 0xd5e <vTaskDelayUntil+0x52>
     d4c:	48 17       	cp	r20, r24
     d4e:	59 07       	cpc	r21, r25
     d50:	40 f0       	brcs	.+16     	; 0xd62 <vTaskDelayUntil+0x56>
#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
     d52:	20 e0       	ldi	r18, 0x00	; 0
     d54:	07 c0       	rjmp	.+14     	; 0xd64 <vTaskDelayUntil+0x58>
     d56:	20 e0       	ldi	r18, 0x00	; 0
     d58:	05 c0       	rjmp	.+10     	; 0xd64 <vTaskDelayUntil+0x58>
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     d5a:	21 e0       	ldi	r18, 0x01	; 1
     d5c:	03 c0       	rjmp	.+6      	; 0xd64 <vTaskDelayUntil+0x58>
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
				{
					xShouldDelay = pdTRUE;
     d5e:	21 e0       	ldi	r18, 0x01	; 1
     d60:	01 c0       	rjmp	.+2      	; 0xd64 <vTaskDelayUntil+0x58>
     d62:	21 e0       	ldi	r18, 0x01	; 1
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     d64:	f8 01       	movw	r30, r16
     d66:	91 83       	std	Z+1, r25	; 0x01
     d68:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
     d6a:	22 23       	and	r18, r18
     d6c:	29 f0       	breq	.+10     	; 0xd78 <vTaskDelayUntil+0x6c>
			{
				traceTASK_DELAY_UNTIL( xTimeToWake );

				/* prvAddCurrentTaskToDelayedList() needs the block time, not
				the time to wake, so subtract the current tick count. */
				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
     d6e:	60 e0       	ldi	r22, 0x00	; 0
     d70:	84 1b       	sub	r24, r20
     d72:	95 0b       	sbc	r25, r21
     d74:	0e 94 88 04 	call	0x910	; 0x910 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     d78:	0e 94 14 06 	call	0xc28	; 0xc28 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     d7c:	81 11       	cpse	r24, r1
     d7e:	02 c0       	rjmp	.+4      	; 0xd84 <vTaskDelayUntil+0x78>
		{
			portYIELD_WITHIN_API();
     d80:	0e 94 77 01 	call	0x2ee	; 0x2ee <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     d84:	df 91       	pop	r29
     d86:	cf 91       	pop	r28
     d88:	1f 91       	pop	r17
     d8a:	0f 91       	pop	r16
     d8c:	08 95       	ret

00000d8e <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     d8e:	80 91 da 06 	lds	r24, 0x06DA	; 0x8006da <uxSchedulerSuspended>
     d92:	88 23       	and	r24, r24
     d94:	21 f0       	breq	.+8      	; 0xd9e <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     d96:	81 e0       	ldi	r24, 0x01	; 1
     d98:	80 93 e1 06 	sts	0x06E1, r24	; 0x8006e1 <xYieldPending>
     d9c:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     d9e:	10 92 e1 06 	sts	0x06E1, r1	; 0x8006e1 <xYieldPending>
		/* Check for stack overflow, if configured. */
		taskCHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     da2:	20 91 e4 06 	lds	r18, 0x06E4	; 0x8006e4 <uxTopReadyPriority>
     da6:	01 c0       	rjmp	.+2      	; 0xdaa <vTaskSwitchContext+0x1c>
     da8:	21 50       	subi	r18, 0x01	; 1
     daa:	82 2f       	mov	r24, r18
     dac:	90 e0       	ldi	r25, 0x00	; 0
     dae:	fc 01       	movw	r30, r24
     db0:	ee 0f       	add	r30, r30
     db2:	ff 1f       	adc	r31, r31
     db4:	ee 0f       	add	r30, r30
     db6:	ff 1f       	adc	r31, r31
     db8:	ee 0f       	add	r30, r30
     dba:	ff 1f       	adc	r31, r31
     dbc:	e8 0f       	add	r30, r24
     dbe:	f9 1f       	adc	r31, r25
     dc0:	e9 5f       	subi	r30, 0xF9	; 249
     dc2:	f8 4f       	sbci	r31, 0xF8	; 248
     dc4:	30 81       	ld	r19, Z
     dc6:	33 23       	and	r19, r19
     dc8:	79 f3       	breq	.-34     	; 0xda8 <vTaskSwitchContext+0x1a>
     dca:	ac 01       	movw	r20, r24
     dcc:	44 0f       	add	r20, r20
     dce:	55 1f       	adc	r21, r21
     dd0:	44 0f       	add	r20, r20
     dd2:	55 1f       	adc	r21, r21
     dd4:	44 0f       	add	r20, r20
     dd6:	55 1f       	adc	r21, r21
     dd8:	48 0f       	add	r20, r24
     dda:	59 1f       	adc	r21, r25
     ddc:	df 01       	movw	r26, r30
     dde:	01 80       	ldd	r0, Z+1	; 0x01
     de0:	f2 81       	ldd	r31, Z+2	; 0x02
     de2:	e0 2d       	mov	r30, r0
     de4:	02 80       	ldd	r0, Z+2	; 0x02
     de6:	f3 81       	ldd	r31, Z+3	; 0x03
     de8:	e0 2d       	mov	r30, r0
     dea:	12 96       	adiw	r26, 0x02	; 2
     dec:	fc 93       	st	X, r31
     dee:	ee 93       	st	-X, r30
     df0:	11 97       	sbiw	r26, 0x01	; 1
     df2:	46 5f       	subi	r20, 0xF6	; 246
     df4:	58 4f       	sbci	r21, 0xF8	; 248
     df6:	e4 17       	cp	r30, r20
     df8:	f5 07       	cpc	r31, r21
     dfa:	29 f4       	brne	.+10     	; 0xe06 <vTaskSwitchContext+0x78>
     dfc:	42 81       	ldd	r20, Z+2	; 0x02
     dfe:	53 81       	ldd	r21, Z+3	; 0x03
     e00:	fd 01       	movw	r30, r26
     e02:	52 83       	std	Z+2, r21	; 0x02
     e04:	41 83       	std	Z+1, r20	; 0x01
     e06:	fc 01       	movw	r30, r24
     e08:	ee 0f       	add	r30, r30
     e0a:	ff 1f       	adc	r31, r31
     e0c:	ee 0f       	add	r30, r30
     e0e:	ff 1f       	adc	r31, r31
     e10:	ee 0f       	add	r30, r30
     e12:	ff 1f       	adc	r31, r31
     e14:	8e 0f       	add	r24, r30
     e16:	9f 1f       	adc	r25, r31
     e18:	fc 01       	movw	r30, r24
     e1a:	e9 5f       	subi	r30, 0xF9	; 249
     e1c:	f8 4f       	sbci	r31, 0xF8	; 248
     e1e:	01 80       	ldd	r0, Z+1	; 0x01
     e20:	f2 81       	ldd	r31, Z+2	; 0x02
     e22:	e0 2d       	mov	r30, r0
     e24:	86 81       	ldd	r24, Z+6	; 0x06
     e26:	97 81       	ldd	r25, Z+7	; 0x07
     e28:	90 93 2c 07 	sts	0x072C, r25	; 0x80072c <pxCurrentTCB+0x1>
     e2c:	80 93 2b 07 	sts	0x072B, r24	; 0x80072b <pxCurrentTCB>
     e30:	20 93 e4 06 	sts	0x06E4, r18	; 0x8006e4 <uxTopReadyPriority>
     e34:	08 95       	ret

00000e36 <KP_Init>:
* @param [in]  KP_CH   -  Keypad channel number.
*
* @return function error state.
*/
extern ERROR_STATE_t KP_Init(uint8_t KP_CH)
{
     e36:	ff 92       	push	r15
     e38:	0f 93       	push	r16
     e3a:	1f 93       	push	r17
     e3c:	cf 93       	push	r28
     e3e:	df 93       	push	r29
   /* Variable to store function error state. */
   ERROR_STATE_t KP_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(KP_INVALID_CH <= KP_CH)
     e40:	81 11       	cpse	r24, r1
     e42:	4e c0       	rjmp	.+156    	; 0xee0 <KP_Init+0xaa>
     e44:	08 2f       	mov	r16, r24
     e46:	10 e0       	ldi	r17, 0x00	; 0
     e48:	17 c0       	rjmp	.+46     	; 0xe78 <KP_Init+0x42>
   else
   {
      /* Set columns pins to input and set pull up resistors  */
      for(uint8_t u8_Counter = 0; u8_Counter < aSTR_KPConfig[KP_CH].u8_KPCols; u8_Counter++)
      {
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_Counter) , PIN_INPUT);
     e4a:	9e 01       	movw	r18, r28
     e4c:	22 0f       	add	r18, r18
     e4e:	33 1f       	adc	r19, r19
     e50:	f9 01       	movw	r30, r18
     e52:	ec 0f       	add	r30, r28
     e54:	fd 1f       	adc	r31, r29
     e56:	ee 0f       	add	r30, r30
     e58:	ff 1f       	adc	r31, r31
     e5a:	e7 52       	subi	r30, 0x27	; 39
     e5c:	ff 4f       	sbci	r31, 0xFF	; 255
     e5e:	f5 80       	ldd	r15, Z+5	; 0x05
     e60:	f1 0e       	add	r15, r17
     e62:	c4 81       	ldd	r28, Z+4	; 0x04
     e64:	40 e0       	ldi	r20, 0x00	; 0
     e66:	6f 2d       	mov	r22, r15
     e68:	8c 2f       	mov	r24, r28
     e6a:	0e 94 37 09 	call	0x126e	; 0x126e <DIO_SetPinDirection>
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_Counter));
     e6e:	6f 2d       	mov	r22, r15
     e70:	8c 2f       	mov	r24, r28
     e72:	0e 94 4c 0a 	call	0x1498	; 0x1498 <DIO_EnablePinPullup>
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_INVALID_CH);
   }
   else
   {
      /* Set columns pins to input and set pull up resistors  */
      for(uint8_t u8_Counter = 0; u8_Counter < aSTR_KPConfig[KP_CH].u8_KPCols; u8_Counter++)
     e76:	1f 5f       	subi	r17, 0xFF	; 255
     e78:	c0 2f       	mov	r28, r16
     e7a:	d0 e0       	ldi	r29, 0x00	; 0
     e7c:	fe 01       	movw	r30, r28
     e7e:	ee 0f       	add	r30, r30
     e80:	ff 1f       	adc	r31, r31
     e82:	ec 0f       	add	r30, r28
     e84:	fd 1f       	adc	r31, r29
     e86:	ee 0f       	add	r30, r30
     e88:	ff 1f       	adc	r31, r31
     e8a:	e7 52       	subi	r30, 0x27	; 39
     e8c:	ff 4f       	sbci	r31, 0xFF	; 255
     e8e:	83 81       	ldd	r24, Z+3	; 0x03
     e90:	18 17       	cp	r17, r24
     e92:	d8 f2       	brcs	.-74     	; 0xe4a <KP_Init+0x14>
     e94:	10 e0       	ldi	r17, 0x00	; 0
     e96:	16 c0       	rjmp	.+44     	; 0xec4 <KP_Init+0x8e>
      }
      
      /* Set rows pins to input and set pull up resistors */
      for(uint8_t u8_Counter = 0; u8_Counter < aSTR_KPConfig[KP_CH].u8_KPRows; u8_Counter++)
      {
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_Counter) , PIN_INPUT);
     e98:	fe 01       	movw	r30, r28
     e9a:	ee 0f       	add	r30, r30
     e9c:	ff 1f       	adc	r31, r31
     e9e:	ec 0f       	add	r30, r28
     ea0:	fd 1f       	adc	r31, r29
     ea2:	ee 0f       	add	r30, r30
     ea4:	ff 1f       	adc	r31, r31
     ea6:	e7 52       	subi	r30, 0x27	; 39
     ea8:	ff 4f       	sbci	r31, 0xFF	; 255
     eaa:	02 81       	ldd	r16, Z+2	; 0x02
     eac:	01 0f       	add	r16, r17
     eae:	f1 80       	ldd	r15, Z+1	; 0x01
     eb0:	40 e0       	ldi	r20, 0x00	; 0
     eb2:	60 2f       	mov	r22, r16
     eb4:	8f 2d       	mov	r24, r15
     eb6:	0e 94 37 09 	call	0x126e	; 0x126e <DIO_SetPinDirection>
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_Counter));
     eba:	60 2f       	mov	r22, r16
     ebc:	8f 2d       	mov	r24, r15
     ebe:	0e 94 4c 0a 	call	0x1498	; 0x1498 <DIO_EnablePinPullup>
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_Counter) , PIN_INPUT);
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_Counter));
      }
      
      /* Set rows pins to input and set pull up resistors */
      for(uint8_t u8_Counter = 0; u8_Counter < aSTR_KPConfig[KP_CH].u8_KPRows; u8_Counter++)
     ec2:	1f 5f       	subi	r17, 0xFF	; 255
     ec4:	fe 01       	movw	r30, r28
     ec6:	ee 0f       	add	r30, r30
     ec8:	ff 1f       	adc	r31, r31
     eca:	ec 0f       	add	r30, r28
     ecc:	fd 1f       	adc	r31, r29
     ece:	ee 0f       	add	r30, r30
     ed0:	ff 1f       	adc	r31, r31
     ed2:	e7 52       	subi	r30, 0x27	; 39
     ed4:	ff 4f       	sbci	r31, 0xFF	; 255
     ed6:	80 81       	ld	r24, Z
     ed8:	18 17       	cp	r17, r24
     eda:	f0 f2       	brcs	.-68     	; 0xe98 <KP_Init+0x62>
      {
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_Counter) , PIN_INPUT);
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_Counter));
      }
      KP_ErrorState = ERROR_OK;
     edc:	80 e0       	ldi	r24, 0x00	; 0
     ede:	01 c0       	rjmp	.+2      	; 0xee2 <KP_Init+0xac>
   
   /* Validate valid Parameters are passed. */
   if(KP_INVALID_CH <= KP_CH)
   {
      /* Set invalid channel error. */
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_INVALID_CH);
     ee0:	82 ee       	ldi	r24, 0xE2	; 226
      KP_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return KP_ErrorState;
}
     ee2:	df 91       	pop	r29
     ee4:	cf 91       	pop	r28
     ee6:	1f 91       	pop	r17
     ee8:	0f 91       	pop	r16
     eea:	ff 90       	pop	r15
     eec:	08 95       	ret

00000eee <KP_GetPressedValue>:
* @param [out] Data     -  Pressed Key Value.
*
* @return function error state.
*/
ERROR_STATE_t KP_GetPressedValue(uint8_t KP_CH, uint32_t * const Data)
{
     eee:	5f 92       	push	r5
     ef0:	6f 92       	push	r6
     ef2:	7f 92       	push	r7
     ef4:	8f 92       	push	r8
     ef6:	9f 92       	push	r9
     ef8:	af 92       	push	r10
     efa:	bf 92       	push	r11
     efc:	cf 92       	push	r12
     efe:	df 92       	push	r13
     f00:	ef 92       	push	r14
     f02:	ff 92       	push	r15
     f04:	0f 93       	push	r16
     f06:	1f 93       	push	r17
     f08:	cf 93       	push	r28
     f0a:	df 93       	push	r29
     f0c:	1f 92       	push	r1
     f0e:	cd b7       	in	r28, 0x3d	; 61
     f10:	de b7       	in	r29, 0x3e	; 62
   /* Variable to store function error state. */
   ERROR_STATE_t KP_ErrorState;
      
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Data)
     f12:	61 15       	cp	r22, r1
     f14:	71 05       	cpc	r23, r1
     f16:	09 f4       	brne	.+2      	; 0xf1a <KP_GetPressedValue+0x2c>
     f18:	87 c0       	rjmp	.+270    	; 0x1028 <KP_GetPressedValue+0x13a>
   {
      /* Set null pointer error. */
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_NULL_PTR);
   }
   else if(KP_INVALID_CH <= KP_CH)
     f1a:	81 11       	cpse	r24, r1
     f1c:	87 c0       	rjmp	.+270    	; 0x102c <KP_GetPressedValue+0x13e>
     f1e:	6b 01       	movw	r12, r22
     f20:	e8 2e       	mov	r14, r24
     f22:	61 2c       	mov	r6, r1
     f24:	81 2c       	mov	r8, r1
     f26:	91 2c       	mov	r9, r1
     f28:	54 01       	movw	r10, r8
     f2a:	68 c0       	rjmp	.+208    	; 0xffc <KP_GetPressedValue+0x10e>
      
      /* loops on every column */
      for(uint8_t u8_ColCounter = 0; u8_ColCounter < aSTR_KPConfig[KP_CH].u8_KPCols; u8_ColCounter++)
      {
         /* set column direction to output and value to low */
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter) , PIN_OUTPUT);
     f2c:	f8 01       	movw	r30, r16
     f2e:	ee 0f       	add	r30, r30
     f30:	ff 1f       	adc	r31, r31
     f32:	e0 0f       	add	r30, r16
     f34:	f1 1f       	adc	r31, r17
     f36:	ee 0f       	add	r30, r30
     f38:	ff 1f       	adc	r31, r31
     f3a:	e7 52       	subi	r30, 0x27	; 39
     f3c:	ff 4f       	sbci	r31, 0xFF	; 255
     f3e:	75 80       	ldd	r7, Z+5	; 0x05
     f40:	76 0c       	add	r7, r6
     f42:	54 80       	ldd	r5, Z+4	; 0x04
     f44:	41 e0       	ldi	r20, 0x01	; 1
     f46:	67 2d       	mov	r22, r7
     f48:	85 2d       	mov	r24, r5
     f4a:	0e 94 37 09 	call	0x126e	; 0x126e <DIO_SetPinDirection>
         DIO_WritePin(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter), PIN_LOW);
     f4e:	40 e0       	ldi	r20, 0x00	; 0
     f50:	67 2d       	mov	r22, r7
     f52:	85 2d       	mov	r24, r5
     f54:	0e 94 a0 09 	call	0x1340	; 0x1340 <DIO_WritePin>
         
         /* loops on every row */
         for(uint8_t u8_RowCounter = 0; u8_RowCounter < aSTR_KPConfig[KP_CH].u8_KPRows; u8_RowCounter++)
     f58:	f1 2c       	mov	r15, r1
     f5a:	39 c0       	rjmp	.+114    	; 0xfce <KP_GetPressedValue+0xe0>
         {
            /* read row value */
            DIO_ReadPin(aSTR_KPConfig[KP_CH].u8_KPRowPort, (aSTR_KPConfig[KP_CH].u8_KPRowPinStart + u8_RowCounter), &u8_KeyState);
     f5c:	f8 01       	movw	r30, r16
     f5e:	ee 0f       	add	r30, r30
     f60:	ff 1f       	adc	r31, r31
     f62:	e0 0f       	add	r30, r16
     f64:	f1 1f       	adc	r31, r17
     f66:	ee 0f       	add	r30, r30
     f68:	ff 1f       	adc	r31, r31
     f6a:	e7 52       	subi	r30, 0x27	; 39
     f6c:	ff 4f       	sbci	r31, 0xFF	; 255
     f6e:	62 81       	ldd	r22, Z+2	; 0x02
     f70:	6f 0d       	add	r22, r15
     f72:	ae 01       	movw	r20, r28
     f74:	4f 5f       	subi	r20, 0xFF	; 255
     f76:	5f 4f       	sbci	r21, 0xFF	; 255
     f78:	81 81       	ldd	r24, Z+1	; 0x01
     f7a:	0e 94 09 0a 	call	0x1412	; 0x1412 <DIO_ReadPin>
            /* check if row is pressed */
            if(u8_KeyState == PRESSED)
     f7e:	89 81       	ldd	r24, Y+1	; 0x01
     f80:	81 11       	cpse	r24, r1
     f82:	24 c0       	rjmp	.+72     	; 0xfcc <KP_GetPressedValue+0xde>
            {
               /* Check for multipressed buttons. */
               if(u32_NewState > 0)
     f84:	81 14       	cp	r8, r1
     f86:	91 04       	cpc	r9, r1
     f88:	a1 04       	cpc	r10, r1
     f8a:	b1 04       	cpc	r11, r1
     f8c:	11 f0       	breq	.+4      	; 0xf92 <KP_GetPressedValue+0xa4>
               {
                  u32_NewState |= 1;
     f8e:	68 94       	set
     f90:	80 f8       	bld	r8, 0
               }
               switch(KP_CH)
     f92:	e1 10       	cpse	r14, r1
     f94:	1b c0       	rjmp	.+54     	; 0xfcc <KP_GetPressedValue+0xde>
               {
                  #ifdef KP_CH_0
                  case KP_CH_0:
                     u32_NewState |= (1<<KP_Ch0Map[u8_RowCounter][u8_ColCounter]);
     f96:	8f 2d       	mov	r24, r15
     f98:	90 e0       	ldi	r25, 0x00	; 0
     f9a:	fc 01       	movw	r30, r24
     f9c:	ee 0f       	add	r30, r30
     f9e:	ff 1f       	adc	r31, r31
     fa0:	e8 0f       	add	r30, r24
     fa2:	f9 1f       	adc	r31, r25
     fa4:	e3 53       	subi	r30, 0x33	; 51
     fa6:	ff 4f       	sbci	r31, 0xFF	; 255
     fa8:	e6 0d       	add	r30, r6
     faa:	f1 1d       	adc	r31, r1
     fac:	81 e0       	ldi	r24, 0x01	; 1
     fae:	90 e0       	ldi	r25, 0x00	; 0
     fb0:	00 80       	ld	r0, Z
     fb2:	02 c0       	rjmp	.+4      	; 0xfb8 <KP_GetPressedValue+0xca>
     fb4:	88 0f       	add	r24, r24
     fb6:	99 1f       	adc	r25, r25
     fb8:	0a 94       	dec	r0
     fba:	e2 f7       	brpl	.-8      	; 0xfb4 <KP_GetPressedValue+0xc6>
     fbc:	09 2e       	mov	r0, r25
     fbe:	00 0c       	add	r0, r0
     fc0:	aa 0b       	sbc	r26, r26
     fc2:	bb 0b       	sbc	r27, r27
     fc4:	88 2a       	or	r8, r24
     fc6:	99 2a       	or	r9, r25
     fc8:	aa 2a       	or	r10, r26
     fca:	bb 2a       	or	r11, r27
         /* set column direction to output and value to low */
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter) , PIN_OUTPUT);
         DIO_WritePin(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter), PIN_LOW);
         
         /* loops on every row */
         for(uint8_t u8_RowCounter = 0; u8_RowCounter < aSTR_KPConfig[KP_CH].u8_KPRows; u8_RowCounter++)
     fcc:	f3 94       	inc	r15
     fce:	f8 01       	movw	r30, r16
     fd0:	ee 0f       	add	r30, r30
     fd2:	ff 1f       	adc	r31, r31
     fd4:	e0 0f       	add	r30, r16
     fd6:	f1 1f       	adc	r31, r17
     fd8:	ee 0f       	add	r30, r30
     fda:	ff 1f       	adc	r31, r31
     fdc:	e7 52       	subi	r30, 0x27	; 39
     fde:	ff 4f       	sbci	r31, 0xFF	; 255
     fe0:	80 81       	ld	r24, Z
     fe2:	f8 16       	cp	r15, r24
     fe4:	08 f4       	brcc	.+2      	; 0xfe8 <KP_GetPressedValue+0xfa>
     fe6:	ba cf       	rjmp	.-140    	; 0xf5c <KP_GetPressedValue+0x6e>
               }
            }
         }
         
         /* return column direction to input and resistor to pulled up. */
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter) , PIN_INPUT);
     fe8:	40 e0       	ldi	r20, 0x00	; 0
     fea:	67 2d       	mov	r22, r7
     fec:	85 2d       	mov	r24, r5
     fee:	0e 94 37 09 	call	0x126e	; 0x126e <DIO_SetPinDirection>
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter));
     ff2:	67 2d       	mov	r22, r7
     ff4:	85 2d       	mov	r24, r5
     ff6:	0e 94 4c 0a 	call	0x1498	; 0x1498 <DIO_EnablePinPullup>
   {
      uint32_t u32_NewState = 0x00;
      uint8_t u8_KeyState;
      
      /* loops on every column */
      for(uint8_t u8_ColCounter = 0; u8_ColCounter < aSTR_KPConfig[KP_CH].u8_KPCols; u8_ColCounter++)
     ffa:	63 94       	inc	r6
     ffc:	0e 2d       	mov	r16, r14
     ffe:	10 e0       	ldi	r17, 0x00	; 0
    1000:	f8 01       	movw	r30, r16
    1002:	ee 0f       	add	r30, r30
    1004:	ff 1f       	adc	r31, r31
    1006:	e0 0f       	add	r30, r16
    1008:	f1 1f       	adc	r31, r17
    100a:	ee 0f       	add	r30, r30
    100c:	ff 1f       	adc	r31, r31
    100e:	e7 52       	subi	r30, 0x27	; 39
    1010:	ff 4f       	sbci	r31, 0xFF	; 255
    1012:	83 81       	ldd	r24, Z+3	; 0x03
    1014:	68 16       	cp	r6, r24
    1016:	08 f4       	brcc	.+2      	; 0x101a <KP_GetPressedValue+0x12c>
    1018:	89 cf       	rjmp	.-238    	; 0xf2c <KP_GetPressedValue+0x3e>
         DIO_SetPinDirection(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter) , PIN_INPUT);
         DIO_EnablePinPullup(aSTR_KPConfig[KP_CH].u8_KPColPort, (aSTR_KPConfig[KP_CH].u8_KPColPinStart + u8_ColCounter));
      }
      
      /* Return the keys data. */
      *Data = u32_NewState;
    101a:	f6 01       	movw	r30, r12
    101c:	80 82       	st	Z, r8
    101e:	91 82       	std	Z+1, r9	; 0x01
    1020:	a2 82       	std	Z+2, r10	; 0x02
    1022:	b3 82       	std	Z+3, r11	; 0x03
      KP_ErrorState = ERROR_OK;
    1024:	80 e0       	ldi	r24, 0x00	; 0
    1026:	03 c0       	rjmp	.+6      	; 0x102e <KP_GetPressedValue+0x140>
      
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Data)
   {
      /* Set null pointer error. */
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_NULL_PTR);
    1028:	81 ee       	ldi	r24, 0xE1	; 225
    102a:	01 c0       	rjmp	.+2      	; 0x102e <KP_GetPressedValue+0x140>
   }
   else if(KP_INVALID_CH <= KP_CH)
   {
      /* Set invalid channel error. */
      KP_ErrorState = (E_KEYPAD_ID | E_KEYPAD_INVALID_CH);
    102c:	82 ee       	ldi	r24, 0xE2	; 226
      
   }
   
   /* return Error state. */
   return KP_ErrorState;
    102e:	0f 90       	pop	r0
    1030:	df 91       	pop	r29
    1032:	cf 91       	pop	r28
    1034:	1f 91       	pop	r17
    1036:	0f 91       	pop	r16
    1038:	ff 90       	pop	r15
    103a:	ef 90       	pop	r14
    103c:	df 90       	pop	r13
    103e:	cf 90       	pop	r12
    1040:	bf 90       	pop	r11
    1042:	af 90       	pop	r10
    1044:	9f 90       	pop	r9
    1046:	8f 90       	pop	r8
    1048:	7f 90       	pop	r7
    104a:	6f 90       	pop	r6
    104c:	5f 90       	pop	r5
    104e:	08 95       	ret

00001050 <LED_Init>:
* @param [in]  LED_ch   -  LED channel number.
*
* @return function error state.
*/
extern ERROR_STATE_t LED_Init(uint8_t LED_ch)
{
    1050:	ef 92       	push	r14
    1052:	ff 92       	push	r15
    1054:	0f 93       	push	r16
    1056:	1f 93       	push	r17
    1058:	cf 93       	push	r28
    105a:	df 93       	push	r29
   /* Variable to store function error state. */
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    105c:	81 11       	cpse	r24, r1
    105e:	4e c0       	rjmp	.+156    	; 0x10fc <LED_Init+0xac>
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function was called before */
   else if(INIT == gu8_IsLEDInit[LED_ch])
    1060:	c8 2f       	mov	r28, r24
    1062:	d0 e0       	ldi	r29, 0x00	; 0
    1064:	fe 01       	movw	r30, r28
    1066:	e3 5d       	subi	r30, 0xD3	; 211
    1068:	f8 4f       	sbci	r31, 0xF8	; 248
    106a:	80 81       	ld	r24, Z
    106c:	81 30       	cpi	r24, 0x01	; 1
    106e:	09 f4       	brne	.+2      	; 0x1072 <LED_Init+0x22>
    1070:	47 c0       	rjmp	.+142    	; 0x1100 <LED_Init+0xb0>
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INIT_BEFORE);
   }
   else
   {
      /* Normal LED Config */
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    1072:	fe 01       	movw	r30, r28
    1074:	ee 0f       	add	r30, r30
    1076:	ff 1f       	adc	r31, r31
    1078:	ee 0f       	add	r30, r30
    107a:	ff 1f       	adc	r31, r31
    107c:	e1 52       	subi	r30, 0x21	; 33
    107e:	ff 4f       	sbci	r31, 0xFF	; 255
    1080:	82 81       	ldd	r24, Z+2	; 0x02
    1082:	81 11       	cpse	r24, r1
    1084:	14 c0       	rjmp	.+40     	; 0x10ae <LED_Init+0x5e>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* configure LED pin */
         DIO_ErrorState = DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
    1086:	fe 01       	movw	r30, r28
    1088:	ee 0f       	add	r30, r30
    108a:	ff 1f       	adc	r31, r31
    108c:	ee 0f       	add	r30, r30
    108e:	ff 1f       	adc	r31, r31
    1090:	e1 52       	subi	r30, 0x21	; 33
    1092:	ff 4f       	sbci	r31, 0xFF	; 255
    1094:	61 81       	ldd	r22, Z+1	; 0x01
    1096:	41 e0       	ldi	r20, 0x01	; 1
    1098:	80 81       	ld	r24, Z
    109a:	0e 94 37 09 	call	0x126e	; 0x126e <DIO_SetPinDirection>
         /* make sure pin configuration is successful */
         if(ERROR_OK != DIO_ErrorState)
    109e:	81 11       	cpse	r24, r1
    10a0:	31 c0       	rjmp	.+98     	; 0x1104 <LED_Init+0xb4>
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            /* Set Channel to INIT */
            gu8_IsLEDInit[LED_ch] = INIT;
    10a2:	c3 5d       	subi	r28, 0xD3	; 211
    10a4:	d8 4f       	sbci	r29, 0xF8	; 248
    10a6:	81 e0       	ldi	r24, 0x01	; 1
    10a8:	88 83       	st	Y, r24
            LED_ErrorState = ERROR_OK;
    10aa:	80 e0       	ldi	r24, 0x00	; 0
    10ac:	30 c0       	rjmp	.+96     	; 0x110e <LED_Init+0xbe>
         }
      }
      /* PWM LED Config */
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
    10ae:	81 30       	cpi	r24, 0x01	; 1
    10b0:	59 f5       	brne	.+86     	; 0x1108 <LED_Init+0xb8>
      {
         ERROR_STATE_t ErrorState;
         
         /* configure LED pin */
         ErrorState = PWM_Init(gSTR_LEDConfig[LED_ch].u8_PWMCh);
    10b2:	ce 01       	movw	r24, r28
    10b4:	88 0f       	add	r24, r24
    10b6:	99 1f       	adc	r25, r25
    10b8:	88 0f       	add	r24, r24
    10ba:	99 1f       	adc	r25, r25
    10bc:	9c 01       	movw	r18, r24
    10be:	21 52       	subi	r18, 0x21	; 33
    10c0:	3f 4f       	sbci	r19, 0xFF	; 255
    10c2:	79 01       	movw	r14, r18
    10c4:	f9 01       	movw	r30, r18
    10c6:	03 81       	ldd	r16, Z+3	; 0x03
    10c8:	80 2f       	mov	r24, r16
    10ca:	0e 94 8a 0a 	call	0x1514	; 0x1514 <PWM_Init>
    10ce:	18 2f       	mov	r17, r24
         ErrorState |= DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
    10d0:	41 e0       	ldi	r20, 0x01	; 1
    10d2:	f7 01       	movw	r30, r14
    10d4:	61 81       	ldd	r22, Z+1	; 0x01
    10d6:	80 81       	ld	r24, Z
    10d8:	0e 94 37 09 	call	0x126e	; 0x126e <DIO_SetPinDirection>
    10dc:	18 2b       	or	r17, r24
         /*START THE PWM WAVE*/
         ErrorState |= PWM_Start(gSTR_LEDConfig[LED_ch].u8_PWMCh);
    10de:	80 2f       	mov	r24, r16
    10e0:	0e 94 bb 0a 	call	0x1576	; 0x1576 <PWM_Start>
    10e4:	18 2b       	or	r17, r24
         ErrorState |= PWM_Connect(gSTR_LEDConfig[LED_ch].u8_PWMCh);
    10e6:	80 2f       	mov	r24, r16
    10e8:	0e 94 c7 0a 	call	0x158e	; 0x158e <PWM_Connect>
    10ec:	81 2b       	or	r24, r17
         /* make sure pin configuration is successful */
         if(ERROR_OK != ErrorState)
    10ee:	71 f4       	brne	.+28     	; 0x110c <LED_Init+0xbc>
            LED_ErrorState = ERROR_NOK;
         }  
         else
         {
            /* Set Channel to INIT */
            gu8_IsLEDInit[LED_ch] = INIT;
    10f0:	c3 5d       	subi	r28, 0xD3	; 211
    10f2:	d8 4f       	sbci	r29, 0xF8	; 248
    10f4:	81 e0       	ldi	r24, 0x01	; 1
    10f6:	88 83       	st	Y, r24
            LED_ErrorState = ERROR_OK;
    10f8:	80 e0       	ldi	r24, 0x00	; 0
    10fa:	09 c0       	rjmp	.+18     	; 0x110e <LED_Init+0xbe>
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    10fc:	81 ec       	ldi	r24, 0xC1	; 193
    10fe:	07 c0       	rjmp	.+14     	; 0x110e <LED_Init+0xbe>
   }
   /* check if init function was called before */
   else if(INIT == gu8_IsLEDInit[LED_ch])
   {
      /* Set init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INIT_BEFORE);
    1100:	82 ec       	ldi	r24, 0xC2	; 194
    1102:	05 c0       	rjmp	.+10     	; 0x110e <LED_Init+0xbe>
         /* configure LED pin */
         DIO_ErrorState = DIO_SetPinDirection(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_OUTPUT);
         /* make sure pin configuration is successful */
         if(ERROR_OK != DIO_ErrorState)
         {
            LED_ErrorState = ERROR_NOK;
    1104:	81 e0       	ldi	r24, 0x01	; 1
    1106:	03 c0       	rjmp	.+6      	; 0x110e <LED_Init+0xbe>
            LED_ErrorState = ERROR_OK;
         }          
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
    1108:	81 e0       	ldi	r24, 0x01	; 1
    110a:	01 c0       	rjmp	.+2      	; 0x110e <LED_Init+0xbe>
         ErrorState |= PWM_Start(gSTR_LEDConfig[LED_ch].u8_PWMCh);
         ErrorState |= PWM_Connect(gSTR_LEDConfig[LED_ch].u8_PWMCh);
         /* make sure pin configuration is successful */
         if(ERROR_OK != ErrorState)
         {
            LED_ErrorState = ERROR_NOK;
    110c:	81 e0       	ldi	r24, 0x01	; 1
      }   
   }
   
   /* return Error state. */
   return LED_ErrorState;
}
    110e:	df 91       	pop	r29
    1110:	cf 91       	pop	r28
    1112:	1f 91       	pop	r17
    1114:	0f 91       	pop	r16
    1116:	ff 90       	pop	r15
    1118:	ef 90       	pop	r14
    111a:	08 95       	ret

0000111c <LED_Off>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    111c:	81 11       	cpse	r24, r1
    111e:	32 c0       	rjmp	.+100    	; 0x1184 <LED_Off+0x68>
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
    1120:	90 e0       	ldi	r25, 0x00	; 0
    1122:	fc 01       	movw	r30, r24
    1124:	e3 5d       	subi	r30, 0xD3	; 211
    1126:	f8 4f       	sbci	r31, 0xF8	; 248
    1128:	20 81       	ld	r18, Z
    112a:	21 30       	cpi	r18, 0x01	; 1
    112c:	69 f5       	brne	.+90     	; 0x1188 <LED_Off+0x6c>
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   else
   {
      /* Normal LED */
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    112e:	fc 01       	movw	r30, r24
    1130:	ee 0f       	add	r30, r30
    1132:	ff 1f       	adc	r31, r31
    1134:	ee 0f       	add	r30, r30
    1136:	ff 1f       	adc	r31, r31
    1138:	e1 52       	subi	r30, 0x21	; 33
    113a:	ff 4f       	sbci	r31, 0xFF	; 255
    113c:	22 81       	ldd	r18, Z+2	; 0x02
    113e:	21 11       	cpse	r18, r1
    1140:	10 c0       	rjmp	.+32     	; 0x1162 <LED_Off+0x46>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* set LED pin to low */
         DIO_ErrorState = DIO_WritePin(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_LOW);
    1142:	88 0f       	add	r24, r24
    1144:	99 1f       	adc	r25, r25
    1146:	88 0f       	add	r24, r24
    1148:	99 1f       	adc	r25, r25
    114a:	fc 01       	movw	r30, r24
    114c:	e1 52       	subi	r30, 0x21	; 33
    114e:	ff 4f       	sbci	r31, 0xFF	; 255
    1150:	61 81       	ldd	r22, Z+1	; 0x01
    1152:	40 e0       	ldi	r20, 0x00	; 0
    1154:	80 81       	ld	r24, Z
    1156:	0e 94 a0 09 	call	0x1340	; 0x1340 <DIO_WritePin>
         
         /* make sure DIO function was successful */
         if(ERROR_OK != DIO_ErrorState)
    115a:	88 23       	and	r24, r24
    115c:	b9 f0       	breq	.+46     	; 0x118c <LED_Off+0x70>
         {
            LED_ErrorState = ERROR_NOK;
    115e:	81 e0       	ldi	r24, 0x01	; 1
    1160:	08 95       	ret
         {
            LED_ErrorState = ERROR_OK;
         }
      }
      /* PWM LED */
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
    1162:	21 30       	cpi	r18, 0x01	; 1
    1164:	a9 f4       	brne	.+42     	; 0x1190 <LED_Off+0x74>
      {
         ERROR_STATE_t PWM_ErrorState;
         
         /* set LED duty cycle to Minimum */
         PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, MIN_DUTY);
    1166:	88 0f       	add	r24, r24
    1168:	99 1f       	adc	r25, r25
    116a:	88 0f       	add	r24, r24
    116c:	99 1f       	adc	r25, r25
    116e:	fc 01       	movw	r30, r24
    1170:	e1 52       	subi	r30, 0x21	; 33
    1172:	ff 4f       	sbci	r31, 0xFF	; 255
    1174:	60 e0       	ldi	r22, 0x00	; 0
    1176:	83 81       	ldd	r24, Z+3	; 0x03
    1178:	0e 94 d8 0a 	call	0x15b0	; 0x15b0 <PWM_SetDuty>
         
         /* make sure PWM function was successful */
         if(ERROR_OK != PWM_ErrorState)
    117c:	88 23       	and	r24, r24
    117e:	51 f0       	breq	.+20     	; 0x1194 <LED_Off+0x78>
         {
            LED_ErrorState = ERROR_NOK;
    1180:	81 e0       	ldi	r24, 0x01	; 1
    1182:	08 95       	ret
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    1184:	81 ec       	ldi	r24, 0xC1	; 193
    1186:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
    1188:	83 ec       	ldi	r24, 0xC3	; 195
    118a:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    118c:	80 e0       	ldi	r24, 0x00	; 0
    118e:	08 95       	ret
            LED_ErrorState = ERROR_OK;
         }
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
    1190:	81 e0       	ldi	r24, 0x01	; 1
    1192:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    1194:	80 e0       	ldi	r24, 0x00	; 0
      }
   }
   
   /* return Error state. */
   return LED_ErrorState;
}
    1196:	08 95       	ret

00001198 <LED_On>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    1198:	81 11       	cpse	r24, r1
    119a:	32 c0       	rjmp	.+100    	; 0x1200 <LED_On+0x68>
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
    119c:	90 e0       	ldi	r25, 0x00	; 0
    119e:	fc 01       	movw	r30, r24
    11a0:	e3 5d       	subi	r30, 0xD3	; 211
    11a2:	f8 4f       	sbci	r31, 0xF8	; 248
    11a4:	20 81       	ld	r18, Z
    11a6:	21 30       	cpi	r18, 0x01	; 1
    11a8:	69 f5       	brne	.+90     	; 0x1204 <LED_On+0x6c>
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   else
   {
      if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    11aa:	fc 01       	movw	r30, r24
    11ac:	ee 0f       	add	r30, r30
    11ae:	ff 1f       	adc	r31, r31
    11b0:	ee 0f       	add	r30, r30
    11b2:	ff 1f       	adc	r31, r31
    11b4:	e1 52       	subi	r30, 0x21	; 33
    11b6:	ff 4f       	sbci	r31, 0xFF	; 255
    11b8:	22 81       	ldd	r18, Z+2	; 0x02
    11ba:	21 11       	cpse	r18, r1
    11bc:	10 c0       	rjmp	.+32     	; 0x11de <LED_On+0x46>
      {
         ERROR_STATE_t DIO_ErrorState;
         
         /* set LED pin to high */
         DIO_ErrorState = DIO_WritePin(gSTR_LEDConfig[LED_ch].u8_LEDPort, gSTR_LEDConfig[LED_ch].u8_LEDPin, PIN_HIGH);
    11be:	88 0f       	add	r24, r24
    11c0:	99 1f       	adc	r25, r25
    11c2:	88 0f       	add	r24, r24
    11c4:	99 1f       	adc	r25, r25
    11c6:	fc 01       	movw	r30, r24
    11c8:	e1 52       	subi	r30, 0x21	; 33
    11ca:	ff 4f       	sbci	r31, 0xFF	; 255
    11cc:	61 81       	ldd	r22, Z+1	; 0x01
    11ce:	41 e0       	ldi	r20, 0x01	; 1
    11d0:	80 81       	ld	r24, Z
    11d2:	0e 94 a0 09 	call	0x1340	; 0x1340 <DIO_WritePin>
         
         /* make sure DIO function was successful */
         if(ERROR_OK != DIO_ErrorState)
    11d6:	88 23       	and	r24, r24
    11d8:	b9 f0       	breq	.+46     	; 0x1208 <LED_On+0x70>
         {
            LED_ErrorState = ERROR_NOK;
    11da:	81 e0       	ldi	r24, 0x01	; 1
    11dc:	08 95       	ret
         else
         {
            LED_ErrorState = ERROR_OK;
         }
      }
      else if(PWM_ON == gSTR_LEDConfig[LED_ch].u8_PWM)
    11de:	21 30       	cpi	r18, 0x01	; 1
    11e0:	a9 f4       	brne	.+42     	; 0x120c <LED_On+0x74>
      {
         ERROR_STATE_t PWM_ErrorState;
         
         /* set LED duty cycle to maximum */
         PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, MAX_DUTY);
    11e2:	88 0f       	add	r24, r24
    11e4:	99 1f       	adc	r25, r25
    11e6:	88 0f       	add	r24, r24
    11e8:	99 1f       	adc	r25, r25
    11ea:	fc 01       	movw	r30, r24
    11ec:	e1 52       	subi	r30, 0x21	; 33
    11ee:	ff 4f       	sbci	r31, 0xFF	; 255
    11f0:	64 e6       	ldi	r22, 0x64	; 100
    11f2:	83 81       	ldd	r24, Z+3	; 0x03
    11f4:	0e 94 d8 0a 	call	0x15b0	; 0x15b0 <PWM_SetDuty>
         
         /* make sure PWM function was successful */
         if(ERROR_OK != PWM_ErrorState)
    11f8:	88 23       	and	r24, r24
    11fa:	51 f0       	breq	.+20     	; 0x1210 <LED_On+0x78>
         {
            LED_ErrorState = ERROR_NOK;
    11fc:	81 e0       	ldi	r24, 0x01	; 1
    11fe:	08 95       	ret
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    1200:	81 ec       	ldi	r24, 0xC1	; 193
    1202:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
    1204:	83 ec       	ldi	r24, 0xC3	; 195
    1206:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    1208:	80 e0       	ldi	r24, 0x00	; 0
    120a:	08 95       	ret
            LED_ErrorState = ERROR_OK;
         }
      }
      else
      {
         LED_ErrorState = ERROR_NOK;
    120c:	81 e0       	ldi	r24, 0x01	; 1
    120e:	08 95       	ret
         {
            LED_ErrorState = ERROR_NOK;
         }
         else
         {
            LED_ErrorState = ERROR_OK;
    1210:	80 e0       	ldi	r24, 0x00	; 0
      }
   }
   
   /* return Error state. */
   return LED_ErrorState;
}
    1212:	08 95       	ret

00001214 <LED_Dim>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t LED_ErrorState;
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
    1214:	81 11       	cpse	r24, r1
    1216:	21 c0       	rjmp	.+66     	; 0x125a <LED_Dim+0x46>
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
    1218:	90 e0       	ldi	r25, 0x00	; 0
    121a:	fc 01       	movw	r30, r24
    121c:	e3 5d       	subi	r30, 0xD3	; 211
    121e:	f8 4f       	sbci	r31, 0xF8	; 248
    1220:	20 81       	ld	r18, Z
    1222:	21 30       	cpi	r18, 0x01	; 1
    1224:	e1 f4       	brne	.+56     	; 0x125e <LED_Dim+0x4a>
   {
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
   }
   /* check if channel is not pwm pin. */
   else if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
    1226:	fc 01       	movw	r30, r24
    1228:	ee 0f       	add	r30, r30
    122a:	ff 1f       	adc	r31, r31
    122c:	ee 0f       	add	r30, r30
    122e:	ff 1f       	adc	r31, r31
    1230:	e1 52       	subi	r30, 0x21	; 33
    1232:	ff 4f       	sbci	r31, 0xFF	; 255
    1234:	22 81       	ldd	r18, Z+2	; 0x02
    1236:	22 23       	and	r18, r18
    1238:	a1 f0       	breq	.+40     	; 0x1262 <LED_Dim+0x4e>
   {
      LED_ErrorState = ERROR_NOK;
   }
   /* check valid duty cycle. */
   else if(MAX_DUTY < Duty)
    123a:	65 36       	cpi	r22, 0x65	; 101
    123c:	a0 f4       	brcc	.+40     	; 0x1266 <LED_Dim+0x52>
   else
   {
      ERROR_STATE_t PWM_ErrorState;
         
      /* set LED duty cycle */
      PWM_ErrorState = PWM_SetDuty(gSTR_LEDConfig[LED_ch].u8_PWMCh, Duty);
    123e:	88 0f       	add	r24, r24
    1240:	99 1f       	adc	r25, r25
    1242:	88 0f       	add	r24, r24
    1244:	99 1f       	adc	r25, r25
    1246:	fc 01       	movw	r30, r24
    1248:	e1 52       	subi	r30, 0x21	; 33
    124a:	ff 4f       	sbci	r31, 0xFF	; 255
    124c:	83 81       	ldd	r24, Z+3	; 0x03
    124e:	0e 94 d8 0a 	call	0x15b0	; 0x15b0 <PWM_SetDuty>
        
      /* make sure PWM function was successful */ 
      if(ERROR_OK != PWM_ErrorState)
    1252:	88 23       	and	r24, r24
    1254:	51 f0       	breq	.+20     	; 0x126a <LED_Dim+0x56>
      {
         LED_ErrorState = ERROR_NOK;
    1256:	81 e0       	ldi	r24, 0x01	; 1
    1258:	08 95       	ret
   
   /* Check valid channel */
   if(LED_INVALID_CH <= LED_ch)
   {
      /* Set invalid channel error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_INVALID_CH_NO);
    125a:	81 ec       	ldi	r24, 0xC1	; 193
    125c:	08 95       	ret
   }
   /* check if init function wasn't called before */
   else if(INIT != gu8_IsLEDInit[LED_ch])
   {
      /* Set Not init before error. */
      LED_ErrorState = (E_LED_MODULE_ID | E_LED_NOT_INIT);
    125e:	83 ec       	ldi	r24, 0xC3	; 195
    1260:	08 95       	ret
   }
   /* check if channel is not pwm pin. */
   else if(PWM_OFF == gSTR_LEDConfig[LED_ch].u8_PWM)
   {
      LED_ErrorState = ERROR_NOK;
    1262:	81 e0       	ldi	r24, 0x01	; 1
    1264:	08 95       	ret
   }
   /* check valid duty cycle. */
   else if(MAX_DUTY < Duty)
   {
      LED_ErrorState = ERROR_NOK;
    1266:	81 e0       	ldi	r24, 0x01	; 1
    1268:	08 95       	ret
      {
         LED_ErrorState = ERROR_NOK;
      }
      else
      {
         LED_ErrorState = ERROR_OK;
    126a:	80 e0       	ldi	r24, 0x00	; 0
      }
   }
   
   /* return Error state. */
   return LED_ErrorState;
}
    126c:	08 95       	ret

0000126e <DIO_SetPinDirection>:
				u8_ErrorState=ERROR_NOK;
				break;	
		}	
	}	
	return u8_ErrorState;
}
    126e:	42 30       	cpi	r20, 0x02	; 2
    1270:	08 f0       	brcs	.+2      	; 0x1274 <DIO_SetPinDirection+0x6>
    1272:	60 c0       	rjmp	.+192    	; 0x1334 <DIO_SetPinDirection+0xc6>
    1274:	68 30       	cpi	r22, 0x08	; 8
    1276:	08 f0       	brcs	.+2      	; 0x127a <DIO_SetPinDirection+0xc>
    1278:	5f c0       	rjmp	.+190    	; 0x1338 <DIO_SetPinDirection+0xca>
    127a:	81 30       	cpi	r24, 0x01	; 1
    127c:	e1 f0       	breq	.+56     	; 0x12b6 <DIO_SetPinDirection+0x48>
    127e:	30 f0       	brcs	.+12     	; 0x128c <DIO_SetPinDirection+0x1e>
    1280:	82 30       	cpi	r24, 0x02	; 2
    1282:	71 f1       	breq	.+92     	; 0x12e0 <DIO_SetPinDirection+0x72>
    1284:	83 30       	cpi	r24, 0x03	; 3
    1286:	09 f4       	brne	.+2      	; 0x128a <DIO_SetPinDirection+0x1c>
    1288:	40 c0       	rjmp	.+128    	; 0x130a <DIO_SetPinDirection+0x9c>
    128a:	58 c0       	rjmp	.+176    	; 0x133c <DIO_SetPinDirection+0xce>
    128c:	2a b3       	in	r18, 0x1a	; 26
    128e:	81 e0       	ldi	r24, 0x01	; 1
    1290:	90 e0       	ldi	r25, 0x00	; 0
    1292:	06 2e       	mov	r0, r22
    1294:	02 c0       	rjmp	.+4      	; 0x129a <DIO_SetPinDirection+0x2c>
    1296:	88 0f       	add	r24, r24
    1298:	99 1f       	adc	r25, r25
    129a:	0a 94       	dec	r0
    129c:	e2 f7       	brpl	.-8      	; 0x1296 <DIO_SetPinDirection+0x28>
    129e:	50 e0       	ldi	r21, 0x00	; 0
    12a0:	02 c0       	rjmp	.+4      	; 0x12a6 <DIO_SetPinDirection+0x38>
    12a2:	44 0f       	add	r20, r20
    12a4:	55 1f       	adc	r21, r21
    12a6:	6a 95       	dec	r22
    12a8:	e2 f7       	brpl	.-8      	; 0x12a2 <DIO_SetPinDirection+0x34>
    12aa:	80 95       	com	r24
    12ac:	82 23       	and	r24, r18
    12ae:	48 2b       	or	r20, r24
    12b0:	4a bb       	out	0x1a, r20	; 26
    12b2:	80 e0       	ldi	r24, 0x00	; 0
    12b4:	08 95       	ret
    12b6:	27 b3       	in	r18, 0x17	; 23
    12b8:	81 e0       	ldi	r24, 0x01	; 1
    12ba:	90 e0       	ldi	r25, 0x00	; 0
    12bc:	06 2e       	mov	r0, r22
    12be:	02 c0       	rjmp	.+4      	; 0x12c4 <DIO_SetPinDirection+0x56>
    12c0:	88 0f       	add	r24, r24
    12c2:	99 1f       	adc	r25, r25
    12c4:	0a 94       	dec	r0
    12c6:	e2 f7       	brpl	.-8      	; 0x12c0 <DIO_SetPinDirection+0x52>
    12c8:	50 e0       	ldi	r21, 0x00	; 0
    12ca:	02 c0       	rjmp	.+4      	; 0x12d0 <DIO_SetPinDirection+0x62>
    12cc:	44 0f       	add	r20, r20
    12ce:	55 1f       	adc	r21, r21
    12d0:	6a 95       	dec	r22
    12d2:	e2 f7       	brpl	.-8      	; 0x12cc <DIO_SetPinDirection+0x5e>
    12d4:	80 95       	com	r24
    12d6:	82 23       	and	r24, r18
    12d8:	48 2b       	or	r20, r24
    12da:	47 bb       	out	0x17, r20	; 23
    12dc:	80 e0       	ldi	r24, 0x00	; 0
    12de:	08 95       	ret
    12e0:	24 b3       	in	r18, 0x14	; 20
    12e2:	81 e0       	ldi	r24, 0x01	; 1
    12e4:	90 e0       	ldi	r25, 0x00	; 0
    12e6:	06 2e       	mov	r0, r22
    12e8:	02 c0       	rjmp	.+4      	; 0x12ee <DIO_SetPinDirection+0x80>
    12ea:	88 0f       	add	r24, r24
    12ec:	99 1f       	adc	r25, r25
    12ee:	0a 94       	dec	r0
    12f0:	e2 f7       	brpl	.-8      	; 0x12ea <DIO_SetPinDirection+0x7c>
    12f2:	50 e0       	ldi	r21, 0x00	; 0
    12f4:	02 c0       	rjmp	.+4      	; 0x12fa <DIO_SetPinDirection+0x8c>
    12f6:	44 0f       	add	r20, r20
    12f8:	55 1f       	adc	r21, r21
    12fa:	6a 95       	dec	r22
    12fc:	e2 f7       	brpl	.-8      	; 0x12f6 <DIO_SetPinDirection+0x88>
    12fe:	80 95       	com	r24
    1300:	82 23       	and	r24, r18
    1302:	48 2b       	or	r20, r24
    1304:	44 bb       	out	0x14, r20	; 20
    1306:	80 e0       	ldi	r24, 0x00	; 0
    1308:	08 95       	ret
    130a:	21 b3       	in	r18, 0x11	; 17
    130c:	81 e0       	ldi	r24, 0x01	; 1
    130e:	90 e0       	ldi	r25, 0x00	; 0
    1310:	06 2e       	mov	r0, r22
    1312:	02 c0       	rjmp	.+4      	; 0x1318 <DIO_SetPinDirection+0xaa>
    1314:	88 0f       	add	r24, r24
    1316:	99 1f       	adc	r25, r25
    1318:	0a 94       	dec	r0
    131a:	e2 f7       	brpl	.-8      	; 0x1314 <DIO_SetPinDirection+0xa6>
    131c:	50 e0       	ldi	r21, 0x00	; 0
    131e:	02 c0       	rjmp	.+4      	; 0x1324 <DIO_SetPinDirection+0xb6>
    1320:	44 0f       	add	r20, r20
    1322:	55 1f       	adc	r21, r21
    1324:	6a 95       	dec	r22
    1326:	e2 f7       	brpl	.-8      	; 0x1320 <DIO_SetPinDirection+0xb2>
    1328:	80 95       	com	r24
    132a:	82 23       	and	r24, r18
    132c:	48 2b       	or	r20, r24
    132e:	41 bb       	out	0x11, r20	; 17
    1330:	80 e0       	ldi	r24, 0x00	; 0
    1332:	08 95       	ret
    1334:	81 e0       	ldi	r24, 0x01	; 1
    1336:	08 95       	ret
    1338:	81 e0       	ldi	r24, 0x01	; 1
    133a:	08 95       	ret
    133c:	81 e0       	ldi	r24, 0x01	; 1
    133e:	08 95       	ret

00001340 <DIO_WritePin>:
    1340:	42 30       	cpi	r20, 0x02	; 2
    1342:	08 f0       	brcs	.+2      	; 0x1346 <DIO_WritePin+0x6>
    1344:	60 c0       	rjmp	.+192    	; 0x1406 <DIO_WritePin+0xc6>
    1346:	68 30       	cpi	r22, 0x08	; 8
    1348:	08 f0       	brcs	.+2      	; 0x134c <DIO_WritePin+0xc>
    134a:	5f c0       	rjmp	.+190    	; 0x140a <DIO_WritePin+0xca>
    134c:	81 30       	cpi	r24, 0x01	; 1
    134e:	e1 f0       	breq	.+56     	; 0x1388 <DIO_WritePin+0x48>
    1350:	30 f0       	brcs	.+12     	; 0x135e <DIO_WritePin+0x1e>
    1352:	82 30       	cpi	r24, 0x02	; 2
    1354:	71 f1       	breq	.+92     	; 0x13b2 <DIO_WritePin+0x72>
    1356:	83 30       	cpi	r24, 0x03	; 3
    1358:	09 f4       	brne	.+2      	; 0x135c <DIO_WritePin+0x1c>
    135a:	40 c0       	rjmp	.+128    	; 0x13dc <DIO_WritePin+0x9c>
    135c:	58 c0       	rjmp	.+176    	; 0x140e <DIO_WritePin+0xce>
    135e:	2b b3       	in	r18, 0x1b	; 27
    1360:	81 e0       	ldi	r24, 0x01	; 1
    1362:	90 e0       	ldi	r25, 0x00	; 0
    1364:	06 2e       	mov	r0, r22
    1366:	02 c0       	rjmp	.+4      	; 0x136c <DIO_WritePin+0x2c>
    1368:	88 0f       	add	r24, r24
    136a:	99 1f       	adc	r25, r25
    136c:	0a 94       	dec	r0
    136e:	e2 f7       	brpl	.-8      	; 0x1368 <DIO_WritePin+0x28>
    1370:	50 e0       	ldi	r21, 0x00	; 0
    1372:	02 c0       	rjmp	.+4      	; 0x1378 <DIO_WritePin+0x38>
    1374:	44 0f       	add	r20, r20
    1376:	55 1f       	adc	r21, r21
    1378:	6a 95       	dec	r22
    137a:	e2 f7       	brpl	.-8      	; 0x1374 <DIO_WritePin+0x34>
    137c:	80 95       	com	r24
    137e:	82 23       	and	r24, r18
    1380:	48 2b       	or	r20, r24
    1382:	4b bb       	out	0x1b, r20	; 27
    1384:	80 e0       	ldi	r24, 0x00	; 0
    1386:	08 95       	ret
    1388:	28 b3       	in	r18, 0x18	; 24
    138a:	81 e0       	ldi	r24, 0x01	; 1
    138c:	90 e0       	ldi	r25, 0x00	; 0
    138e:	06 2e       	mov	r0, r22
    1390:	02 c0       	rjmp	.+4      	; 0x1396 <DIO_WritePin+0x56>
    1392:	88 0f       	add	r24, r24
    1394:	99 1f       	adc	r25, r25
    1396:	0a 94       	dec	r0
    1398:	e2 f7       	brpl	.-8      	; 0x1392 <DIO_WritePin+0x52>
    139a:	50 e0       	ldi	r21, 0x00	; 0
    139c:	02 c0       	rjmp	.+4      	; 0x13a2 <DIO_WritePin+0x62>
    139e:	44 0f       	add	r20, r20
    13a0:	55 1f       	adc	r21, r21
    13a2:	6a 95       	dec	r22
    13a4:	e2 f7       	brpl	.-8      	; 0x139e <DIO_WritePin+0x5e>
    13a6:	80 95       	com	r24
    13a8:	82 23       	and	r24, r18
    13aa:	48 2b       	or	r20, r24
    13ac:	48 bb       	out	0x18, r20	; 24
    13ae:	80 e0       	ldi	r24, 0x00	; 0
    13b0:	08 95       	ret
    13b2:	25 b3       	in	r18, 0x15	; 21
    13b4:	81 e0       	ldi	r24, 0x01	; 1
    13b6:	90 e0       	ldi	r25, 0x00	; 0
    13b8:	06 2e       	mov	r0, r22
    13ba:	02 c0       	rjmp	.+4      	; 0x13c0 <DIO_WritePin+0x80>
    13bc:	88 0f       	add	r24, r24
    13be:	99 1f       	adc	r25, r25
    13c0:	0a 94       	dec	r0
    13c2:	e2 f7       	brpl	.-8      	; 0x13bc <DIO_WritePin+0x7c>
    13c4:	50 e0       	ldi	r21, 0x00	; 0
    13c6:	02 c0       	rjmp	.+4      	; 0x13cc <DIO_WritePin+0x8c>
    13c8:	44 0f       	add	r20, r20
    13ca:	55 1f       	adc	r21, r21
    13cc:	6a 95       	dec	r22
    13ce:	e2 f7       	brpl	.-8      	; 0x13c8 <DIO_WritePin+0x88>
    13d0:	80 95       	com	r24
    13d2:	82 23       	and	r24, r18
    13d4:	48 2b       	or	r20, r24
    13d6:	45 bb       	out	0x15, r20	; 21
    13d8:	80 e0       	ldi	r24, 0x00	; 0
    13da:	08 95       	ret
    13dc:	22 b3       	in	r18, 0x12	; 18
    13de:	81 e0       	ldi	r24, 0x01	; 1
    13e0:	90 e0       	ldi	r25, 0x00	; 0
    13e2:	06 2e       	mov	r0, r22
    13e4:	02 c0       	rjmp	.+4      	; 0x13ea <DIO_WritePin+0xaa>
    13e6:	88 0f       	add	r24, r24
    13e8:	99 1f       	adc	r25, r25
    13ea:	0a 94       	dec	r0
    13ec:	e2 f7       	brpl	.-8      	; 0x13e6 <DIO_WritePin+0xa6>
    13ee:	50 e0       	ldi	r21, 0x00	; 0
    13f0:	02 c0       	rjmp	.+4      	; 0x13f6 <DIO_WritePin+0xb6>
    13f2:	44 0f       	add	r20, r20
    13f4:	55 1f       	adc	r21, r21
    13f6:	6a 95       	dec	r22
    13f8:	e2 f7       	brpl	.-8      	; 0x13f2 <DIO_WritePin+0xb2>
    13fa:	80 95       	com	r24
    13fc:	82 23       	and	r24, r18
    13fe:	48 2b       	or	r20, r24
    1400:	42 bb       	out	0x12, r20	; 18
    1402:	80 e0       	ldi	r24, 0x00	; 0
    1404:	08 95       	ret
    1406:	81 e0       	ldi	r24, 0x01	; 1
    1408:	08 95       	ret
    140a:	81 e0       	ldi	r24, 0x01	; 1
    140c:	08 95       	ret
    140e:	81 e0       	ldi	r24, 0x01	; 1
    1410:	08 95       	ret

00001412 <DIO_ReadPin>:
ERROR_STATE_t DIO_ReadPin(uint8_t PortName,uint8_t PinNo,ptr_uint8_t PinData)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PinNo>PIN7)
    1412:	68 30       	cpi	r22, 0x08	; 8
    1414:	d8 f5       	brcc	.+118    	; 0x148c <DIO_ReadPin+0x7a>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else if(NULL_PTR==PinData)
    1416:	41 15       	cp	r20, r1
    1418:	51 05       	cpc	r21, r1
    141a:	d1 f1       	breq	.+116    	; 0x1490 <DIO_ReadPin+0x7e>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{
		switch(PortName)
    141c:	81 30       	cpi	r24, 0x01	; 1
    141e:	91 f0       	breq	.+36     	; 0x1444 <DIO_ReadPin+0x32>
    1420:	28 f0       	brcs	.+10     	; 0x142c <DIO_ReadPin+0x1a>
    1422:	82 30       	cpi	r24, 0x02	; 2
    1424:	d9 f0       	breq	.+54     	; 0x145c <DIO_ReadPin+0x4a>
    1426:	83 30       	cpi	r24, 0x03	; 3
    1428:	29 f1       	breq	.+74     	; 0x1474 <DIO_ReadPin+0x62>
    142a:	34 c0       	rjmp	.+104    	; 0x1494 <DIO_ReadPin+0x82>
		{
			case PORT_A:
				* PinData=BIT_GET(PINA,PinNo);
    142c:	89 b3       	in	r24, 0x19	; 25
    142e:	90 e0       	ldi	r25, 0x00	; 0
    1430:	02 c0       	rjmp	.+4      	; 0x1436 <DIO_ReadPin+0x24>
    1432:	95 95       	asr	r25
    1434:	87 95       	ror	r24
    1436:	6a 95       	dec	r22
    1438:	e2 f7       	brpl	.-8      	; 0x1432 <DIO_ReadPin+0x20>
    143a:	81 70       	andi	r24, 0x01	; 1
    143c:	fa 01       	movw	r30, r20
    143e:	80 83       	st	Z, r24
				u8_ErrorState=ERROR_OK;
    1440:	80 e0       	ldi	r24, 0x00	; 0
				break;
    1442:	08 95       	ret
			case PORT_B:
				* PinData=BIT_GET(PINB,PinNo);
    1444:	86 b3       	in	r24, 0x16	; 22
    1446:	90 e0       	ldi	r25, 0x00	; 0
    1448:	02 c0       	rjmp	.+4      	; 0x144e <DIO_ReadPin+0x3c>
    144a:	95 95       	asr	r25
    144c:	87 95       	ror	r24
    144e:	6a 95       	dec	r22
    1450:	e2 f7       	brpl	.-8      	; 0x144a <DIO_ReadPin+0x38>
    1452:	81 70       	andi	r24, 0x01	; 1
    1454:	fa 01       	movw	r30, r20
    1456:	80 83       	st	Z, r24
				u8_ErrorState=ERROR_OK;
    1458:	80 e0       	ldi	r24, 0x00	; 0
				break;
    145a:	08 95       	ret
			case PORT_C:
				* PinData=BIT_GET(PINC,PinNo);
    145c:	83 b3       	in	r24, 0x13	; 19
    145e:	90 e0       	ldi	r25, 0x00	; 0
    1460:	02 c0       	rjmp	.+4      	; 0x1466 <DIO_ReadPin+0x54>
    1462:	95 95       	asr	r25
    1464:	87 95       	ror	r24
    1466:	6a 95       	dec	r22
    1468:	e2 f7       	brpl	.-8      	; 0x1462 <DIO_ReadPin+0x50>
    146a:	81 70       	andi	r24, 0x01	; 1
    146c:	fa 01       	movw	r30, r20
    146e:	80 83       	st	Z, r24
				u8_ErrorState=ERROR_OK;
    1470:	80 e0       	ldi	r24, 0x00	; 0
				break;
    1472:	08 95       	ret
			case PORT_D:
				* PinData=BIT_GET(PIND,PinNo);
    1474:	80 b3       	in	r24, 0x10	; 16
    1476:	90 e0       	ldi	r25, 0x00	; 0
    1478:	02 c0       	rjmp	.+4      	; 0x147e <DIO_ReadPin+0x6c>
    147a:	95 95       	asr	r25
    147c:	87 95       	ror	r24
    147e:	6a 95       	dec	r22
    1480:	e2 f7       	brpl	.-8      	; 0x147a <DIO_ReadPin+0x68>
    1482:	81 70       	andi	r24, 0x01	; 1
    1484:	fa 01       	movw	r30, r20
    1486:	80 83       	st	Z, r24
				u8_ErrorState=ERROR_OK;
    1488:	80 e0       	ldi	r24, 0x00	; 0
				break;
    148a:	08 95       	ret
ERROR_STATE_t DIO_ReadPin(uint8_t PortName,uint8_t PinNo,ptr_uint8_t PinData)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PinNo>PIN7)
	{
		u8_ErrorState=ERROR_NOK;
    148c:	81 e0       	ldi	r24, 0x01	; 1
    148e:	08 95       	ret
	}
	else if(NULL_PTR==PinData)
	{
		u8_ErrorState=ERROR_NOK;
    1490:	81 e0       	ldi	r24, 0x01	; 1
    1492:	08 95       	ret
			case PORT_D:
				* PinData=BIT_GET(PIND,PinNo);
				u8_ErrorState=ERROR_OK;
				break;
			default:
				u8_ErrorState=ERROR_NOK;
    1494:	81 e0       	ldi	r24, 0x01	; 1
				break;
		}
	}	
	return u8_ErrorState;
}
    1496:	08 95       	ret

00001498 <DIO_EnablePinPullup>:


ERROR_STATE_t DIO_EnablePinPullup(uint8_t PortName,uint8_t PinNo)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PinNo>PIN7)
    1498:	68 30       	cpi	r22, 0x08	; 8
    149a:	c0 f5       	brcc	.+112    	; 0x150c <DIO_EnablePinPullup+0x74>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{	
		switch(PortName)
    149c:	81 30       	cpi	r24, 0x01	; 1
    149e:	91 f0       	breq	.+36     	; 0x14c4 <DIO_EnablePinPullup+0x2c>
    14a0:	28 f0       	brcs	.+10     	; 0x14ac <DIO_EnablePinPullup+0x14>
    14a2:	82 30       	cpi	r24, 0x02	; 2
    14a4:	d9 f0       	breq	.+54     	; 0x14dc <DIO_EnablePinPullup+0x44>
    14a6:	83 30       	cpi	r24, 0x03	; 3
    14a8:	29 f1       	breq	.+74     	; 0x14f4 <DIO_EnablePinPullup+0x5c>
    14aa:	32 c0       	rjmp	.+100    	; 0x1510 <DIO_EnablePinPullup+0x78>
		{
			case PORT_A:
				BIT_WRITE(PORTA,PinNo,PIN_HIGH);
    14ac:	81 e0       	ldi	r24, 0x01	; 1
    14ae:	90 e0       	ldi	r25, 0x00	; 0
    14b0:	02 c0       	rjmp	.+4      	; 0x14b6 <DIO_EnablePinPullup+0x1e>
    14b2:	88 0f       	add	r24, r24
    14b4:	99 1f       	adc	r25, r25
    14b6:	6a 95       	dec	r22
    14b8:	e2 f7       	brpl	.-8      	; 0x14b2 <DIO_EnablePinPullup+0x1a>
    14ba:	9b b3       	in	r25, 0x1b	; 27
    14bc:	89 2b       	or	r24, r25
    14be:	8b bb       	out	0x1b, r24	; 27
				u8_ErrorState=ERROR_OK;
    14c0:	80 e0       	ldi	r24, 0x00	; 0
				break;
    14c2:	08 95       	ret
			case PORT_B:
				BIT_WRITE(PORTB,PinNo,PIN_HIGH);
    14c4:	81 e0       	ldi	r24, 0x01	; 1
    14c6:	90 e0       	ldi	r25, 0x00	; 0
    14c8:	02 c0       	rjmp	.+4      	; 0x14ce <DIO_EnablePinPullup+0x36>
    14ca:	88 0f       	add	r24, r24
    14cc:	99 1f       	adc	r25, r25
    14ce:	6a 95       	dec	r22
    14d0:	e2 f7       	brpl	.-8      	; 0x14ca <DIO_EnablePinPullup+0x32>
    14d2:	98 b3       	in	r25, 0x18	; 24
    14d4:	89 2b       	or	r24, r25
    14d6:	88 bb       	out	0x18, r24	; 24
				u8_ErrorState=ERROR_OK;
    14d8:	80 e0       	ldi	r24, 0x00	; 0
				break;                            
    14da:	08 95       	ret
			case PORT_C:                          
				BIT_WRITE(PORTC,PinNo,PIN_HIGH);
    14dc:	81 e0       	ldi	r24, 0x01	; 1
    14de:	90 e0       	ldi	r25, 0x00	; 0
    14e0:	02 c0       	rjmp	.+4      	; 0x14e6 <DIO_EnablePinPullup+0x4e>
    14e2:	88 0f       	add	r24, r24
    14e4:	99 1f       	adc	r25, r25
    14e6:	6a 95       	dec	r22
    14e8:	e2 f7       	brpl	.-8      	; 0x14e2 <DIO_EnablePinPullup+0x4a>
    14ea:	95 b3       	in	r25, 0x15	; 21
    14ec:	89 2b       	or	r24, r25
    14ee:	85 bb       	out	0x15, r24	; 21
				u8_ErrorState=ERROR_OK;
    14f0:	80 e0       	ldi	r24, 0x00	; 0
				break;                            
    14f2:	08 95       	ret
			case PORT_D:                          
				BIT_WRITE(PORTD,PinNo,PIN_HIGH);
    14f4:	81 e0       	ldi	r24, 0x01	; 1
    14f6:	90 e0       	ldi	r25, 0x00	; 0
    14f8:	02 c0       	rjmp	.+4      	; 0x14fe <DIO_EnablePinPullup+0x66>
    14fa:	88 0f       	add	r24, r24
    14fc:	99 1f       	adc	r25, r25
    14fe:	6a 95       	dec	r22
    1500:	e2 f7       	brpl	.-8      	; 0x14fa <DIO_EnablePinPullup+0x62>
    1502:	92 b3       	in	r25, 0x12	; 18
    1504:	89 2b       	or	r24, r25
    1506:	82 bb       	out	0x12, r24	; 18
				u8_ErrorState=ERROR_OK;
    1508:	80 e0       	ldi	r24, 0x00	; 0
				break;
    150a:	08 95       	ret
ERROR_STATE_t DIO_EnablePinPullup(uint8_t PortName,uint8_t PinNo)
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PinNo>PIN7)
	{
		u8_ErrorState=ERROR_NOK;
    150c:	81 e0       	ldi	r24, 0x01	; 1
    150e:	08 95       	ret
			case PORT_D:                          
				BIT_WRITE(PORTD,PinNo,PIN_HIGH);
				u8_ErrorState=ERROR_OK;
				break;
			default:
				u8_ErrorState=ERROR_NOK;
    1510:	81 e0       	ldi	r24, 0x01	; 1
				break;
		}	
	}	
	return u8_ErrorState;
    1512:	08 95       	ret

00001514 <PWM_Init>:
		default:
			u8_ErrorState=ERROR_NOK;
			break;			
	}
	return u8_ErrorState;
}
    1514:	83 30       	cpi	r24, 0x03	; 3
    1516:	69 f5       	brne	.+90     	; 0x1572 <PWM_Init+0x5e>
    1518:	85 b5       	in	r24, 0x25	; 37
    151a:	e2 e6       	ldi	r30, 0x62	; 98
    151c:	f0 e0       	ldi	r31, 0x00	; 0
    151e:	92 85       	ldd	r25, Z+10	; 0x0a
    1520:	49 2f       	mov	r20, r25
    1522:	41 70       	andi	r20, 0x01	; 1
    1524:	50 e0       	ldi	r21, 0x00	; 0
    1526:	00 24       	eor	r0, r0
    1528:	56 95       	lsr	r21
    152a:	47 95       	ror	r20
    152c:	07 94       	ror	r0
    152e:	56 95       	lsr	r21
    1530:	47 95       	ror	r20
    1532:	07 94       	ror	r0
    1534:	54 2f       	mov	r21, r20
    1536:	40 2d       	mov	r20, r0
    1538:	8f 7b       	andi	r24, 0xBF	; 191
    153a:	48 2b       	or	r20, r24
    153c:	91 fb       	bst	r25, 1
    153e:	22 27       	eor	r18, r18
    1540:	20 f9       	bld	r18, 0
    1542:	30 e0       	ldi	r19, 0x00	; 0
    1544:	22 0f       	add	r18, r18
    1546:	33 1f       	adc	r19, r19
    1548:	22 0f       	add	r18, r18
    154a:	33 1f       	adc	r19, r19
    154c:	22 0f       	add	r18, r18
    154e:	33 1f       	adc	r19, r19
    1550:	47 7f       	andi	r20, 0xF7	; 247
    1552:	24 2b       	or	r18, r20
    1554:	83 85       	ldd	r24, Z+11	; 0x0b
    1556:	30 e1       	ldi	r19, 0x10	; 16
    1558:	83 9f       	mul	r24, r19
    155a:	c0 01       	movw	r24, r0
    155c:	11 24       	eor	r1, r1
    155e:	2f 7c       	andi	r18, 0xCF	; 207
    1560:	28 2b       	or	r18, r24
    1562:	25 bd       	out	0x25, r18	; 37
    1564:	41 e0       	ldi	r20, 0x01	; 1
    1566:	67 e0       	ldi	r22, 0x07	; 7
    1568:	83 e0       	ldi	r24, 0x03	; 3
    156a:	0e 94 37 09 	call	0x126e	; 0x126e <DIO_SetPinDirection>
    156e:	80 e0       	ldi	r24, 0x00	; 0
    1570:	08 95       	ret
    1572:	81 e0       	ldi	r24, 0x01	; 1
    1574:	08 95       	ret

00001576 <PWM_Start>:
    1576:	83 30       	cpi	r24, 0x03	; 3
    1578:	41 f4       	brne	.+16     	; 0x158a <PWM_Start+0x14>
    157a:	85 b5       	in	r24, 0x25	; 37
    157c:	90 91 6b 00 	lds	r25, 0x006B	; 0x80006b <gastr_PWMConfig+0x9>
    1580:	88 7f       	andi	r24, 0xF8	; 248
    1582:	89 2b       	or	r24, r25
    1584:	85 bd       	out	0x25, r24	; 37
    1586:	80 e0       	ldi	r24, 0x00	; 0
    1588:	08 95       	ret
    158a:	81 e0       	ldi	r24, 0x01	; 1
    158c:	08 95       	ret

0000158e <PWM_Connect>:
    158e:	83 30       	cpi	r24, 0x03	; 3
    1590:	69 f4       	brne	.+26     	; 0x15ac <PWM_Connect+0x1e>
    1592:	25 b5       	in	r18, 0x25	; 37
    1594:	90 91 6d 00 	lds	r25, 0x006D	; 0x80006d <gastr_PWMConfig+0xb>
    1598:	30 e1       	ldi	r19, 0x10	; 16
    159a:	93 9f       	mul	r25, r19
    159c:	c0 01       	movw	r24, r0
    159e:	11 24       	eor	r1, r1
    15a0:	92 2f       	mov	r25, r18
    15a2:	9f 7c       	andi	r25, 0xCF	; 207
    15a4:	89 2b       	or	r24, r25
    15a6:	85 bd       	out	0x25, r24	; 37
    15a8:	80 e0       	ldi	r24, 0x00	; 0
    15aa:	08 95       	ret
    15ac:	81 e0       	ldi	r24, 0x01	; 1
    15ae:	08 95       	ret

000015b0 <PWM_SetDuty>:

ERROR_STATE_t PWM_SetDuty(uint8_t PwmChannelNumber,uint8_t PwmDuty )
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PwmDuty==0||PwmDuty>100)
    15b0:	9f ef       	ldi	r25, 0xFF	; 255
    15b2:	96 0f       	add	r25, r22
    15b4:	94 36       	cpi	r25, 0x64	; 100
    15b6:	10 f5       	brcc	.+68     	; 0x15fc <PWM_SetDuty+0x4c>
	{
		u8_ErrorState=ERROR_NOK;
	}
	else
	{
		switch(PwmChannelNumber)
    15b8:	83 30       	cpi	r24, 0x03	; 3
    15ba:	11 f5       	brne	.+68     	; 0x1600 <PWM_SetDuty+0x50>
					break;	
			#endif	
			
			#if OC2
				case PWM_CHANNEL_OC2:
					switch(gastr_PWMConfig[PWM_CHANNEL_OC2].PWMWaveformMode)
    15bc:	80 91 6d 00 	lds	r24, 0x006D	; 0x80006d <gastr_PWMConfig+0xb>
    15c0:	82 30       	cpi	r24, 0x02	; 2
    15c2:	01 f5       	brne	.+64     	; 0x1604 <PWM_SetDuty+0x54>
					{
						case NON_INVERTING:
							OCR2 = (uint8_t)(((PwmDuty/100.0)*256.0)-1);
    15c4:	70 e0       	ldi	r23, 0x00	; 0
    15c6:	80 e0       	ldi	r24, 0x00	; 0
    15c8:	90 e0       	ldi	r25, 0x00	; 0
    15ca:	0e 94 91 0d 	call	0x1b22	; 0x1b22 <__floatsisf>
    15ce:	20 e0       	ldi	r18, 0x00	; 0
    15d0:	30 e0       	ldi	r19, 0x00	; 0
    15d2:	48 ec       	ldi	r20, 0xC8	; 200
    15d4:	52 e4       	ldi	r21, 0x42	; 66
    15d6:	0e 94 ee 0c 	call	0x19dc	; 0x19dc <__divsf3>
    15da:	20 e0       	ldi	r18, 0x00	; 0
    15dc:	30 e0       	ldi	r19, 0x00	; 0
    15de:	40 e8       	ldi	r20, 0x80	; 128
    15e0:	53 e4       	ldi	r21, 0x43	; 67
    15e2:	0e 94 1d 0e 	call	0x1c3a	; 0x1c3a <__mulsf3>
    15e6:	20 e0       	ldi	r18, 0x00	; 0
    15e8:	30 e0       	ldi	r19, 0x00	; 0
    15ea:	40 e8       	ldi	r20, 0x80	; 128
    15ec:	5f e3       	ldi	r21, 0x3F	; 63
    15ee:	0e 94 81 0c 	call	0x1902	; 0x1902 <__subsf3>
    15f2:	0e 94 60 0d 	call	0x1ac0	; 0x1ac0 <__fixunssfsi>
    15f6:	63 bd       	out	0x23, r22	; 35
							u8_ErrorState=ERROR_OK;
    15f8:	80 e0       	ldi	r24, 0x00	; 0
							break;
    15fa:	08 95       	ret
ERROR_STATE_t PWM_SetDuty(uint8_t PwmChannelNumber,uint8_t PwmDuty )
{
	uint8_t u8_ErrorState=ERROR_OK;
	if(PwmDuty==0||PwmDuty>100)
	{
		u8_ErrorState=ERROR_NOK;
    15fc:	81 e0       	ldi	r24, 0x01	; 1
    15fe:	08 95       	ret
							break;
					}
					break;
			#endif	
			default:
				u8_ErrorState=ERROR_NOK;
    1600:	81 e0       	ldi	r24, 0x01	; 1
    1602:	08 95       	ret
						case NON_INVERTING:
							OCR2 = (uint8_t)(((PwmDuty/100.0)*256.0)-1);
							u8_ErrorState=ERROR_OK;
							break;
						default:
							u8_ErrorState=ERROR_NOK;
    1604:	81 e0       	ldi	r24, 0x01	; 1
				u8_ErrorState=ERROR_NOK;
				break;			
		}		
	}
	return u8_ErrorState;
    1606:	08 95       	ret

00001608 <HMI_MainFunction>:
* @brief: This function is the HMI main function.
*
* @return function error state.
*/
extern void HMI_MainFunction(void)
{
    1608:	0f 93       	push	r16
    160a:	1f 93       	push	r17
    160c:	cf 93       	push	r28
    160e:	df 93       	push	r29
    1610:	00 d0       	rcall	.+0      	; 0x1612 <HMI_MainFunction+0xa>
    1612:	00 d0       	rcall	.+0      	; 0x1614 <HMI_MainFunction+0xc>
    1614:	cd b7       	in	r28, 0x3d	; 61
    1616:	de b7       	in	r29, 0x3e	; 62
   uint32_t u32_Key;
   static uint32_t u32_OldKey = 0;
   static uint32_t u32_LastSetKey = 0;
   
   /* Initialization sequence. */
   if (u8_Init == 0)
    1618:	80 91 36 07 	lds	r24, 0x0736	; 0x800736 <u8_Init.1658>
    161c:	81 11       	cpse	r24, r1
    161e:	07 c0       	rjmp	.+14     	; 0x162e <HMI_MainFunction+0x26>
   {
      KP_Init(KP_UsedChannel);
    1620:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <KP_UsedChannel>
    1624:	0e 94 1b 07 	call	0xe36	; 0xe36 <KP_Init>
      u8_Init = 1;
    1628:	81 e0       	ldi	r24, 0x01	; 1
    162a:	80 93 36 07 	sts	0x0736, r24	; 0x800736 <u8_Init.1658>
   }
   
   /* Get KEypad pressed keys. */
   KP_GetPressedValue(KP_UsedChannel, &u32_Key);
    162e:	be 01       	movw	r22, r28
    1630:	6f 5f       	subi	r22, 0xFF	; 255
    1632:	7f 4f       	sbci	r23, 0xFF	; 255
    1634:	80 91 73 00 	lds	r24, 0x0073	; 0x800073 <KP_UsedChannel>
    1638:	0e 94 77 07 	call	0xeee	; 0xeee <KP_GetPressedValue>
   
   if(u32_OldKey == u32_Key && u32_LastSetKey != u32_Key)
    163c:	80 91 32 07 	lds	r24, 0x0732	; 0x800732 <u32_OldKey.1660>
    1640:	90 91 33 07 	lds	r25, 0x0733	; 0x800733 <u32_OldKey.1660+0x1>
    1644:	a0 91 34 07 	lds	r26, 0x0734	; 0x800734 <u32_OldKey.1660+0x2>
    1648:	b0 91 35 07 	lds	r27, 0x0735	; 0x800735 <u32_OldKey.1660+0x3>
    164c:	49 81       	ldd	r20, Y+1	; 0x01
    164e:	5a 81       	ldd	r21, Y+2	; 0x02
    1650:	6b 81       	ldd	r22, Y+3	; 0x03
    1652:	7c 81       	ldd	r23, Y+4	; 0x04
    1654:	84 17       	cp	r24, r20
    1656:	95 07       	cpc	r25, r21
    1658:	a6 07       	cpc	r26, r22
    165a:	b7 07       	cpc	r27, r23
    165c:	09 f0       	breq	.+2      	; 0x1660 <HMI_MainFunction+0x58>
    165e:	42 c0       	rjmp	.+132    	; 0x16e4 <HMI_MainFunction+0xdc>
    1660:	80 91 2e 07 	lds	r24, 0x072E	; 0x80072e <u32_LastSetKey.1661>
    1664:	90 91 2f 07 	lds	r25, 0x072F	; 0x80072f <u32_LastSetKey.1661+0x1>
    1668:	a0 91 30 07 	lds	r26, 0x0730	; 0x800730 <u32_LastSetKey.1661+0x2>
    166c:	b0 91 31 07 	lds	r27, 0x0731	; 0x800731 <u32_LastSetKey.1661+0x3>
    1670:	48 17       	cp	r20, r24
    1672:	59 07       	cpc	r21, r25
    1674:	6a 07       	cpc	r22, r26
    1676:	7b 07       	cpc	r23, r27
    1678:	a9 f1       	breq	.+106    	; 0x16e4 <HMI_MainFunction+0xdc>
   {
      u32_LastSetKey = u32_Key;
    167a:	40 93 2e 07 	sts	0x072E, r20	; 0x80072e <u32_LastSetKey.1661>
    167e:	50 93 2f 07 	sts	0x072F, r21	; 0x80072f <u32_LastSetKey.1661+0x1>
    1682:	60 93 30 07 	sts	0x0730, r22	; 0x800730 <u32_LastSetKey.1661+0x2>
    1686:	70 93 31 07 	sts	0x0731, r23	; 0x800731 <u32_LastSetKey.1661+0x3>
      /* If multi buttons are pressed. */
      if(MULTI_PRESS_BIT & u32_Key)
    168a:	40 ff       	sbrs	r20, 0
    168c:	11 c0       	rjmp	.+34     	; 0x16b0 <HMI_MainFunction+0xa8>
      {
         /* Device erase pattern keys are pressed */
         if(DEVICE_ERASE_VALUE == u32_Key)
    168e:	43 34       	cpi	r20, 0x43	; 67
    1690:	80 e1       	ldi	r24, 0x10	; 16
    1692:	58 07       	cpc	r21, r24
    1694:	61 05       	cpc	r22, r1
    1696:	71 05       	cpc	r23, r1
    1698:	19 f4       	brne	.+6      	; 0x16a0 <HMI_MainFunction+0x98>
         {
            /* Set device erase flag. */
            HMI_SetDeviceEraseFlag();
    169a:	0e 94 87 0b 	call	0x170e	; 0x170e <HMI_SetDeviceEraseFlag>
    169e:	22 c0       	rjmp	.+68     	; 0x16e4 <HMI_MainFunction+0xdc>
         }
         /* password change pattern keys are pressed */
         else if(PASSWORD_CHANGE_VALUE == u32_Key)
    16a0:	43 34       	cpi	r20, 0x43	; 67
    16a2:	54 40       	sbci	r21, 0x04	; 4
    16a4:	61 05       	cpc	r22, r1
    16a6:	71 05       	cpc	r23, r1
    16a8:	e9 f4       	brne	.+58     	; 0x16e4 <HMI_MainFunction+0xdc>
         {
            /* Set password change flag. */
            HMI_SetPasswordChangeFlag();
    16aa:	0e 94 8c 0b 	call	0x1718	; 0x1718 <HMI_SetPasswordChangeFlag>
    16ae:	1a c0       	rjmp	.+52     	; 0x16e4 <HMI_MainFunction+0xdc>
         else
         {
         }
      }
      /* If a single key is pressed. */
      else if(u32_Key != 0)
    16b0:	41 15       	cp	r20, r1
    16b2:	51 05       	cpc	r21, r1
    16b4:	61 05       	cpc	r22, r1
    16b6:	71 05       	cpc	r23, r1
    16b8:	91 f4       	brne	.+36     	; 0x16de <HMI_MainFunction+0xd6>
    16ba:	14 c0       	rjmp	.+40     	; 0x16e4 <HMI_MainFunction+0xdc>
      {
         /* Determine the single pressed key. */
         for(uint8_t u8_KeyCounter = 1; u8_KeyCounter<= 12; u8_KeyCounter++)
         {
            if((u32_Key >> u8_KeyCounter) & 1 )
    16bc:	8a 01       	movw	r16, r20
    16be:	9b 01       	movw	r18, r22
    16c0:	08 2e       	mov	r0, r24
    16c2:	04 c0       	rjmp	.+8      	; 0x16cc <HMI_MainFunction+0xc4>
    16c4:	36 95       	lsr	r19
    16c6:	27 95       	ror	r18
    16c8:	17 95       	ror	r17
    16ca:	07 95       	ror	r16
    16cc:	0a 94       	dec	r0
    16ce:	d2 f7       	brpl	.-12     	; 0x16c4 <HMI_MainFunction+0xbc>
    16d0:	00 ff       	sbrs	r16, 0
    16d2:	03 c0       	rjmp	.+6      	; 0x16da <HMI_MainFunction+0xd2>
            {
               HMI_SetKeyPressed(u8_KeyCounter);
    16d4:	0e 94 91 0b 	call	0x1722	; 0x1722 <HMI_SetKeyPressed>
               break;
    16d8:	05 c0       	rjmp	.+10     	; 0x16e4 <HMI_MainFunction+0xdc>
      }
      /* If a single key is pressed. */
      else if(u32_Key != 0)
      {
         /* Determine the single pressed key. */
         for(uint8_t u8_KeyCounter = 1; u8_KeyCounter<= 12; u8_KeyCounter++)
    16da:	8f 5f       	subi	r24, 0xFF	; 255
    16dc:	01 c0       	rjmp	.+2      	; 0x16e0 <HMI_MainFunction+0xd8>
    16de:	81 e0       	ldi	r24, 0x01	; 1
    16e0:	8d 30       	cpi	r24, 0x0D	; 13
    16e2:	60 f3       	brcs	.-40     	; 0x16bc <HMI_MainFunction+0xb4>
      }
      else
      {
      }
   }
   u32_OldKey = u32_Key;
    16e4:	89 81       	ldd	r24, Y+1	; 0x01
    16e6:	9a 81       	ldd	r25, Y+2	; 0x02
    16e8:	ab 81       	ldd	r26, Y+3	; 0x03
    16ea:	bc 81       	ldd	r27, Y+4	; 0x04
    16ec:	80 93 32 07 	sts	0x0732, r24	; 0x800732 <u32_OldKey.1660>
    16f0:	90 93 33 07 	sts	0x0733, r25	; 0x800733 <u32_OldKey.1660+0x1>
    16f4:	a0 93 34 07 	sts	0x0734, r26	; 0x800734 <u32_OldKey.1660+0x2>
    16f8:	b0 93 35 07 	sts	0x0735, r27	; 0x800735 <u32_OldKey.1660+0x3>
      
    16fc:	0f 90       	pop	r0
    16fe:	0f 90       	pop	r0
    1700:	0f 90       	pop	r0
    1702:	0f 90       	pop	r0
    1704:	df 91       	pop	r29
    1706:	cf 91       	pop	r28
    1708:	1f 91       	pop	r17
    170a:	0f 91       	pop	r16
    170c:	08 95       	ret

0000170e <HMI_SetDeviceEraseFlag>:
* @return function error state.
*/
extern ERROR_STATE_t HMI_SetDeviceEraseFlag(void)
{
   /* Set the device erase flag. */
   gu8_DeviceEraseFlag = DEVICE_ERASE_FLAG;
    170e:	81 e0       	ldi	r24, 0x01	; 1
    1710:	80 93 39 07 	sts	0x0739, r24	; 0x800739 <gu8_DeviceEraseFlag>
   /* return Error state. */
   return ERROR_OK;
}
    1714:	80 e0       	ldi	r24, 0x00	; 0
    1716:	08 95       	ret

00001718 <HMI_SetPasswordChangeFlag>:
* @return function error state.
*/
extern ERROR_STATE_t HMI_SetPasswordChangeFlag(void)
{
   /* Set the password change flag. */
   gu8_PasswordChangeFlag = PASSWORD_CHANGE_FLAG;
    1718:	81 e0       	ldi	r24, 0x01	; 1
    171a:	80 93 38 07 	sts	0x0738, r24	; 0x800738 <gu8_PasswordChangeFlag>
   /* return Error state. */
   return ERROR_OK;
}
    171e:	80 e0       	ldi	r24, 0x00	; 0
    1720:	08 95       	ret

00001722 <HMI_SetKeyPressed>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t HMI_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(INVALID_KEY_PRESSED_VALUE <= Value)
    1722:	8d 30       	cpi	r24, 0x0D	; 13
    1724:	20 f4       	brcc	.+8      	; 0x172e <HMI_SetKeyPressed+0xc>
      HMI_ErrorState = (E_HMI_ID | E_HMI_INVALID_VAL);
   }
   else
   {
      /* Set the pressed key value. */
      gu8_KeyPressedValue = Value;
    1726:	80 93 37 07 	sts	0x0737, r24	; 0x800737 <gu8_KeyPressedValue>
      HMI_ErrorState = ERROR_OK;
    172a:	80 e0       	ldi	r24, 0x00	; 0
    172c:	08 95       	ret
   
   /* Validate valid Parameters are passed. */
   if(INVALID_KEY_PRESSED_VALUE <= Value)
   {
      /* Set invalid Value error. */
      HMI_ErrorState = (E_HMI_ID | E_HMI_INVALID_VAL);
    172e:	82 ed       	ldi	r24, 0xD2	; 210
      HMI_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return HMI_ErrorState;
    1730:	08 95       	ret

00001732 <Indicator_MainFunction>:
* @brief: This function is the indicator main function.
*
* @return function error state.
*/
extern void Indicator_MainFunction(void)
{
    1732:	cf 93       	push	r28
    1734:	df 93       	push	r29
    1736:	00 d0       	rcall	.+0      	; 0x1738 <Indicator_MainFunction+0x6>
    1738:	1f 92       	push	r1
    173a:	cd b7       	in	r28, 0x3d	; 61
    173c:	de b7       	in	r29, 0x3e	; 62
   /* OS Variable used for calculating the function waiting period. */
   portTickType xLastWakeTime;
   xLastWakeTime=xTaskGetTickCount();
    173e:	0e 94 50 05 	call	0xaa0	; 0xaa0 <xTaskGetTickCount>
    1742:	9a 83       	std	Y+2, r25	; 0x02
    1744:	89 83       	std	Y+1, r24	; 0x01
   static uint8_t u8_OldPattern = INDICATOR_INVALID_PATTERN;
   static Enu_IndicatorStateMachine State = Indicator_LowTime;
   static uint8_t u8_Duty = 0;
   
   /* Initialization sequence. */
   if (u8_Init == 0)
    1746:	80 91 3c 07 	lds	r24, 0x073C	; 0x80073c <u8_Init.1974>
    174a:	81 11       	cpse	r24, r1
    174c:	07 c0       	rjmp	.+14     	; 0x175c <Indicator_MainFunction+0x2a>
   {
      LED_Init(LED_UsedChannel);
    174e:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <LED_UsedChannel>
    1752:	0e 94 28 08 	call	0x1050	; 0x1050 <LED_Init>
      u8_Init = 1;
    1756:	81 e0       	ldi	r24, 0x01	; 1
    1758:	80 93 3c 07 	sts	0x073C, r24	; 0x80073c <u8_Init.1974>
   }
   
   /* Get the current pattern. */
   Indicator_GetPattern(&u8_Pattern);
    175c:	ce 01       	movw	r24, r28
    175e:	03 96       	adiw	r24, 0x03	; 3
    1760:	0e 94 48 0c 	call	0x1890	; 0x1890 <Indicator_GetPattern>
   
   /* If a new pattern is set. */
   if( u8_Pattern != u8_OldPattern)
    1764:	eb 81       	ldd	r30, Y+3	; 0x03
    1766:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    176a:	e8 17       	cp	r30, r24
    176c:	31 f0       	breq	.+12     	; 0x177a <Indicator_MainFunction+0x48>
   {
      u8_OldPattern = u8_Pattern;
    176e:	e0 93 60 00 	sts	0x0060, r30	; 0x800060 <__DATA_REGION_ORIGIN__>
      /* Reinitialize the state and the duty cycle. */
      State = Indicator_LowTime;
    1772:	10 92 3b 07 	sts	0x073B, r1	; 0x80073b <State.1977>
      u8_Duty = MIN_DUTY;
    1776:	10 92 3a 07 	sts	0x073A, r1	; 0x80073a <u8_Duty.1978>
   }
   
   if(INDICATOR_INVALID_PATTERN != u8_Pattern)
    177a:	e4 30       	cpi	r30, 0x04	; 4
    177c:	09 f4       	brne	.+2      	; 0x1780 <Indicator_MainFunction+0x4e>
    177e:	82 c0       	rjmp	.+260    	; 0x1884 <Indicator_MainFunction+0x152>
   {
      switch(State)
    1780:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <State.1977>
    1784:	81 30       	cpi	r24, 0x01	; 1
    1786:	f9 f0       	breq	.+62     	; 0x17c6 <Indicator_MainFunction+0x94>
    1788:	38 f0       	brcs	.+14     	; 0x1798 <Indicator_MainFunction+0x66>
    178a:	82 30       	cpi	r24, 0x02	; 2
    178c:	09 f4       	brne	.+2      	; 0x1790 <Indicator_MainFunction+0x5e>
    178e:	40 c0       	rjmp	.+128    	; 0x1810 <Indicator_MainFunction+0xde>
    1790:	83 30       	cpi	r24, 0x03	; 3
    1792:	09 f4       	brne	.+2      	; 0x1796 <Indicator_MainFunction+0x64>
    1794:	54 c0       	rjmp	.+168    	; 0x183e <Indicator_MainFunction+0x10c>
    1796:	76 c0       	rjmp	.+236    	; 0x1884 <Indicator_MainFunction+0x152>
      {
         case Indicator_LowTime:
            /* Turn off led */
            LED_Off(LED_UsedChannel);
    1798:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <LED_UsedChannel>
    179c:	0e 94 8e 08 	call	0x111c	; 0x111c <LED_Off>
            /* Change state to rise time state. */
            State = Indicator_RiseTime;
    17a0:	81 e0       	ldi	r24, 0x01	; 1
    17a2:	80 93 3b 07 	sts	0x073B, r24	; 0x80073b <State.1977>
            /* Put the task in waiting state for the low time period. */
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u32_LowTime);
    17a6:	eb 81       	ldd	r30, Y+3	; 0x03
    17a8:	86 e1       	ldi	r24, 0x16	; 22
    17aa:	e8 9f       	mul	r30, r24
    17ac:	f0 01       	movw	r30, r0
    17ae:	11 24       	eor	r1, r1
    17b0:	ec 58       	subi	r30, 0x8C	; 140
    17b2:	ff 4f       	sbci	r31, 0xFF	; 255
    17b4:	60 89       	ldd	r22, Z+16	; 0x10
    17b6:	71 89       	ldd	r23, Z+17	; 0x11
    17b8:	82 89       	ldd	r24, Z+18	; 0x12
    17ba:	93 89       	ldd	r25, Z+19	; 0x13
    17bc:	ce 01       	movw	r24, r28
    17be:	01 96       	adiw	r24, 0x01	; 1
    17c0:	0e 94 86 06 	call	0xd0c	; 0xd0c <vTaskDelayUntil>
            break;
    17c4:	5f c0       	rjmp	.+190    	; 0x1884 <Indicator_MainFunction+0x152>
         case Indicator_RiseTime:
            /* Increase the duty with the rate of change. */
            u8_Duty += aSTR_IndicatorConfig[u8_Pattern].u8_RateOfChange;
    17c6:	86 e1       	ldi	r24, 0x16	; 22
    17c8:	e8 9f       	mul	r30, r24
    17ca:	f0 01       	movw	r30, r0
    17cc:	11 24       	eor	r1, r1
    17ce:	ec 58       	subi	r30, 0x8C	; 140
    17d0:	ff 4f       	sbci	r31, 0xFF	; 255
    17d2:	65 89       	ldd	r22, Z+21	; 0x15
    17d4:	80 91 3a 07 	lds	r24, 0x073A	; 0x80073a <u8_Duty.1978>
    17d8:	68 0f       	add	r22, r24
    17da:	60 93 3a 07 	sts	0x073A, r22	; 0x80073a <u8_Duty.1978>
            /* Dim the led with the current duty cycle. */
            LED_Dim(LED_UsedChannel, u8_Duty);
    17de:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <LED_UsedChannel>
    17e2:	0e 94 0a 09 	call	0x1214	; 0x1214 <LED_Dim>
            /* Change state to high time state. */
            if(u8_Duty == MAX_DUTY)
    17e6:	80 91 3a 07 	lds	r24, 0x073A	; 0x80073a <u8_Duty.1978>
    17ea:	84 36       	cpi	r24, 0x64	; 100
    17ec:	19 f4       	brne	.+6      	; 0x17f4 <Indicator_MainFunction+0xc2>
            {
               State = Indicator_HighTime;
    17ee:	82 e0       	ldi	r24, 0x02	; 2
    17f0:	80 93 3b 07 	sts	0x073B, r24	; 0x80073b <State.1977>
            }
            /* Put the task in waiting state for the step time period. */
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u8_StepTime);
    17f4:	eb 81       	ldd	r30, Y+3	; 0x03
    17f6:	86 e1       	ldi	r24, 0x16	; 22
    17f8:	e8 9f       	mul	r30, r24
    17fa:	f0 01       	movw	r30, r0
    17fc:	11 24       	eor	r1, r1
    17fe:	ec 58       	subi	r30, 0x8C	; 140
    1800:	ff 4f       	sbci	r31, 0xFF	; 255
    1802:	64 89       	ldd	r22, Z+20	; 0x14
    1804:	70 e0       	ldi	r23, 0x00	; 0
    1806:	ce 01       	movw	r24, r28
    1808:	01 96       	adiw	r24, 0x01	; 1
    180a:	0e 94 86 06 	call	0xd0c	; 0xd0c <vTaskDelayUntil>
            break;
    180e:	3a c0       	rjmp	.+116    	; 0x1884 <Indicator_MainFunction+0x152>
         case Indicator_HighTime:
            /* Turn led on. */
            LED_On(LED_UsedChannel);
    1810:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <LED_UsedChannel>
    1814:	0e 94 cc 08 	call	0x1198	; 0x1198 <LED_On>
            /* Change state to fall time state. */
            State = Indicator_FallTime;
    1818:	83 e0       	ldi	r24, 0x03	; 3
    181a:	80 93 3b 07 	sts	0x073B, r24	; 0x80073b <State.1977>
            /* Put the task in waiting state for the high time period. */
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u32_HighTime);
    181e:	eb 81       	ldd	r30, Y+3	; 0x03
    1820:	86 e1       	ldi	r24, 0x16	; 22
    1822:	e8 9f       	mul	r30, r24
    1824:	f0 01       	movw	r30, r0
    1826:	11 24       	eor	r1, r1
    1828:	ec 58       	subi	r30, 0x8C	; 140
    182a:	ff 4f       	sbci	r31, 0xFF	; 255
    182c:	64 81       	ldd	r22, Z+4	; 0x04
    182e:	75 81       	ldd	r23, Z+5	; 0x05
    1830:	86 81       	ldd	r24, Z+6	; 0x06
    1832:	97 81       	ldd	r25, Z+7	; 0x07
    1834:	ce 01       	movw	r24, r28
    1836:	01 96       	adiw	r24, 0x01	; 1
    1838:	0e 94 86 06 	call	0xd0c	; 0xd0c <vTaskDelayUntil>
            break;
    183c:	23 c0       	rjmp	.+70     	; 0x1884 <Indicator_MainFunction+0x152>
         case Indicator_FallTime:
            /* decrease the duty with the rate of change. */
            u8_Duty -= aSTR_IndicatorConfig[u8_Pattern].u8_RateOfChange;
    183e:	86 e1       	ldi	r24, 0x16	; 22
    1840:	e8 9f       	mul	r30, r24
    1842:	f0 01       	movw	r30, r0
    1844:	11 24       	eor	r1, r1
    1846:	ec 58       	subi	r30, 0x8C	; 140
    1848:	ff 4f       	sbci	r31, 0xFF	; 255
    184a:	85 89       	ldd	r24, Z+21	; 0x15
    184c:	60 91 3a 07 	lds	r22, 0x073A	; 0x80073a <u8_Duty.1978>
    1850:	68 1b       	sub	r22, r24
    1852:	60 93 3a 07 	sts	0x073A, r22	; 0x80073a <u8_Duty.1978>
            /* Dim the led with the current duty cycle. */
            LED_Dim(LED_UsedChannel, u8_Duty);
    1856:	80 91 cc 00 	lds	r24, 0x00CC	; 0x8000cc <LED_UsedChannel>
    185a:	0e 94 0a 09 	call	0x1214	; 0x1214 <LED_Dim>
            /* Change state to low time state. */
            if(u8_Duty == MIN_DUTY)
    185e:	80 91 3a 07 	lds	r24, 0x073A	; 0x80073a <u8_Duty.1978>
    1862:	81 11       	cpse	r24, r1
    1864:	02 c0       	rjmp	.+4      	; 0x186a <Indicator_MainFunction+0x138>
            {
               State = Indicator_LowTime;
    1866:	10 92 3b 07 	sts	0x073B, r1	; 0x80073b <State.1977>
            }
            /* Put the task in waiting state for the step time period. */
            vTaskDelayUntil(&xLastWakeTime, aSTR_IndicatorConfig[u8_Pattern].u8_StepTime);
    186a:	eb 81       	ldd	r30, Y+3	; 0x03
    186c:	86 e1       	ldi	r24, 0x16	; 22
    186e:	e8 9f       	mul	r30, r24
    1870:	f0 01       	movw	r30, r0
    1872:	11 24       	eor	r1, r1
    1874:	ec 58       	subi	r30, 0x8C	; 140
    1876:	ff 4f       	sbci	r31, 0xFF	; 255
    1878:	64 89       	ldd	r22, Z+20	; 0x14
    187a:	70 e0       	ldi	r23, 0x00	; 0
    187c:	ce 01       	movw	r24, r28
    187e:	01 96       	adiw	r24, 0x01	; 1
    1880:	0e 94 86 06 	call	0xd0c	; 0xd0c <vTaskDelayUntil>
            break;
      }
   }
    1884:	0f 90       	pop	r0
    1886:	0f 90       	pop	r0
    1888:	0f 90       	pop	r0
    188a:	df 91       	pop	r29
    188c:	cf 91       	pop	r28
    188e:	08 95       	ret

00001890 <Indicator_GetPattern>:
{
   /* Variable to store function error state. */
   ERROR_STATE_t Indicator_ErrorState;
   
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Value)
    1890:	00 97       	sbiw	r24, 0x00	; 0
    1892:	31 f0       	breq	.+12     	; 0x18a0 <Indicator_GetPattern+0x10>
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_NULL_PTR);
   }
   else
   {
      /* Return the indicator pattern. */
      *Value = gu8_IndicatorPattern;
    1894:	20 91 61 00 	lds	r18, 0x0061	; 0x800061 <gu8_IndicatorPattern>
    1898:	fc 01       	movw	r30, r24
    189a:	20 83       	st	Z, r18
      Indicator_ErrorState = ERROR_OK;
    189c:	80 e0       	ldi	r24, 0x00	; 0
    189e:	08 95       	ret
   
   /* Validate valid Parameters are passed. */
   if(NULL_PTR == Value)
   {
      /* Set null pointer error. */
      Indicator_ErrorState = (E_INDICATOR_ID | E_INDICATOR_NULL_PTR);
    18a0:	82 eb       	ldi	r24, 0xB2	; 178
      Indicator_ErrorState = ERROR_OK;
   }
   
   /* return Error state. */
   return Indicator_ErrorState;
}
    18a2:	08 95       	ret

000018a4 <HMI_Task>:
#include "Indicator.h"
#include "FreeRTOS.h"
#include "task.h"

void HMI_Task( void *pvParameters )
{
    18a4:	cf 93       	push	r28
    18a6:	df 93       	push	r29
    18a8:	00 d0       	rcall	.+0      	; 0x18aa <HMI_Task+0x6>
    18aa:	cd b7       	in	r28, 0x3d	; 61
    18ac:	de b7       	in	r29, 0x3e	; 62
   portTickType xLastWakeTime;
   xLastWakeTime=xTaskGetTickCount();
    18ae:	0e 94 50 05 	call	0xaa0	; 0xaa0 <xTaskGetTickCount>
    18b2:	9a 83       	std	Y+2, r25	; 0x02
    18b4:	89 83       	std	Y+1, r24	; 0x01
   
   for( ;; )
   {
      HMI_MainFunction();
    18b6:	0e 94 04 0b 	call	0x1608	; 0x1608 <HMI_MainFunction>
      vTaskDelayUntil(&xLastWakeTime, 50);
    18ba:	62 e3       	ldi	r22, 0x32	; 50
    18bc:	70 e0       	ldi	r23, 0x00	; 0
    18be:	ce 01       	movw	r24, r28
    18c0:	01 96       	adiw	r24, 0x01	; 1
    18c2:	0e 94 86 06 	call	0xd0c	; 0xd0c <vTaskDelayUntil>
    18c6:	f7 cf       	rjmp	.-18     	; 0x18b6 <HMI_Task+0x12>

000018c8 <Feedback_Task>:

void Feedback_Task( void *pvParameters )
{  
   for( ;; )
   {
      Indicator_MainFunction();
    18c8:	0e 94 99 0b 	call	0x1732	; 0x1732 <Indicator_MainFunction>
    18cc:	fd cf       	rjmp	.-6      	; 0x18c8 <Feedback_Task>

000018ce <main>:
   }
}

int main(void)
{   
   xTaskCreate( HMI_Task, "HMI", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );
    18ce:	e1 2c       	mov	r14, r1
    18d0:	f1 2c       	mov	r15, r1
    18d2:	01 e0       	ldi	r16, 0x01	; 1
    18d4:	20 e0       	ldi	r18, 0x00	; 0
    18d6:	30 e0       	ldi	r19, 0x00	; 0
    18d8:	45 e5       	ldi	r20, 0x55	; 85
    18da:	50 e0       	ldi	r21, 0x00	; 0
    18dc:	63 ee       	ldi	r22, 0xE3	; 227
    18de:	70 e0       	ldi	r23, 0x00	; 0
    18e0:	82 e5       	ldi	r24, 0x52	; 82
    18e2:	9c e0       	ldi	r25, 0x0C	; 12
    18e4:	0e 94 cc 04 	call	0x998	; 0x998 <xTaskCreate>
   xTaskCreate( Feedback_Task, "Indicator", configMINIMAL_STACK_SIZE, NULL_PTR, 1, NULL_PTR );
    18e8:	20 e0       	ldi	r18, 0x00	; 0
    18ea:	30 e0       	ldi	r19, 0x00	; 0
    18ec:	45 e5       	ldi	r20, 0x55	; 85
    18ee:	50 e0       	ldi	r21, 0x00	; 0
    18f0:	67 ee       	ldi	r22, 0xE7	; 231
    18f2:	70 e0       	ldi	r23, 0x00	; 0
    18f4:	84 e6       	ldi	r24, 0x64	; 100
    18f6:	9c e0       	ldi	r25, 0x0C	; 12
    18f8:	0e 94 cc 04 	call	0x998	; 0x998 <xTaskCreate>
   
   vTaskStartScheduler();
    18fc:	0e 94 20 05 	call	0xa40	; 0xa40 <vTaskStartScheduler>
    1900:	ff cf       	rjmp	.-2      	; 0x1900 <main+0x32>

00001902 <__subsf3>:
    1902:	50 58       	subi	r21, 0x80	; 128

00001904 <__addsf3>:
    1904:	bb 27       	eor	r27, r27
    1906:	aa 27       	eor	r26, r26
    1908:	0e 94 99 0c 	call	0x1932	; 0x1932 <__addsf3x>
    190c:	0c 94 e3 0d 	jmp	0x1bc6	; 0x1bc6 <__fp_round>
    1910:	0e 94 d5 0d 	call	0x1baa	; 0x1baa <__fp_pscA>
    1914:	38 f0       	brcs	.+14     	; 0x1924 <__addsf3+0x20>
    1916:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <__fp_pscB>
    191a:	20 f0       	brcs	.+8      	; 0x1924 <__addsf3+0x20>
    191c:	39 f4       	brne	.+14     	; 0x192c <__addsf3+0x28>
    191e:	9f 3f       	cpi	r25, 0xFF	; 255
    1920:	19 f4       	brne	.+6      	; 0x1928 <__addsf3+0x24>
    1922:	26 f4       	brtc	.+8      	; 0x192c <__addsf3+0x28>
    1924:	0c 94 d2 0d 	jmp	0x1ba4	; 0x1ba4 <__fp_nan>
    1928:	0e f4       	brtc	.+2      	; 0x192c <__addsf3+0x28>
    192a:	e0 95       	com	r30
    192c:	e7 fb       	bst	r30, 7
    192e:	0c 94 cc 0d 	jmp	0x1b98	; 0x1b98 <__fp_inf>

00001932 <__addsf3x>:
    1932:	e9 2f       	mov	r30, r25
    1934:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <__fp_split3>
    1938:	58 f3       	brcs	.-42     	; 0x1910 <__addsf3+0xc>
    193a:	ba 17       	cp	r27, r26
    193c:	62 07       	cpc	r22, r18
    193e:	73 07       	cpc	r23, r19
    1940:	84 07       	cpc	r24, r20
    1942:	95 07       	cpc	r25, r21
    1944:	20 f0       	brcs	.+8      	; 0x194e <__addsf3x+0x1c>
    1946:	79 f4       	brne	.+30     	; 0x1966 <__addsf3x+0x34>
    1948:	a6 f5       	brtc	.+104    	; 0x19b2 <__addsf3x+0x80>
    194a:	0c 94 16 0e 	jmp	0x1c2c	; 0x1c2c <__fp_zero>
    194e:	0e f4       	brtc	.+2      	; 0x1952 <__addsf3x+0x20>
    1950:	e0 95       	com	r30
    1952:	0b 2e       	mov	r0, r27
    1954:	ba 2f       	mov	r27, r26
    1956:	a0 2d       	mov	r26, r0
    1958:	0b 01       	movw	r0, r22
    195a:	b9 01       	movw	r22, r18
    195c:	90 01       	movw	r18, r0
    195e:	0c 01       	movw	r0, r24
    1960:	ca 01       	movw	r24, r20
    1962:	a0 01       	movw	r20, r0
    1964:	11 24       	eor	r1, r1
    1966:	ff 27       	eor	r31, r31
    1968:	59 1b       	sub	r21, r25
    196a:	99 f0       	breq	.+38     	; 0x1992 <__addsf3x+0x60>
    196c:	59 3f       	cpi	r21, 0xF9	; 249
    196e:	50 f4       	brcc	.+20     	; 0x1984 <__addsf3x+0x52>
    1970:	50 3e       	cpi	r21, 0xE0	; 224
    1972:	68 f1       	brcs	.+90     	; 0x19ce <__addsf3x+0x9c>
    1974:	1a 16       	cp	r1, r26
    1976:	f0 40       	sbci	r31, 0x00	; 0
    1978:	a2 2f       	mov	r26, r18
    197a:	23 2f       	mov	r18, r19
    197c:	34 2f       	mov	r19, r20
    197e:	44 27       	eor	r20, r20
    1980:	58 5f       	subi	r21, 0xF8	; 248
    1982:	f3 cf       	rjmp	.-26     	; 0x196a <__addsf3x+0x38>
    1984:	46 95       	lsr	r20
    1986:	37 95       	ror	r19
    1988:	27 95       	ror	r18
    198a:	a7 95       	ror	r26
    198c:	f0 40       	sbci	r31, 0x00	; 0
    198e:	53 95       	inc	r21
    1990:	c9 f7       	brne	.-14     	; 0x1984 <__addsf3x+0x52>
    1992:	7e f4       	brtc	.+30     	; 0x19b2 <__addsf3x+0x80>
    1994:	1f 16       	cp	r1, r31
    1996:	ba 0b       	sbc	r27, r26
    1998:	62 0b       	sbc	r22, r18
    199a:	73 0b       	sbc	r23, r19
    199c:	84 0b       	sbc	r24, r20
    199e:	ba f0       	brmi	.+46     	; 0x19ce <__addsf3x+0x9c>
    19a0:	91 50       	subi	r25, 0x01	; 1
    19a2:	a1 f0       	breq	.+40     	; 0x19cc <__addsf3x+0x9a>
    19a4:	ff 0f       	add	r31, r31
    19a6:	bb 1f       	adc	r27, r27
    19a8:	66 1f       	adc	r22, r22
    19aa:	77 1f       	adc	r23, r23
    19ac:	88 1f       	adc	r24, r24
    19ae:	c2 f7       	brpl	.-16     	; 0x19a0 <__addsf3x+0x6e>
    19b0:	0e c0       	rjmp	.+28     	; 0x19ce <__addsf3x+0x9c>
    19b2:	ba 0f       	add	r27, r26
    19b4:	62 1f       	adc	r22, r18
    19b6:	73 1f       	adc	r23, r19
    19b8:	84 1f       	adc	r24, r20
    19ba:	48 f4       	brcc	.+18     	; 0x19ce <__addsf3x+0x9c>
    19bc:	87 95       	ror	r24
    19be:	77 95       	ror	r23
    19c0:	67 95       	ror	r22
    19c2:	b7 95       	ror	r27
    19c4:	f7 95       	ror	r31
    19c6:	9e 3f       	cpi	r25, 0xFE	; 254
    19c8:	08 f0       	brcs	.+2      	; 0x19cc <__addsf3x+0x9a>
    19ca:	b0 cf       	rjmp	.-160    	; 0x192c <__addsf3+0x28>
    19cc:	93 95       	inc	r25
    19ce:	88 0f       	add	r24, r24
    19d0:	08 f0       	brcs	.+2      	; 0x19d4 <__addsf3x+0xa2>
    19d2:	99 27       	eor	r25, r25
    19d4:	ee 0f       	add	r30, r30
    19d6:	97 95       	ror	r25
    19d8:	87 95       	ror	r24
    19da:	08 95       	ret

000019dc <__divsf3>:
    19dc:	0e 94 02 0d 	call	0x1a04	; 0x1a04 <__divsf3x>
    19e0:	0c 94 e3 0d 	jmp	0x1bc6	; 0x1bc6 <__fp_round>
    19e4:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <__fp_pscB>
    19e8:	58 f0       	brcs	.+22     	; 0x1a00 <__divsf3+0x24>
    19ea:	0e 94 d5 0d 	call	0x1baa	; 0x1baa <__fp_pscA>
    19ee:	40 f0       	brcs	.+16     	; 0x1a00 <__divsf3+0x24>
    19f0:	29 f4       	brne	.+10     	; 0x19fc <__divsf3+0x20>
    19f2:	5f 3f       	cpi	r21, 0xFF	; 255
    19f4:	29 f0       	breq	.+10     	; 0x1a00 <__divsf3+0x24>
    19f6:	0c 94 cc 0d 	jmp	0x1b98	; 0x1b98 <__fp_inf>
    19fa:	51 11       	cpse	r21, r1
    19fc:	0c 94 17 0e 	jmp	0x1c2e	; 0x1c2e <__fp_szero>
    1a00:	0c 94 d2 0d 	jmp	0x1ba4	; 0x1ba4 <__fp_nan>

00001a04 <__divsf3x>:
    1a04:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <__fp_split3>
    1a08:	68 f3       	brcs	.-38     	; 0x19e4 <__divsf3+0x8>

00001a0a <__divsf3_pse>:
    1a0a:	99 23       	and	r25, r25
    1a0c:	b1 f3       	breq	.-20     	; 0x19fa <__divsf3+0x1e>
    1a0e:	55 23       	and	r21, r21
    1a10:	91 f3       	breq	.-28     	; 0x19f6 <__divsf3+0x1a>
    1a12:	95 1b       	sub	r25, r21
    1a14:	55 0b       	sbc	r21, r21
    1a16:	bb 27       	eor	r27, r27
    1a18:	aa 27       	eor	r26, r26
    1a1a:	62 17       	cp	r22, r18
    1a1c:	73 07       	cpc	r23, r19
    1a1e:	84 07       	cpc	r24, r20
    1a20:	38 f0       	brcs	.+14     	; 0x1a30 <__divsf3_pse+0x26>
    1a22:	9f 5f       	subi	r25, 0xFF	; 255
    1a24:	5f 4f       	sbci	r21, 0xFF	; 255
    1a26:	22 0f       	add	r18, r18
    1a28:	33 1f       	adc	r19, r19
    1a2a:	44 1f       	adc	r20, r20
    1a2c:	aa 1f       	adc	r26, r26
    1a2e:	a9 f3       	breq	.-22     	; 0x1a1a <__divsf3_pse+0x10>
    1a30:	35 d0       	rcall	.+106    	; 0x1a9c <__divsf3_pse+0x92>
    1a32:	0e 2e       	mov	r0, r30
    1a34:	3a f0       	brmi	.+14     	; 0x1a44 <__divsf3_pse+0x3a>
    1a36:	e0 e8       	ldi	r30, 0x80	; 128
    1a38:	32 d0       	rcall	.+100    	; 0x1a9e <__divsf3_pse+0x94>
    1a3a:	91 50       	subi	r25, 0x01	; 1
    1a3c:	50 40       	sbci	r21, 0x00	; 0
    1a3e:	e6 95       	lsr	r30
    1a40:	00 1c       	adc	r0, r0
    1a42:	ca f7       	brpl	.-14     	; 0x1a36 <__divsf3_pse+0x2c>
    1a44:	2b d0       	rcall	.+86     	; 0x1a9c <__divsf3_pse+0x92>
    1a46:	fe 2f       	mov	r31, r30
    1a48:	29 d0       	rcall	.+82     	; 0x1a9c <__divsf3_pse+0x92>
    1a4a:	66 0f       	add	r22, r22
    1a4c:	77 1f       	adc	r23, r23
    1a4e:	88 1f       	adc	r24, r24
    1a50:	bb 1f       	adc	r27, r27
    1a52:	26 17       	cp	r18, r22
    1a54:	37 07       	cpc	r19, r23
    1a56:	48 07       	cpc	r20, r24
    1a58:	ab 07       	cpc	r26, r27
    1a5a:	b0 e8       	ldi	r27, 0x80	; 128
    1a5c:	09 f0       	breq	.+2      	; 0x1a60 <__divsf3_pse+0x56>
    1a5e:	bb 0b       	sbc	r27, r27
    1a60:	80 2d       	mov	r24, r0
    1a62:	bf 01       	movw	r22, r30
    1a64:	ff 27       	eor	r31, r31
    1a66:	93 58       	subi	r25, 0x83	; 131
    1a68:	5f 4f       	sbci	r21, 0xFF	; 255
    1a6a:	3a f0       	brmi	.+14     	; 0x1a7a <__divsf3_pse+0x70>
    1a6c:	9e 3f       	cpi	r25, 0xFE	; 254
    1a6e:	51 05       	cpc	r21, r1
    1a70:	78 f0       	brcs	.+30     	; 0x1a90 <__divsf3_pse+0x86>
    1a72:	0c 94 cc 0d 	jmp	0x1b98	; 0x1b98 <__fp_inf>
    1a76:	0c 94 17 0e 	jmp	0x1c2e	; 0x1c2e <__fp_szero>
    1a7a:	5f 3f       	cpi	r21, 0xFF	; 255
    1a7c:	e4 f3       	brlt	.-8      	; 0x1a76 <__divsf3_pse+0x6c>
    1a7e:	98 3e       	cpi	r25, 0xE8	; 232
    1a80:	d4 f3       	brlt	.-12     	; 0x1a76 <__divsf3_pse+0x6c>
    1a82:	86 95       	lsr	r24
    1a84:	77 95       	ror	r23
    1a86:	67 95       	ror	r22
    1a88:	b7 95       	ror	r27
    1a8a:	f7 95       	ror	r31
    1a8c:	9f 5f       	subi	r25, 0xFF	; 255
    1a8e:	c9 f7       	brne	.-14     	; 0x1a82 <__divsf3_pse+0x78>
    1a90:	88 0f       	add	r24, r24
    1a92:	91 1d       	adc	r25, r1
    1a94:	96 95       	lsr	r25
    1a96:	87 95       	ror	r24
    1a98:	97 f9       	bld	r25, 7
    1a9a:	08 95       	ret
    1a9c:	e1 e0       	ldi	r30, 0x01	; 1
    1a9e:	66 0f       	add	r22, r22
    1aa0:	77 1f       	adc	r23, r23
    1aa2:	88 1f       	adc	r24, r24
    1aa4:	bb 1f       	adc	r27, r27
    1aa6:	62 17       	cp	r22, r18
    1aa8:	73 07       	cpc	r23, r19
    1aaa:	84 07       	cpc	r24, r20
    1aac:	ba 07       	cpc	r27, r26
    1aae:	20 f0       	brcs	.+8      	; 0x1ab8 <__divsf3_pse+0xae>
    1ab0:	62 1b       	sub	r22, r18
    1ab2:	73 0b       	sbc	r23, r19
    1ab4:	84 0b       	sbc	r24, r20
    1ab6:	ba 0b       	sbc	r27, r26
    1ab8:	ee 1f       	adc	r30, r30
    1aba:	88 f7       	brcc	.-30     	; 0x1a9e <__divsf3_pse+0x94>
    1abc:	e0 95       	com	r30
    1abe:	08 95       	ret

00001ac0 <__fixunssfsi>:
    1ac0:	0e 94 fc 0d 	call	0x1bf8	; 0x1bf8 <__fp_splitA>
    1ac4:	88 f0       	brcs	.+34     	; 0x1ae8 <__fixunssfsi+0x28>
    1ac6:	9f 57       	subi	r25, 0x7F	; 127
    1ac8:	98 f0       	brcs	.+38     	; 0x1af0 <__fixunssfsi+0x30>
    1aca:	b9 2f       	mov	r27, r25
    1acc:	99 27       	eor	r25, r25
    1ace:	b7 51       	subi	r27, 0x17	; 23
    1ad0:	b0 f0       	brcs	.+44     	; 0x1afe <__fixunssfsi+0x3e>
    1ad2:	e1 f0       	breq	.+56     	; 0x1b0c <__fixunssfsi+0x4c>
    1ad4:	66 0f       	add	r22, r22
    1ad6:	77 1f       	adc	r23, r23
    1ad8:	88 1f       	adc	r24, r24
    1ada:	99 1f       	adc	r25, r25
    1adc:	1a f0       	brmi	.+6      	; 0x1ae4 <__fixunssfsi+0x24>
    1ade:	ba 95       	dec	r27
    1ae0:	c9 f7       	brne	.-14     	; 0x1ad4 <__fixunssfsi+0x14>
    1ae2:	14 c0       	rjmp	.+40     	; 0x1b0c <__fixunssfsi+0x4c>
    1ae4:	b1 30       	cpi	r27, 0x01	; 1
    1ae6:	91 f0       	breq	.+36     	; 0x1b0c <__fixunssfsi+0x4c>
    1ae8:	0e 94 16 0e 	call	0x1c2c	; 0x1c2c <__fp_zero>
    1aec:	b1 e0       	ldi	r27, 0x01	; 1
    1aee:	08 95       	ret
    1af0:	0c 94 16 0e 	jmp	0x1c2c	; 0x1c2c <__fp_zero>
    1af4:	67 2f       	mov	r22, r23
    1af6:	78 2f       	mov	r23, r24
    1af8:	88 27       	eor	r24, r24
    1afa:	b8 5f       	subi	r27, 0xF8	; 248
    1afc:	39 f0       	breq	.+14     	; 0x1b0c <__fixunssfsi+0x4c>
    1afe:	b9 3f       	cpi	r27, 0xF9	; 249
    1b00:	cc f3       	brlt	.-14     	; 0x1af4 <__fixunssfsi+0x34>
    1b02:	86 95       	lsr	r24
    1b04:	77 95       	ror	r23
    1b06:	67 95       	ror	r22
    1b08:	b3 95       	inc	r27
    1b0a:	d9 f7       	brne	.-10     	; 0x1b02 <__fixunssfsi+0x42>
    1b0c:	3e f4       	brtc	.+14     	; 0x1b1c <__fixunssfsi+0x5c>
    1b0e:	90 95       	com	r25
    1b10:	80 95       	com	r24
    1b12:	70 95       	com	r23
    1b14:	61 95       	neg	r22
    1b16:	7f 4f       	sbci	r23, 0xFF	; 255
    1b18:	8f 4f       	sbci	r24, 0xFF	; 255
    1b1a:	9f 4f       	sbci	r25, 0xFF	; 255
    1b1c:	08 95       	ret

00001b1e <__floatunsisf>:
    1b1e:	e8 94       	clt
    1b20:	09 c0       	rjmp	.+18     	; 0x1b34 <__floatsisf+0x12>

00001b22 <__floatsisf>:
    1b22:	97 fb       	bst	r25, 7
    1b24:	3e f4       	brtc	.+14     	; 0x1b34 <__floatsisf+0x12>
    1b26:	90 95       	com	r25
    1b28:	80 95       	com	r24
    1b2a:	70 95       	com	r23
    1b2c:	61 95       	neg	r22
    1b2e:	7f 4f       	sbci	r23, 0xFF	; 255
    1b30:	8f 4f       	sbci	r24, 0xFF	; 255
    1b32:	9f 4f       	sbci	r25, 0xFF	; 255
    1b34:	99 23       	and	r25, r25
    1b36:	a9 f0       	breq	.+42     	; 0x1b62 <__floatsisf+0x40>
    1b38:	f9 2f       	mov	r31, r25
    1b3a:	96 e9       	ldi	r25, 0x96	; 150
    1b3c:	bb 27       	eor	r27, r27
    1b3e:	93 95       	inc	r25
    1b40:	f6 95       	lsr	r31
    1b42:	87 95       	ror	r24
    1b44:	77 95       	ror	r23
    1b46:	67 95       	ror	r22
    1b48:	b7 95       	ror	r27
    1b4a:	f1 11       	cpse	r31, r1
    1b4c:	f8 cf       	rjmp	.-16     	; 0x1b3e <__floatsisf+0x1c>
    1b4e:	fa f4       	brpl	.+62     	; 0x1b8e <__floatsisf+0x6c>
    1b50:	bb 0f       	add	r27, r27
    1b52:	11 f4       	brne	.+4      	; 0x1b58 <__floatsisf+0x36>
    1b54:	60 ff       	sbrs	r22, 0
    1b56:	1b c0       	rjmp	.+54     	; 0x1b8e <__floatsisf+0x6c>
    1b58:	6f 5f       	subi	r22, 0xFF	; 255
    1b5a:	7f 4f       	sbci	r23, 0xFF	; 255
    1b5c:	8f 4f       	sbci	r24, 0xFF	; 255
    1b5e:	9f 4f       	sbci	r25, 0xFF	; 255
    1b60:	16 c0       	rjmp	.+44     	; 0x1b8e <__floatsisf+0x6c>
    1b62:	88 23       	and	r24, r24
    1b64:	11 f0       	breq	.+4      	; 0x1b6a <__floatsisf+0x48>
    1b66:	96 e9       	ldi	r25, 0x96	; 150
    1b68:	11 c0       	rjmp	.+34     	; 0x1b8c <__floatsisf+0x6a>
    1b6a:	77 23       	and	r23, r23
    1b6c:	21 f0       	breq	.+8      	; 0x1b76 <__floatsisf+0x54>
    1b6e:	9e e8       	ldi	r25, 0x8E	; 142
    1b70:	87 2f       	mov	r24, r23
    1b72:	76 2f       	mov	r23, r22
    1b74:	05 c0       	rjmp	.+10     	; 0x1b80 <__floatsisf+0x5e>
    1b76:	66 23       	and	r22, r22
    1b78:	71 f0       	breq	.+28     	; 0x1b96 <__floatsisf+0x74>
    1b7a:	96 e8       	ldi	r25, 0x86	; 134
    1b7c:	86 2f       	mov	r24, r22
    1b7e:	70 e0       	ldi	r23, 0x00	; 0
    1b80:	60 e0       	ldi	r22, 0x00	; 0
    1b82:	2a f0       	brmi	.+10     	; 0x1b8e <__floatsisf+0x6c>
    1b84:	9a 95       	dec	r25
    1b86:	66 0f       	add	r22, r22
    1b88:	77 1f       	adc	r23, r23
    1b8a:	88 1f       	adc	r24, r24
    1b8c:	da f7       	brpl	.-10     	; 0x1b84 <__floatsisf+0x62>
    1b8e:	88 0f       	add	r24, r24
    1b90:	96 95       	lsr	r25
    1b92:	87 95       	ror	r24
    1b94:	97 f9       	bld	r25, 7
    1b96:	08 95       	ret

00001b98 <__fp_inf>:
    1b98:	97 f9       	bld	r25, 7
    1b9a:	9f 67       	ori	r25, 0x7F	; 127
    1b9c:	80 e8       	ldi	r24, 0x80	; 128
    1b9e:	70 e0       	ldi	r23, 0x00	; 0
    1ba0:	60 e0       	ldi	r22, 0x00	; 0
    1ba2:	08 95       	ret

00001ba4 <__fp_nan>:
    1ba4:	9f ef       	ldi	r25, 0xFF	; 255
    1ba6:	80 ec       	ldi	r24, 0xC0	; 192
    1ba8:	08 95       	ret

00001baa <__fp_pscA>:
    1baa:	00 24       	eor	r0, r0
    1bac:	0a 94       	dec	r0
    1bae:	16 16       	cp	r1, r22
    1bb0:	17 06       	cpc	r1, r23
    1bb2:	18 06       	cpc	r1, r24
    1bb4:	09 06       	cpc	r0, r25
    1bb6:	08 95       	ret

00001bb8 <__fp_pscB>:
    1bb8:	00 24       	eor	r0, r0
    1bba:	0a 94       	dec	r0
    1bbc:	12 16       	cp	r1, r18
    1bbe:	13 06       	cpc	r1, r19
    1bc0:	14 06       	cpc	r1, r20
    1bc2:	05 06       	cpc	r0, r21
    1bc4:	08 95       	ret

00001bc6 <__fp_round>:
    1bc6:	09 2e       	mov	r0, r25
    1bc8:	03 94       	inc	r0
    1bca:	00 0c       	add	r0, r0
    1bcc:	11 f4       	brne	.+4      	; 0x1bd2 <__fp_round+0xc>
    1bce:	88 23       	and	r24, r24
    1bd0:	52 f0       	brmi	.+20     	; 0x1be6 <__fp_round+0x20>
    1bd2:	bb 0f       	add	r27, r27
    1bd4:	40 f4       	brcc	.+16     	; 0x1be6 <__fp_round+0x20>
    1bd6:	bf 2b       	or	r27, r31
    1bd8:	11 f4       	brne	.+4      	; 0x1bde <__fp_round+0x18>
    1bda:	60 ff       	sbrs	r22, 0
    1bdc:	04 c0       	rjmp	.+8      	; 0x1be6 <__fp_round+0x20>
    1bde:	6f 5f       	subi	r22, 0xFF	; 255
    1be0:	7f 4f       	sbci	r23, 0xFF	; 255
    1be2:	8f 4f       	sbci	r24, 0xFF	; 255
    1be4:	9f 4f       	sbci	r25, 0xFF	; 255
    1be6:	08 95       	ret

00001be8 <__fp_split3>:
    1be8:	57 fd       	sbrc	r21, 7
    1bea:	90 58       	subi	r25, 0x80	; 128
    1bec:	44 0f       	add	r20, r20
    1bee:	55 1f       	adc	r21, r21
    1bf0:	59 f0       	breq	.+22     	; 0x1c08 <__fp_splitA+0x10>
    1bf2:	5f 3f       	cpi	r21, 0xFF	; 255
    1bf4:	71 f0       	breq	.+28     	; 0x1c12 <__fp_splitA+0x1a>
    1bf6:	47 95       	ror	r20

00001bf8 <__fp_splitA>:
    1bf8:	88 0f       	add	r24, r24
    1bfa:	97 fb       	bst	r25, 7
    1bfc:	99 1f       	adc	r25, r25
    1bfe:	61 f0       	breq	.+24     	; 0x1c18 <__fp_splitA+0x20>
    1c00:	9f 3f       	cpi	r25, 0xFF	; 255
    1c02:	79 f0       	breq	.+30     	; 0x1c22 <__fp_splitA+0x2a>
    1c04:	87 95       	ror	r24
    1c06:	08 95       	ret
    1c08:	12 16       	cp	r1, r18
    1c0a:	13 06       	cpc	r1, r19
    1c0c:	14 06       	cpc	r1, r20
    1c0e:	55 1f       	adc	r21, r21
    1c10:	f2 cf       	rjmp	.-28     	; 0x1bf6 <__fp_split3+0xe>
    1c12:	46 95       	lsr	r20
    1c14:	f1 df       	rcall	.-30     	; 0x1bf8 <__fp_splitA>
    1c16:	08 c0       	rjmp	.+16     	; 0x1c28 <__fp_splitA+0x30>
    1c18:	16 16       	cp	r1, r22
    1c1a:	17 06       	cpc	r1, r23
    1c1c:	18 06       	cpc	r1, r24
    1c1e:	99 1f       	adc	r25, r25
    1c20:	f1 cf       	rjmp	.-30     	; 0x1c04 <__fp_splitA+0xc>
    1c22:	86 95       	lsr	r24
    1c24:	71 05       	cpc	r23, r1
    1c26:	61 05       	cpc	r22, r1
    1c28:	08 94       	sec
    1c2a:	08 95       	ret

00001c2c <__fp_zero>:
    1c2c:	e8 94       	clt

00001c2e <__fp_szero>:
    1c2e:	bb 27       	eor	r27, r27
    1c30:	66 27       	eor	r22, r22
    1c32:	77 27       	eor	r23, r23
    1c34:	cb 01       	movw	r24, r22
    1c36:	97 f9       	bld	r25, 7
    1c38:	08 95       	ret

00001c3a <__mulsf3>:
    1c3a:	0e 94 30 0e 	call	0x1c60	; 0x1c60 <__mulsf3x>
    1c3e:	0c 94 e3 0d 	jmp	0x1bc6	; 0x1bc6 <__fp_round>
    1c42:	0e 94 d5 0d 	call	0x1baa	; 0x1baa <__fp_pscA>
    1c46:	38 f0       	brcs	.+14     	; 0x1c56 <__mulsf3+0x1c>
    1c48:	0e 94 dc 0d 	call	0x1bb8	; 0x1bb8 <__fp_pscB>
    1c4c:	20 f0       	brcs	.+8      	; 0x1c56 <__mulsf3+0x1c>
    1c4e:	95 23       	and	r25, r21
    1c50:	11 f0       	breq	.+4      	; 0x1c56 <__mulsf3+0x1c>
    1c52:	0c 94 cc 0d 	jmp	0x1b98	; 0x1b98 <__fp_inf>
    1c56:	0c 94 d2 0d 	jmp	0x1ba4	; 0x1ba4 <__fp_nan>
    1c5a:	11 24       	eor	r1, r1
    1c5c:	0c 94 17 0e 	jmp	0x1c2e	; 0x1c2e <__fp_szero>

00001c60 <__mulsf3x>:
    1c60:	0e 94 f4 0d 	call	0x1be8	; 0x1be8 <__fp_split3>
    1c64:	70 f3       	brcs	.-36     	; 0x1c42 <__mulsf3+0x8>

00001c66 <__mulsf3_pse>:
    1c66:	95 9f       	mul	r25, r21
    1c68:	c1 f3       	breq	.-16     	; 0x1c5a <__mulsf3+0x20>
    1c6a:	95 0f       	add	r25, r21
    1c6c:	50 e0       	ldi	r21, 0x00	; 0
    1c6e:	55 1f       	adc	r21, r21
    1c70:	62 9f       	mul	r22, r18
    1c72:	f0 01       	movw	r30, r0
    1c74:	72 9f       	mul	r23, r18
    1c76:	bb 27       	eor	r27, r27
    1c78:	f0 0d       	add	r31, r0
    1c7a:	b1 1d       	adc	r27, r1
    1c7c:	63 9f       	mul	r22, r19
    1c7e:	aa 27       	eor	r26, r26
    1c80:	f0 0d       	add	r31, r0
    1c82:	b1 1d       	adc	r27, r1
    1c84:	aa 1f       	adc	r26, r26
    1c86:	64 9f       	mul	r22, r20
    1c88:	66 27       	eor	r22, r22
    1c8a:	b0 0d       	add	r27, r0
    1c8c:	a1 1d       	adc	r26, r1
    1c8e:	66 1f       	adc	r22, r22
    1c90:	82 9f       	mul	r24, r18
    1c92:	22 27       	eor	r18, r18
    1c94:	b0 0d       	add	r27, r0
    1c96:	a1 1d       	adc	r26, r1
    1c98:	62 1f       	adc	r22, r18
    1c9a:	73 9f       	mul	r23, r19
    1c9c:	b0 0d       	add	r27, r0
    1c9e:	a1 1d       	adc	r26, r1
    1ca0:	62 1f       	adc	r22, r18
    1ca2:	83 9f       	mul	r24, r19
    1ca4:	a0 0d       	add	r26, r0
    1ca6:	61 1d       	adc	r22, r1
    1ca8:	22 1f       	adc	r18, r18
    1caa:	74 9f       	mul	r23, r20
    1cac:	33 27       	eor	r19, r19
    1cae:	a0 0d       	add	r26, r0
    1cb0:	61 1d       	adc	r22, r1
    1cb2:	23 1f       	adc	r18, r19
    1cb4:	84 9f       	mul	r24, r20
    1cb6:	60 0d       	add	r22, r0
    1cb8:	21 1d       	adc	r18, r1
    1cba:	82 2f       	mov	r24, r18
    1cbc:	76 2f       	mov	r23, r22
    1cbe:	6a 2f       	mov	r22, r26
    1cc0:	11 24       	eor	r1, r1
    1cc2:	9f 57       	subi	r25, 0x7F	; 127
    1cc4:	50 40       	sbci	r21, 0x00	; 0
    1cc6:	9a f0       	brmi	.+38     	; 0x1cee <__mulsf3_pse+0x88>
    1cc8:	f1 f0       	breq	.+60     	; 0x1d06 <__mulsf3_pse+0xa0>
    1cca:	88 23       	and	r24, r24
    1ccc:	4a f0       	brmi	.+18     	; 0x1ce0 <__mulsf3_pse+0x7a>
    1cce:	ee 0f       	add	r30, r30
    1cd0:	ff 1f       	adc	r31, r31
    1cd2:	bb 1f       	adc	r27, r27
    1cd4:	66 1f       	adc	r22, r22
    1cd6:	77 1f       	adc	r23, r23
    1cd8:	88 1f       	adc	r24, r24
    1cda:	91 50       	subi	r25, 0x01	; 1
    1cdc:	50 40       	sbci	r21, 0x00	; 0
    1cde:	a9 f7       	brne	.-22     	; 0x1cca <__mulsf3_pse+0x64>
    1ce0:	9e 3f       	cpi	r25, 0xFE	; 254
    1ce2:	51 05       	cpc	r21, r1
    1ce4:	80 f0       	brcs	.+32     	; 0x1d06 <__mulsf3_pse+0xa0>
    1ce6:	0c 94 cc 0d 	jmp	0x1b98	; 0x1b98 <__fp_inf>
    1cea:	0c 94 17 0e 	jmp	0x1c2e	; 0x1c2e <__fp_szero>
    1cee:	5f 3f       	cpi	r21, 0xFF	; 255
    1cf0:	e4 f3       	brlt	.-8      	; 0x1cea <__mulsf3_pse+0x84>
    1cf2:	98 3e       	cpi	r25, 0xE8	; 232
    1cf4:	d4 f3       	brlt	.-12     	; 0x1cea <__mulsf3_pse+0x84>
    1cf6:	86 95       	lsr	r24
    1cf8:	77 95       	ror	r23
    1cfa:	67 95       	ror	r22
    1cfc:	b7 95       	ror	r27
    1cfe:	f7 95       	ror	r31
    1d00:	e7 95       	ror	r30
    1d02:	9f 5f       	subi	r25, 0xFF	; 255
    1d04:	c1 f7       	brne	.-16     	; 0x1cf6 <__mulsf3_pse+0x90>
    1d06:	fe 2b       	or	r31, r30
    1d08:	88 0f       	add	r24, r24
    1d0a:	91 1d       	adc	r25, r1
    1d0c:	96 95       	lsr	r25
    1d0e:	87 95       	ror	r24
    1d10:	97 f9       	bld	r25, 7
    1d12:	08 95       	ret

00001d14 <_exit>:
    1d14:	f8 94       	cli

00001d16 <__stop_program>:
    1d16:	ff cf       	rjmp	.-2      	; 0x1d16 <__stop_program>
